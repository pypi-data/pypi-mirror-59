"""extended_groups

Revision ID: 46e4971dc46f
Revises: a90076b18837
Create Date: 2017-05-19 17:08:34.780367

"""

# revision identifiers, used by Alembic.
revision = '46e4971dc46f'
down_revision = 'a90076b18837'
branch_labels = None
depends_on = None

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.create_table('grouptypes',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_grouptypes')),
    sa.UniqueConstraint('name', name=op.f('uq_grouptypes_name'))
    )
    op.create_table('grouptypes_grouptypes',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('grouptype_id', sa.BigInteger(), nullable=False),
    sa.Column('part_of_id', sa.BigInteger(), nullable=False),
    sa.ForeignKeyConstraint(['grouptype_id'], ['grouptypes.id'], name=op.f('fk_grouptypes_grouptypes_grouptype_id_grouptypes'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['part_of_id'], ['grouptypes.id'], name=op.f('fk_grouptypes_grouptypes_part_of_id_grouptypes'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_grouptypes_grouptypes')),
    sa.UniqueConstraint('grouptype_id', 'part_of_id', name=op.f('uq_grouptypes_grouptypes_grouptype_id'))
    )
    op.create_index(op.f('ix_grouptypes_grouptypes_grouptype_id'), 'grouptypes_grouptypes', ['grouptype_id'], unique=False)
    op.create_index(op.f('ix_grouptypes_grouptypes_part_of_id'), 'grouptypes_grouptypes', ['part_of_id'], unique=False)
    op.create_table('groups_groups',
    sa.Column('id', sa.BigInteger(), nullable=False),
    sa.Column('group_id', sa.BigInteger(), nullable=False),
    sa.Column('part_of_id', sa.BigInteger(), nullable=False),
    sa.ForeignKeyConstraint(['group_id'], ['groups.id'], name=op.f('fk_groups_groups_group_id_groups'), ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['part_of_id'], ['groups.id'], name=op.f('fk_groups_groups_part_of_id_groups'), ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_groups_groups')),
    sa.UniqueConstraint('group_id', 'part_of_id', name=op.f('uq_groups_groups_group_id'))
    )
    op.create_index(op.f('ix_groups_groups_group_id'), 'groups_groups', ['group_id'], unique=False)
    op.create_index(op.f('ix_groups_groups_part_of_id'), 'groups_groups', ['part_of_id'], unique=False)
    op.add_column('groups', sa.Column('grouptype_id', sa.BigInteger(), nullable=False))
    op.create_index(op.f('ix_groups_grouptype_id'), 'groups', ['grouptype_id'], unique=False)
    op.create_foreign_key(op.f('fk_groups_grouptype_id_grouptypes'), 'groups', 'grouptypes', ['grouptype_id'], ['id'], ondelete='CASCADE')
    ### end Alembic commands ###

    op.execute("""
        CREATE OR REPLACE FUNCTION check_grouptypes_grouptypes_cycle() RETURNS trigger AS $$
    DECLARE
        cycles INTEGER;
    BEGIN
        LOCK TABLE grouptypes_grouptypes IN ACCESS EXCLUSIVE MODE;
        WITH RECURSIVE search_graph(part_of_id, group_id, id, depth, path, cycle) AS (
             SELECT NEW.part_of_id, NEW.group_id, NEW.id, 1,
         	 ARRAY[NEW.id], false
              UNION ALL
                SELECT g.part_of_id, g.group_id, g.id, sg.depth + 1,
         	 path || g.id,
         	 g.id = ANY(path)
                FROM grouptypes_grouptypes g, search_graph sg
                WHERE g.part_of_id = sg.group_id AND NOT cycle
        )
        SELECT INTO cycles COUNT(*) FROM search_graph WHERE cycle=true;
        RAISE NOTICE 'cycles: %', cycles;
        IF cycles > 0 THEN
           RAISE EXCEPTION 'cycle';
        END IF;
        RETURN NEW;
    END
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER check_grouptypes_grouptypes_cycle AFTER INSERT OR UPDATE ON grouptypes_grouptypes
        FOR EACH ROW EXECUTE PROCEDURE check_grouptypes_grouptypes_cycle();
    """)

    op.execute("""
        CREATE OR REPLACE FUNCTION check_groups_groups_cycle() RETURNS trigger AS $$
    DECLARE
        cycles INTEGER;
    BEGIN
        LOCK TABLE groups_groups IN ACCESS EXCLUSIVE MODE;
        WITH RECURSIVE search_graph(part_of_id, group_id, id, depth, path, cycle) AS (
             SELECT NEW.part_of_id, NEW.group_id, NEW.id, 1,
         	 ARRAY[NEW.id], false
              UNION ALL
                SELECT g.part_of_id, g.group_id, g.id, sg.depth + 1,
         	 path || g.id,
         	 g.id = ANY(path)
                FROM groups_groups g, search_graph sg
                WHERE g.part_of_id = sg.group_id AND NOT cycle
        )
        SELECT INTO cycles COUNT(*) FROM search_graph WHERE cycle=true;
        RAISE NOTICE 'cycles: %', cycles;
        IF cycles > 0 THEN
           RAISE EXCEPTION 'cycle';
        END IF;
        RETURN NEW;
    END
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER check_groups_groups_cycle AFTER INSERT OR UPDATE ON groups_groups
        FOR EACH ROW EXECUTE PROCEDURE check_groups_groups_cycle();
    """)


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    raise NotImplementedError()
    ### end Alembic commands ###
