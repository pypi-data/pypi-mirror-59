Metadata-Version: 2.1
Name: kog-lib
Version: 0.2.3
Summary: Simple python lib, processing excel,mail,textgrid,metadata,wav; using for SurfingTech or others
Home-page: UNKNOWN
Author: KOG
Author-email: 52204413@qq.com
License: BSD License
Description: # surfing_pylib
        
        #### Description
        
        冲浪科技python 库
        公司的Python库都在这个仓库中维护统一管理
        
        #### Installation
        
        ​	`pip install kog_lib`
        
        #### Instructions
        
        1. 查看帮助
        
           `import kog_lib`
        
           `kog_lib.help()`
        
           `kog_lib.help(type)`
        
           ​	`type in {'excel','textgrid','metadata','wav','fs','utils'}`
        
        2. excel读取和写入
        
           ```python
               实例化：
                   my_excel = kog_lib.Excel(excel_path)
                   或，
                   my_excel = kog_lib.Excel()
                   my_excel.load(excel_path)
           
               数据读取：
                   my_excel.data = [
                       [第一行],
                       [第二行],
                       ...
                       [最后一行]
                   ]
           
               写入数据：
                   my_excel.make(data, filename='name1.xls', sheetname='sheet1')
                       data是一个二位的列表，如上述“数据读取”部分的“my_excel.data”
           
               打印内容：
                   my_excel.print(part,n)
                       part: "all" 、"head" 、"tail"：全部打印、 从头打印n个、 从尾部打印n个
                       n: 打印个数
           ```
           
        3. textgrid文件操作
        
           ```python
               类实例化
                   方式1:
                       my_tg = kog_lib.SFTextGrid()
                       my_tg.load(path)
                   方式2:
                       my_tg = kog_lib.SFTextGrid(path)
           
               获取有效时长等信息：
                   : t_file, t_effect, t_invalid, n_invalid =
                                   my_tg.get_textgrid_stat(re_str)  # re_str是正则表达式
                   : 返回， 总时长、有效时长、无效时长、无效个数
           
               修改textgrid中相关内容
                   : my_tg.sup_interval(item_ind,interval_ind,type,sup_str)
                       item_ind: item的序号, 0 或者 1
                       ind_ininterval_indterval:interval的序号，从1开始
                       type: 修改interval的哪个字段,maxtime、mintime、mark
                       sup_str:修改成sup_str
           
               textgrid中speaker检测：
                   : my_tg.check_with_txt(txt_path)
                       txt_path: 记录speaker相关信息的txt文件
                   先检查textgrid是否有误、在检查txt_path是否正确，最后看textgrid中的speaker是否在txt中
           
               textgrid检查：
                   : my_tg.check():
           ```
        
        4. metadata文件操作
        
           ```python
               实例化:
                   my_metadata = kog_lib.SFMetadata()
                       此时会实例化一个默认的metadata模板
           
               导入metadata模板:
                   my_metadata.load_template(filepath)
                       也可以读取现有的metadata文件作为模板
           
               修改metadata文件内容:
                   my_metadata.set_metadata_element(key,value)
                       如: my_metadata.set_metadata_element("BIR","北美")
           
               获取metadata某个key的值:
                   my_metadata.get_metadata_element(key)
                       如: value = my_metadata.get_metadata_element("BIR") # value="北美"
           
               生产metadata文件:
                   my_metadata.make_metadata(output)
                       如: my_metadata.make_metadata("/data/xxxx.metadata")
           ```
           
        5. wav音频分析处理
        
           ```python
               实例化：
                   my_wav = kog_lib.SFWav(wav_path)
                   或，
                   my_wav = kog_lib.SFWav()
                   my_wav.open(wav_path)
           
               获取主要参数：(声道数、样本宽度、采样率、总帧数)
                   my_wav.getparams()
           
               得到区间内峰值：
                   my_wav.get_peak(selected_channel,start_time,end_time)
                       selected_channel: 要得到哪个声道的数据，默认1声道
                       start_time: 起始时间，默认0
                       end_time: 终止时间，默认总时长
           
               切割音频: 从start_time开始且切到end_time时长的音频，保存到output
                   my_wav.cut_wav(output,start_time,end_time,selectedchannel=1)
                       默认切取第一个声道的信息，保存为单声道音频
           
               其他方法：
                   my_wav.readframes(nframes,start_frame) # 从第几帧开始读取多少帧
                   my_wav.readframes_bytime(start_time,end_time) # 从第几秒开始读到第几秒
           ```
           
        6. filesystem文件系统
        
           ```python
               实例化：此时会将当前目录挂载到文件系统
                   root_fs = kog_lib.SFFS()
           
               显示当前服务器配置：
                   root_fs.show_current_server_config()
           
               新增服务器系统配置：
                   root_fs.add_server_config(s_key,s_path)
                       s_key:服务器简称，例如 "SVR1"
                       s_path:服务器路径，例如 "ssh://username:password@192.168.1.104:22"
           
               挂载文件系统：
                   挂载本机其他路径：
                       root_fs.combine_fs("local_samples","/samples")
                   挂载ssh远程服务器
                       root_fs.combine_fs("my_ubuntu","MY_UBUNTU")
                           ps："MY_UBUNTU"的配置已经add_server_config过了
                   挂载FTP服务器
                       root_fs.combine_fs("surfing_ftp","SFTP")
                           ps："SFTP"的配置已经add_server_config过了
                   挂载tar和zip文件系统（系统根目录下的压缩包）
                       root_fs.combine_fs("tar_1","/test.tar.gz",write=True,compression="gz")
                       root_fs.combine_fs("zip_1","/test.zip",write=True,compression=0)
           
               挂载文件系统后，可将各文件系统视为根目录下的子目录，可直接进行各种文件操作，如：
                   ***很多操作在root_fs.close()后才会生效***
                   返回根目录下列表
                       my_fs = root_fs.get_combined_fs()
                       my_fs.listdir("/")
                   打印目录结构
                       my_fs.tree(path="/",max_levels = 1)
                   复制 从my_ubuntu复制到tar压缩包内(仅可向新建的tar中写入，及write=True)
                       my_fs.copy("/my_ubuntu/p2.py","/tar_1/1.py",overwrite=True)
                   在tar中创建多层目录，并向此目录复制文件
                       my_fs.makedirs("/tar_1/x/xx")(仅可向新建的tar中写入，及write=True)
                       my_fs.copy("/my_ubuntu/p2.py","/tar_1/x/xx/1.py",overwrite=True)
                   复制 从my_ubuntu复制到zip压缩包内(仅可向新建的zip中写入，及write=True)
                       my_fs.copy("/my_ubuntu/p2.py","/zip_1/1.py",overwrite=True)
                   在zip中创建多层目录，并向此目录复制文件(仅可向新建的zip中写入，及write=True)
                       my_fs.makedirs("/zip_1/x/xx")
                       my_fs.copy("/my_ubuntu//p2.py","/zip_1/x/xx/1.py",overwrite=True)
                       my_fs.copydir("/my_ubuntu/scripts","/local_current/scripts",create=True)
           
                   其他更详细的用法见pyfilesystem2的介绍:
           ```
           
        7. utils通用方法
        
           ```python
               按行读文件：
                   kog_lib.SFUtils.get_file_lines(path)
           
               按行读文件并去重：
                   kog_lib.SFUtils.get_uniq_lines_from_file(path)
           
               列表去重：
                   kog_lib.SFUtils.uniq_lines(lines)
           
               列表写入文件：
                   kog_lib.SFUtils.write_lines(filepath,lines)
           
               行（字符串）切割，并清洗：
                   kog_lib.SFUtils.split_clean_line(line,split_char,begin_re,end_re,clean_chinese)
                       line:要切割的字符串
                       split_char:以这个字符切分
                       begin_re: 清洗字符串line头部的正则，默认 儿童英语项目的正则
                       end_re: 清洗字符串line尾部的正则，默认 儿童英语项目的正则
                       clean_chinese: 是否清除汉字，默认 清除汉字
           
               根据正则表达式re_str清洗某行：
                   kog_lib.SFUtils.clean_line(line,re_str)
           
               根据正则表达式re_str按行清洗某列表：
                   kog_lib.SFUtils.clean_lines(lines,re_str)
           
               根据正则表达式re_str按行清洗某列表，返回列表元素是(新行，原行)的元组：
                   kog_lib.SFUtils.clean_lines_map_list(line,re_str)
           
               比较两个list，返回A中不再B的元素：
                   kog_lib.SFUtils.diff_list(A,B)
           
               以空格区分，返回某行的词数：
                   kog_lib.SFUtils.get_wordcount_from_line(line)
           
               以空格区分，返回某列表次数：
                   kog_lib.SFUtils.get_wordcount_from_line(lines)
           
               对列表lines分组，每组requaired_lines行，返回组列表的列表：
                   kog_lib.SFUtils.lines_split_2_sublines(lines,requaired_lines)
           
               获取str1到str2的编辑距离：
                   kog_lib.SFUtils.get_edit_distance(str1,str2)
           
               获取str1到str2的编辑步骤：
                   kog_lib.SFUtils.get_edit_ops(str1,str2)
           
               打印str1转换到str2的详细步骤：
                   kog_lib.SFUtils.print_edit_ops(str1,str2)
           
               打印列表：
                   kog_lib.SFUtils.print_lines(lines)
           
               打印字典：
                   kog_lib.SFUtils.print_dict(dict)
           
               批量重命名：
                   kog_lib.SFUtils.modify_name(path,prefix="",suffix="",mode="add",deep=False)
                       path: 修改path路径下文件和文件夹的名称，不含path
                       prefix: 要加的前缀
                       suffix: 要加的后缀
                       mode: 模式，add/minus
                       deep: True：深度重命名（遍历path下文件及文件夹）
                             False：仅对path下文件和文件夹进行重命名
           ```
        
Platform: all
Classifier: Development Status :: 4 - Beta
Classifier: Operating System :: OS Independent
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: BSD License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Topic :: Software Development :: Libraries
Description-Content-Type: text/markdown
