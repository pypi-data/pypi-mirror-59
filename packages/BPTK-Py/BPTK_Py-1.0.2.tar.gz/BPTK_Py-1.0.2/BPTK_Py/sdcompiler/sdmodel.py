#                                                       /`-
# _                                  _   _             /####`-
# | |                                | | (_)           /########`-
# | |_ _ __ __ _ _ __  ___  ___ _ __ | |_ _ ___       /###########`-
# | __| '__/ _` | '_ \/ __|/ _ \ '_ \| __| / __|   ____ -###########/
# | |_| | | (_| | | | \__ \  __/ | | | |_| \__ \  |    | `-#######/
# \__|_|  \__,_|_| |_|___/\___|_| |_|\__|_|___/  |____|    `- # /
#
# Copyright (c) 2019 transentis labs GmbH
# MIT License

###################
## SDModel Class ##
###################
# This is the main class for Python SD Models generated by the SD Compiler

# linear interpolation between a set of points
import numpy as np
from scipy.interpolate import interp1d
import re
import logging

import itertools

def cartesian_product(listoflists):
    """
    Helper for Cartesian product
    :param listoflists:
    :return:
    """
    if len(listoflists) == 1:
        return listoflists[0]
    res = list(itertools.product(*listoflists))

    if len(res) == 1:
        return res[0]

    return res

def LERP(x,points):
    """
    Linear interpolation between a set of points
    :param x: x to obtain y for
    :param points: List of tuples containing the graphical function's points [(x,y),(x,y) ... ]
    :return: y value for x obtained using linear interpolation
    """
    x_vals = np.array([ x[0] for x in points])
    y_vals = np.array([x[1] for x in points])

    if x<= x_vals[0]:
        return y_vals[0]

    if x >= x_vals[len(x_vals)-1]:
        return y_vals[len(x_vals)-1]

    f = interp1d(x_vals, y_vals)
    return float(f(x))

class UnsupportedListIndexException(Exception):
    pass

def findListIndex(index):
    split_index = index.split(":")
    if len(split_index) == 2:
        return [x for x in range(int(split_index[0]), int(split_index[1]) + 1)]
    if len(split_index) > 2:
        logging.error("Multiple list indices are not supported! Indices: {}".format(index))
        raise UnsupportedListIndexException("Multiple list indices are not supported! Indices: {}".format(index))
    return split_index

def getEquationAsList(args):
    if len(args) == 1:
        return args


class SDModel():
    def delay(self, tdelayed, offset, initial, t):
        if (t - self.starttime) < offset:
            return initial
        else:  # Sonst returne die gegebene Gleichung minus das offset
            return tdelayed

    def find_dimensions(self, stock):
        stockdimensions = {}
        for dimension, values in self.dimensions.items():
            if stock in values["variables"]:
                stockdimensions[dimension] = values["labels"]

        if len(stockdimensions.keys()) == 1:
            return [stock + "[{}]".format(x) for x in stockdimensions[list(stockdimensions.keys())[0]]]

    def get_dimensions(self, equation, t):
        re_find_indices = r'\[([^)]+)\]'
        group = re.search(re_find_indices, equation).group(0).replace("[", "").replace("]", "")
        equation_basic = equation.replace(group, "").replace("[]", "")
        labels = []
        for index, elem in enumerate(group.split(",")):
            if elem == "*":
                dim = self.dimensions_order[equation_basic][index]
                labels += [self.dimensions[dim]["labels"]]
            else:
                if not type(elem) is list:
                    labels += [[elem]]
                else:
                    labels += [elem]

        products = cartesian_product(labels)


        return_list = []

        for product in products:
            prod = str(product).replace("(", "").replace(")", "").replace("[", "").replace("]", "").replace("'", "").replace(" ", "")
            return_list += [self.memoize(equation_basic + "[{}]".format(prod), t)]

        return return_list

    def equation(self, equation, arg):
        return self.memoize(equation,arg)

    def memoize(self, equation, arg):
        if "*" in equation:
            return self.get_dimensions(equation,arg)

        mymemo = self.memo[equation]
        if arg in mymemo.keys():
            return mymemo[arg]
        else:
            result = self.equations[equation](arg)
            mymemo[arg] = result

        return result

    def __init__(self):
        # Simulation Buildins
        self.dt = 1
        self.starttime = 0
        self.stoptime = 0
        self.units = '1'
        self.method = 'None'

        self.equations = {}
        self.stocks = []

        self.flows = []
        self.converters = []
        self.gf = []
        self.constants = []
        self.events = []
        self.dimensions = {}
        self.dimensions_order = {}

        self.memo = {}
        for key in list(self.equations.keys()):
            self.memo[key] = {}  # DICT OF DICTS!

    def setDT(self, v):
        self.dt = v

    def setStarttime(self, v):
        self.starttime = v

    def setStoptime(self, v):
        self.stoptime = v

    def specs(self):
        return self.starttime, self.stoptime, self.dt, self.units, self.method

