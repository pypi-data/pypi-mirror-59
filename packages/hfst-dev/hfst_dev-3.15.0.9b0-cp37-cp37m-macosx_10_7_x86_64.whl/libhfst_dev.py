# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libhfst_dev', [dirname(__file__)])
        except ImportError:
            import _libhfst_dev
            return _libhfst_dev
        if fp is not None:
            try:
                _mod = imp.load_module('_libhfst_dev', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libhfst_dev = swig_import_helper()
    del swig_import_helper
else:
    import _libhfst_dev
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst_dev.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _libhfst_dev.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _libhfst_dev.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _libhfst_dev.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _libhfst_dev.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _libhfst_dev.SwigPyIterator_equal(self, x)

    def copy(self):
        return _libhfst_dev.SwigPyIterator_copy(self)

    def next(self):
        return _libhfst_dev.SwigPyIterator_next(self)

    def __next__(self):
        return _libhfst_dev.SwigPyIterator___next__(self)

    def previous(self):
        return _libhfst_dev.SwigPyIterator_previous(self)

    def advance(self, n):
        return _libhfst_dev.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _libhfst_dev.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _libhfst_dev.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _libhfst_dev.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _libhfst_dev.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _libhfst_dev.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _libhfst_dev.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _libhfst_dev.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.StringVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.StringVector_pop(self)

    def append(self, x):
        return _libhfst_dev.StringVector_append(self, x)

    def empty(self):
        return _libhfst_dev.StringVector_empty(self)

    def size(self):
        return _libhfst_dev.StringVector_size(self)

    def swap(self, v):
        return _libhfst_dev.StringVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.StringVector_begin(self)

    def end(self):
        return _libhfst_dev.StringVector_end(self)

    def rbegin(self):
        return _libhfst_dev.StringVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringVector_rend(self)

    def clear(self):
        return _libhfst_dev.StringVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.StringVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.StringVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.StringVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.StringVector_front(self)

    def back(self):
        return _libhfst_dev.StringVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.StringVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.StringVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.StringVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.StringVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _libhfst_dev.StringVector_swigregister
StringVector_swigregister(StringVector)

class StringPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_StringPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.StringPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.StringPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.StringPair_first_get, _libhfst_dev.StringPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.StringPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.StringPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.StringPair_second_get, _libhfst_dev.StringPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_StringPair
    __del__ = lambda self: None
StringPair_swigregister = _libhfst_dev.StringPair_swigregister
StringPair_swigregister(StringPair)

class StringPairVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringPairVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringPairVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringPairVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringPairVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringPairVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.StringPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.StringPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.StringPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.StringPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.StringPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.StringPairVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.StringPairVector_pop(self)

    def append(self, x):
        return _libhfst_dev.StringPairVector_append(self, x)

    def empty(self):
        return _libhfst_dev.StringPairVector_empty(self)

    def size(self):
        return _libhfst_dev.StringPairVector_size(self)

    def swap(self, v):
        return _libhfst_dev.StringPairVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.StringPairVector_begin(self)

    def end(self):
        return _libhfst_dev.StringPairVector_end(self)

    def rbegin(self):
        return _libhfst_dev.StringPairVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringPairVector_rend(self)

    def clear(self):
        return _libhfst_dev.StringPairVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.StringPairVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.StringPairVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.StringPairVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringPairVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.StringPairVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.StringPairVector_front(self)

    def back(self):
        return _libhfst_dev.StringPairVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.StringPairVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.StringPairVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.StringPairVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.StringPairVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.StringPairVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_StringPairVector
    __del__ = lambda self: None
StringPairVector_swigregister = _libhfst_dev.StringPairVector_swigregister
StringPairVector_swigregister(StringPairVector)

class FloatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.FloatVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.FloatVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.FloatVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.FloatVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.FloatVector_pop(self)

    def append(self, x):
        return _libhfst_dev.FloatVector_append(self, x)

    def empty(self):
        return _libhfst_dev.FloatVector_empty(self)

    def size(self):
        return _libhfst_dev.FloatVector_size(self)

    def swap(self, v):
        return _libhfst_dev.FloatVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.FloatVector_begin(self)

    def end(self):
        return _libhfst_dev.FloatVector_end(self)

    def rbegin(self):
        return _libhfst_dev.FloatVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.FloatVector_rend(self)

    def clear(self):
        return _libhfst_dev.FloatVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.FloatVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.FloatVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.FloatVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_FloatVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.FloatVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.FloatVector_front(self)

    def back(self):
        return _libhfst_dev.FloatVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.FloatVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.FloatVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.FloatVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.FloatVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.FloatVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_FloatVector
    __del__ = lambda self: None
FloatVector_swigregister = _libhfst_dev.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class StringSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringSet, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringSet___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringSet___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringSet___len__(self)

    def append(self, x):
        return _libhfst_dev.StringSet_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.StringSet___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.StringSet___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.StringSet_add(self, x)

    def discard(self, x):
        return _libhfst_dev.StringSet_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringSet(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.StringSet_empty(self)

    def size(self):
        return _libhfst_dev.StringSet_size(self)

    def clear(self):
        return _libhfst_dev.StringSet_clear(self)

    def swap(self, v):
        return _libhfst_dev.StringSet_swap(self, v)

    def count(self, x):
        return _libhfst_dev.StringSet_count(self, x)

    def begin(self):
        return _libhfst_dev.StringSet_begin(self)

    def end(self):
        return _libhfst_dev.StringSet_end(self)

    def rbegin(self):
        return _libhfst_dev.StringSet_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringSet_rend(self)

    def erase(self, *args):
        return _libhfst_dev.StringSet_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.StringSet_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.StringSet_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.StringSet_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.StringSet_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.StringSet_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_StringSet
    __del__ = lambda self: None
StringSet_swigregister = _libhfst_dev.StringSet_swigregister
StringSet_swigregister(StringSet)

class StringPairSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringPairSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringPairSet, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringPairSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringPairSet___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringPairSet___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringPairSet___len__(self)

    def append(self, x):
        return _libhfst_dev.StringPairSet_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.StringPairSet___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.StringPairSet___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.StringPairSet_add(self, x)

    def discard(self, x):
        return _libhfst_dev.StringPairSet_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringPairSet(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.StringPairSet_empty(self)

    def size(self):
        return _libhfst_dev.StringPairSet_size(self)

    def clear(self):
        return _libhfst_dev.StringPairSet_clear(self)

    def swap(self, v):
        return _libhfst_dev.StringPairSet_swap(self, v)

    def count(self, x):
        return _libhfst_dev.StringPairSet_count(self, x)

    def begin(self):
        return _libhfst_dev.StringPairSet_begin(self)

    def end(self):
        return _libhfst_dev.StringPairSet_end(self)

    def rbegin(self):
        return _libhfst_dev.StringPairSet_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringPairSet_rend(self)

    def erase(self, *args):
        return _libhfst_dev.StringPairSet_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.StringPairSet_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.StringPairSet_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.StringPairSet_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.StringPairSet_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.StringPairSet_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_StringPairSet
    __del__ = lambda self: None
StringPairSet_swigregister = _libhfst_dev.StringPairSet_swigregister
StringPairSet_swigregister(StringPairSet)

class HfstTransducerVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTransducerVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTransducerVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTransducerVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTransducerVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstTransducerVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstTransducerVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstTransducerVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstTransducerVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstTransducerVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstTransducerVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstTransducerVector_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstTransducerVector_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstTransducerVector_empty(self)

    def size(self):
        return _libhfst_dev.HfstTransducerVector_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstTransducerVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstTransducerVector_begin(self)

    def end(self):
        return _libhfst_dev.HfstTransducerVector_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTransducerVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTransducerVector_rend(self)

    def clear(self):
        return _libhfst_dev.HfstTransducerVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstTransducerVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstTransducerVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTransducerVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstTransducerVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstTransducerVector_front(self)

    def back(self):
        return _libhfst_dev.HfstTransducerVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstTransducerVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstTransducerVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstTransducerVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstTransducerVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstTransducerVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerVector
    __del__ = lambda self: None
HfstTransducerVector_swigregister = _libhfst_dev.HfstTransducerVector_swigregister
HfstTransducerVector_swigregister(HfstTransducerVector)

class HfstSymbolSubstitutions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstSymbolSubstitutions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstSymbolSubstitutions, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstSymbolSubstitutions___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstSymbolSubstitutions___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstSymbolSubstitutions___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions___getitem__(self, key)

    def __delitem__(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions___delitem__(self, key)

    def has_key(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions_has_key(self, key)

    def keys(self):
        return _libhfst_dev.HfstSymbolSubstitutions_keys(self)

    def values(self):
        return _libhfst_dev.HfstSymbolSubstitutions_values(self)

    def items(self):
        return _libhfst_dev.HfstSymbolSubstitutions_items(self)

    def __contains__(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions___contains__(self, key)

    def key_iterator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_key_iterator(self)

    def value_iterator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_value_iterator(self)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstSymbolSubstitutions___setitem__(self, *args)

    def asdict(self):
        return _libhfst_dev.HfstSymbolSubstitutions_asdict(self)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstSymbolSubstitutions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstSymbolSubstitutions_empty(self)

    def size(self):
        return _libhfst_dev.HfstSymbolSubstitutions_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstSymbolSubstitutions_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstSymbolSubstitutions_begin(self)

    def end(self):
        return _libhfst_dev.HfstSymbolSubstitutions_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstSymbolSubstitutions_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstSymbolSubstitutions_rend(self)

    def clear(self):
        return _libhfst_dev.HfstSymbolSubstitutions_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_get_allocator(self)

    def count(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_count(self, x)

    def erase(self, *args):
        return _libhfst_dev.HfstSymbolSubstitutions_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_upper_bound(self, x)
    __swig_destroy__ = _libhfst_dev.delete_HfstSymbolSubstitutions
    __del__ = lambda self: None
HfstSymbolSubstitutions_swigregister = _libhfst_dev.HfstSymbolSubstitutions_swigregister
HfstSymbolSubstitutions_swigregister(HfstSymbolSubstitutions)

class HfstSymbolPairSubstitutions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstSymbolPairSubstitutions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstSymbolPairSubstitutions, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions___getitem__(self, key)

    def __delitem__(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions___delitem__(self, key)

    def has_key(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions_has_key(self, key)

    def keys(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_keys(self)

    def values(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_values(self)

    def items(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_items(self)

    def __contains__(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions___contains__(self, key)

    def key_iterator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_key_iterator(self)

    def value_iterator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_value_iterator(self)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstSymbolPairSubstitutions___setitem__(self, *args)

    def asdict(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_asdict(self)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstSymbolPairSubstitutions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_empty(self)

    def size(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstSymbolPairSubstitutions_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_begin(self)

    def end(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_rend(self)

    def clear(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_get_allocator(self)

    def count(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_count(self, x)

    def erase(self, *args):
        return _libhfst_dev.HfstSymbolPairSubstitutions_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_upper_bound(self, x)
    __swig_destroy__ = _libhfst_dev.delete_HfstSymbolPairSubstitutions
    __del__ = lambda self: None
HfstSymbolPairSubstitutions_swigregister = _libhfst_dev.HfstSymbolPairSubstitutions_swigregister
HfstSymbolPairSubstitutions_swigregister(HfstSymbolPairSubstitutions)

class BarBazFoo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BarBazFoo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BarBazFoo, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.BarBazFoo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.BarBazFoo___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.BarBazFoo___bool__(self)

    def __len__(self):
        return _libhfst_dev.BarBazFoo___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.BarBazFoo___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.BarBazFoo___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.BarBazFoo___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.BarBazFoo___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.BarBazFoo___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.BarBazFoo___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.BarBazFoo_pop(self)

    def append(self, x):
        return _libhfst_dev.BarBazFoo_append(self, x)

    def empty(self):
        return _libhfst_dev.BarBazFoo_empty(self)

    def size(self):
        return _libhfst_dev.BarBazFoo_size(self)

    def swap(self, v):
        return _libhfst_dev.BarBazFoo_swap(self, v)

    def begin(self):
        return _libhfst_dev.BarBazFoo_begin(self)

    def end(self):
        return _libhfst_dev.BarBazFoo_end(self)

    def rbegin(self):
        return _libhfst_dev.BarBazFoo_rbegin(self)

    def rend(self):
        return _libhfst_dev.BarBazFoo_rend(self)

    def clear(self):
        return _libhfst_dev.BarBazFoo_clear(self)

    def get_allocator(self):
        return _libhfst_dev.BarBazFoo_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.BarBazFoo_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.BarBazFoo_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_BarBazFoo(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.BarBazFoo_push_back(self, x)

    def front(self):
        return _libhfst_dev.BarBazFoo_front(self)

    def back(self):
        return _libhfst_dev.BarBazFoo_back(self)

    def assign(self, n, x):
        return _libhfst_dev.BarBazFoo_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.BarBazFoo_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.BarBazFoo_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.BarBazFoo_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.BarBazFoo_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_BarBazFoo
    __del__ = lambda self: None
BarBazFoo_swigregister = _libhfst_dev.BarBazFoo_swigregister
BarBazFoo_swigregister(BarBazFoo)

class HfstTransitions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransitions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransitions, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTransitions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTransitions___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTransitions___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTransitions___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstTransitions___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstTransitions___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstTransitions___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstTransitions___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstTransitions___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstTransitions___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstTransitions_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstTransitions_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstTransitions_empty(self)

    def size(self):
        return _libhfst_dev.HfstTransitions_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstTransitions_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstTransitions_begin(self)

    def end(self):
        return _libhfst_dev.HfstTransitions_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTransitions_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTransitions_rend(self)

    def clear(self):
        return _libhfst_dev.HfstTransitions_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstTransitions_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstTransitions_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTransitions_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransitions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstTransitions_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstTransitions_front(self)

    def back(self):
        return _libhfst_dev.HfstTransitions_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstTransitions_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstTransitions_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstTransitions_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstTransitions_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstTransitions_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstTransitions
    __del__ = lambda self: None
HfstTransitions_swigregister = _libhfst_dev.HfstTransitions_swigregister
HfstTransitions_swigregister(HfstTransitions)

class HfstOneLevelPath(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstOneLevelPath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstOneLevelPath, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstOneLevelPath(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstOneLevelPath_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstOneLevelPath_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstOneLevelPath_first_get, _libhfst_dev.HfstOneLevelPath_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstOneLevelPath_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstOneLevelPath_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstOneLevelPath_second_get, _libhfst_dev.HfstOneLevelPath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstOneLevelPath
    __del__ = lambda self: None
HfstOneLevelPath_swigregister = _libhfst_dev.HfstOneLevelPath_swigregister
HfstOneLevelPath_swigregister(HfstOneLevelPath)

class HfstOneLevelPaths(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstOneLevelPaths, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstOneLevelPaths, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstOneLevelPaths_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstOneLevelPaths___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstOneLevelPaths___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstOneLevelPaths___len__(self)

    def append(self, x):
        return _libhfst_dev.HfstOneLevelPaths_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.HfstOneLevelPaths___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.HfstOneLevelPaths___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.HfstOneLevelPaths_add(self, x)

    def discard(self, x):
        return _libhfst_dev.HfstOneLevelPaths_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstOneLevelPaths(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstOneLevelPaths_empty(self)

    def size(self):
        return _libhfst_dev.HfstOneLevelPaths_size(self)

    def clear(self):
        return _libhfst_dev.HfstOneLevelPaths_clear(self)

    def swap(self, v):
        return _libhfst_dev.HfstOneLevelPaths_swap(self, v)

    def count(self, x):
        return _libhfst_dev.HfstOneLevelPaths_count(self, x)

    def begin(self):
        return _libhfst_dev.HfstOneLevelPaths_begin(self)

    def end(self):
        return _libhfst_dev.HfstOneLevelPaths_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstOneLevelPaths_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstOneLevelPaths_rend(self)

    def erase(self, *args):
        return _libhfst_dev.HfstOneLevelPaths_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstOneLevelPaths_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstOneLevelPaths_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstOneLevelPaths_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.HfstOneLevelPaths_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.HfstOneLevelPaths_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_HfstOneLevelPaths
    __del__ = lambda self: None
HfstOneLevelPaths_swigregister = _libhfst_dev.HfstOneLevelPaths_swigregister
HfstOneLevelPaths_swigregister(HfstOneLevelPaths)

class HfstTwoLevelPath(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTwoLevelPath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTwoLevelPath, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTwoLevelPath(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTwoLevelPath_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTwoLevelPath_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTwoLevelPath_first_get, _libhfst_dev.HfstTwoLevelPath_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTwoLevelPath_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTwoLevelPath_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTwoLevelPath_second_get, _libhfst_dev.HfstTwoLevelPath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTwoLevelPath
    __del__ = lambda self: None
HfstTwoLevelPath_swigregister = _libhfst_dev.HfstTwoLevelPath_swigregister
HfstTwoLevelPath_swigregister(HfstTwoLevelPath)

class HfstTwoLevelPaths(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTwoLevelPaths, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTwoLevelPaths, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTwoLevelPaths_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTwoLevelPaths___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTwoLevelPaths___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTwoLevelPaths___len__(self)

    def append(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.HfstTwoLevelPaths___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.HfstTwoLevelPaths___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_add(self, x)

    def discard(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTwoLevelPaths(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstTwoLevelPaths_empty(self)

    def size(self):
        return _libhfst_dev.HfstTwoLevelPaths_size(self)

    def clear(self):
        return _libhfst_dev.HfstTwoLevelPaths_clear(self)

    def swap(self, v):
        return _libhfst_dev.HfstTwoLevelPaths_swap(self, v)

    def count(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_count(self, x)

    def begin(self):
        return _libhfst_dev.HfstTwoLevelPaths_begin(self)

    def end(self):
        return _libhfst_dev.HfstTwoLevelPaths_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTwoLevelPaths_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTwoLevelPaths_rend(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTwoLevelPaths_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.HfstTwoLevelPaths_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_HfstTwoLevelPaths
    __del__ = lambda self: None
HfstTwoLevelPaths_swigregister = _libhfst_dev.HfstTwoLevelPaths_swigregister
HfstTwoLevelPaths_swigregister(HfstTwoLevelPaths)

class HfstTransducerPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTransducerPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTransducerPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTransducerPair_first_get, _libhfst_dev.HfstTransducerPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTransducerPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTransducerPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTransducerPair_second_get, _libhfst_dev.HfstTransducerPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerPair
    __del__ = lambda self: None
HfstTransducerPair_swigregister = _libhfst_dev.HfstTransducerPair_swigregister
HfstTransducerPair_swigregister(HfstTransducerPair)

class HfstTransducerPairVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerPairVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerPairVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTransducerPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTransducerPairVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTransducerPairVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTransducerPairVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstTransducerPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstTransducerPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstTransducerPairVector_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstTransducerPairVector_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstTransducerPairVector_empty(self)

    def size(self):
        return _libhfst_dev.HfstTransducerPairVector_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstTransducerPairVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstTransducerPairVector_begin(self)

    def end(self):
        return _libhfst_dev.HfstTransducerPairVector_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTransducerPairVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTransducerPairVector_rend(self)

    def clear(self):
        return _libhfst_dev.HfstTransducerPairVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstTransducerPairVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstTransducerPairVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTransducerPairVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerPairVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstTransducerPairVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstTransducerPairVector_front(self)

    def back(self):
        return _libhfst_dev.HfstTransducerPairVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstTransducerPairVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstTransducerPairVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstTransducerPairVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstTransducerPairVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstTransducerPairVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerPairVector
    __del__ = lambda self: None
HfstTransducerPairVector_swigregister = _libhfst_dev.HfstTransducerPairVector_swigregister
HfstTransducerPairVector_swigregister(HfstTransducerPairVector)

class HfstRuleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstRuleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstRuleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstRuleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstRuleVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstRuleVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstRuleVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstRuleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstRuleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstRuleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstRuleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstRuleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstRuleVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstRuleVector_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstRuleVector_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstRuleVector_empty(self)

    def size(self):
        return _libhfst_dev.HfstRuleVector_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstRuleVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstRuleVector_begin(self)

    def end(self):
        return _libhfst_dev.HfstRuleVector_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstRuleVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstRuleVector_rend(self)

    def clear(self):
        return _libhfst_dev.HfstRuleVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstRuleVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstRuleVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstRuleVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstRuleVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstRuleVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstRuleVector_front(self)

    def back(self):
        return _libhfst_dev.HfstRuleVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstRuleVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstRuleVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstRuleVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstRuleVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstRuleVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstRuleVector
    __del__ = lambda self: None
HfstRuleVector_swigregister = _libhfst_dev.HfstRuleVector_swigregister
HfstRuleVector_swigregister(HfstRuleVector)

class HfstTransducerUIntPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerUIntPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerUIntPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerUIntPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTransducerUIntPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTransducerUIntPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTransducerUIntPair_first_get, _libhfst_dev.HfstTransducerUIntPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTransducerUIntPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTransducerUIntPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTransducerUIntPair_second_get, _libhfst_dev.HfstTransducerUIntPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerUIntPair
    __del__ = lambda self: None
HfstTransducerUIntPair_swigregister = _libhfst_dev.HfstTransducerUIntPair_swigregister
HfstTransducerUIntPair_swigregister(HfstTransducerUIntPair)

class LocationVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocationVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocationVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.LocationVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.LocationVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.LocationVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.LocationVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.LocationVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.LocationVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.LocationVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.LocationVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.LocationVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.LocationVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.LocationVector_pop(self)

    def append(self, x):
        return _libhfst_dev.LocationVector_append(self, x)

    def empty(self):
        return _libhfst_dev.LocationVector_empty(self)

    def size(self):
        return _libhfst_dev.LocationVector_size(self)

    def swap(self, v):
        return _libhfst_dev.LocationVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.LocationVector_begin(self)

    def end(self):
        return _libhfst_dev.LocationVector_end(self)

    def rbegin(self):
        return _libhfst_dev.LocationVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.LocationVector_rend(self)

    def clear(self):
        return _libhfst_dev.LocationVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.LocationVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.LocationVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.LocationVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_LocationVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.LocationVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.LocationVector_front(self)

    def back(self):
        return _libhfst_dev.LocationVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.LocationVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.LocationVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.LocationVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.LocationVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.LocationVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_LocationVector
    __del__ = lambda self: None
LocationVector_swigregister = _libhfst_dev.LocationVector_swigregister
LocationVector_swigregister(LocationVector)

class LocationVectorVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocationVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocationVectorVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.LocationVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.LocationVectorVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.LocationVectorVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.LocationVectorVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.LocationVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.LocationVectorVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.LocationVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.LocationVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.LocationVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.LocationVectorVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.LocationVectorVector_pop(self)

    def append(self, x):
        return _libhfst_dev.LocationVectorVector_append(self, x)

    def empty(self):
        return _libhfst_dev.LocationVectorVector_empty(self)

    def size(self):
        return _libhfst_dev.LocationVectorVector_size(self)

    def swap(self, v):
        return _libhfst_dev.LocationVectorVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.LocationVectorVector_begin(self)

    def end(self):
        return _libhfst_dev.LocationVectorVector_end(self)

    def rbegin(self):
        return _libhfst_dev.LocationVectorVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.LocationVectorVector_rend(self)

    def clear(self):
        return _libhfst_dev.LocationVectorVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.LocationVectorVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.LocationVectorVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.LocationVectorVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_LocationVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.LocationVectorVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.LocationVectorVector_front(self)

    def back(self):
        return _libhfst_dev.LocationVectorVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.LocationVectorVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.LocationVectorVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.LocationVectorVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.LocationVectorVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.LocationVectorVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_LocationVectorVector
    __del__ = lambda self: None
LocationVectorVector_swigregister = _libhfst_dev.LocationVectorVector_swigregister
LocationVectorVector_swigregister(LocationVectorVector)

class FooBar(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FooBar, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FooBar, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_FooBar(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.FooBar_first_set
    __swig_getmethods__["first"] = _libhfst_dev.FooBar_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.FooBar_first_get, _libhfst_dev.FooBar_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.FooBar_second_set
    __swig_getmethods__["second"] = _libhfst_dev.FooBar_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.FooBar_second_get, _libhfst_dev.FooBar_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_FooBar
    __del__ = lambda self: None
FooBar_swigregister = _libhfst_dev.FooBar_swigregister
FooBar_swigregister(FooBar)

class HfstTransducerStringPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerStringPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerStringPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerStringPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTransducerStringPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTransducerStringPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTransducerStringPair_first_get, _libhfst_dev.HfstTransducerStringPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTransducerStringPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTransducerStringPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTransducerStringPair_second_get, _libhfst_dev.HfstTransducerStringPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerStringPair
    __del__ = lambda self: None
HfstTransducerStringPair_swigregister = _libhfst_dev.HfstTransducerStringPair_swigregister
HfstTransducerStringPair_swigregister(HfstTransducerStringPair)

class HfstException(Exception):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstException(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.HfstException_what(self)

    def __str__(self):
        return _libhfst_dev.HfstException___str__(self)
HfstException_swigregister = _libhfst_dev.HfstException_swigregister
HfstException_swigregister(HfstException)

class HfstTransducerTypeMismatchException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerTypeMismatchException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerTypeMismatchException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_HfstTransducerTypeMismatchException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerTypeMismatchException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.HfstTransducerTypeMismatchException_what(self)
HfstTransducerTypeMismatchException_swigregister = _libhfst_dev.HfstTransducerTypeMismatchException_swigregister
HfstTransducerTypeMismatchException_swigregister(HfstTransducerTypeMismatchException)

class ImplementationTypeNotAvailableException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImplementationTypeNotAvailableException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImplementationTypeNotAvailableException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4, type):
        this = _libhfst_dev.new_ImplementationTypeNotAvailableException(arg2, arg3, arg4, type)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_ImplementationTypeNotAvailableException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.ImplementationTypeNotAvailableException_what(self)

    def get_type(self):
        return _libhfst_dev.ImplementationTypeNotAvailableException_get_type(self)
ImplementationTypeNotAvailableException_swigregister = _libhfst_dev.ImplementationTypeNotAvailableException_swigregister
ImplementationTypeNotAvailableException_swigregister(ImplementationTypeNotAvailableException)

class FunctionNotImplementedException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionNotImplementedException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FunctionNotImplementedException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_FunctionNotImplementedException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_FunctionNotImplementedException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.FunctionNotImplementedException_what(self)
FunctionNotImplementedException_swigregister = _libhfst_dev.FunctionNotImplementedException_swigregister
FunctionNotImplementedException_swigregister(FunctionNotImplementedException)

class StreamNotReadableException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamNotReadableException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamNotReadableException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StreamNotReadableException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StreamNotReadableException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StreamNotReadableException_what(self)
StreamNotReadableException_swigregister = _libhfst_dev.StreamNotReadableException_swigregister
StreamNotReadableException_swigregister(StreamNotReadableException)

class StreamCannotBeWrittenException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamCannotBeWrittenException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamCannotBeWrittenException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StreamCannotBeWrittenException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StreamCannotBeWrittenException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StreamCannotBeWrittenException_what(self)
StreamCannotBeWrittenException_swigregister = _libhfst_dev.StreamCannotBeWrittenException_swigregister
StreamCannotBeWrittenException_swigregister(StreamCannotBeWrittenException)

class StreamIsClosedException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamIsClosedException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamIsClosedException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StreamIsClosedException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StreamIsClosedException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StreamIsClosedException_what(self)
StreamIsClosedException_swigregister = _libhfst_dev.StreamIsClosedException_swigregister
StreamIsClosedException_swigregister(StreamIsClosedException)

class EndOfStreamException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndOfStreamException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EndOfStreamException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_EndOfStreamException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_EndOfStreamException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.EndOfStreamException_what(self)
EndOfStreamException_swigregister = _libhfst_dev.EndOfStreamException_swigregister
EndOfStreamException_swigregister(EndOfStreamException)

class TransducerIsCyclicException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerIsCyclicException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerIsCyclicException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerIsCyclicException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerIsCyclicException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerIsCyclicException_what(self)
TransducerIsCyclicException_swigregister = _libhfst_dev.TransducerIsCyclicException_swigregister
TransducerIsCyclicException_swigregister(TransducerIsCyclicException)

class NotTransducerStreamException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotTransducerStreamException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotTransducerStreamException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotTransducerStreamException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotTransducerStreamException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotTransducerStreamException_what(self)
NotTransducerStreamException_swigregister = _libhfst_dev.NotTransducerStreamException_swigregister
NotTransducerStreamException_swigregister(NotTransducerStreamException)

class NotValidAttFormatException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotValidAttFormatException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotValidAttFormatException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotValidAttFormatException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotValidAttFormatException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotValidAttFormatException_what(self)
NotValidAttFormatException_swigregister = _libhfst_dev.NotValidAttFormatException_swigregister
NotValidAttFormatException_swigregister(NotValidAttFormatException)

class NotValidPrologFormatException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotValidPrologFormatException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotValidPrologFormatException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotValidPrologFormatException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotValidPrologFormatException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotValidPrologFormatException_what(self)
NotValidPrologFormatException_swigregister = _libhfst_dev.NotValidPrologFormatException_swigregister
NotValidPrologFormatException_swigregister(NotValidPrologFormatException)

class NotValidLexcFormatException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotValidLexcFormatException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotValidLexcFormatException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotValidLexcFormatException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotValidLexcFormatException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotValidLexcFormatException_what(self)
NotValidLexcFormatException_swigregister = _libhfst_dev.NotValidLexcFormatException_swigregister
NotValidLexcFormatException_swigregister(NotValidLexcFormatException)

class StateIsNotFinalException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StateIsNotFinalException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StateIsNotFinalException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StateIsNotFinalException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StateIsNotFinalException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StateIsNotFinalException_what(self)
StateIsNotFinalException_swigregister = _libhfst_dev.StateIsNotFinalException_swigregister
StateIsNotFinalException_swigregister(StateIsNotFinalException)

class ContextTransducersAreNotAutomataException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContextTransducersAreNotAutomataException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContextTransducersAreNotAutomataException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_ContextTransducersAreNotAutomataException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_ContextTransducersAreNotAutomataException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.ContextTransducersAreNotAutomataException_what(self)
ContextTransducersAreNotAutomataException_swigregister = _libhfst_dev.ContextTransducersAreNotAutomataException_swigregister
ContextTransducersAreNotAutomataException_swigregister(ContextTransducersAreNotAutomataException)

class TransducersAreNotAutomataException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducersAreNotAutomataException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducersAreNotAutomataException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducersAreNotAutomataException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducersAreNotAutomataException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducersAreNotAutomataException_what(self)
TransducersAreNotAutomataException_swigregister = _libhfst_dev.TransducersAreNotAutomataException_swigregister
TransducersAreNotAutomataException_swigregister(TransducersAreNotAutomataException)

class StateIndexOutOfBoundsException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StateIndexOutOfBoundsException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StateIndexOutOfBoundsException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StateIndexOutOfBoundsException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StateIndexOutOfBoundsException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StateIndexOutOfBoundsException_what(self)
StateIndexOutOfBoundsException_swigregister = _libhfst_dev.StateIndexOutOfBoundsException_swigregister
StateIndexOutOfBoundsException_swigregister(StateIndexOutOfBoundsException)

class TransducerHeaderException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerHeaderException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerHeaderException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerHeaderException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerHeaderException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerHeaderException_what(self)
TransducerHeaderException_swigregister = _libhfst_dev.TransducerHeaderException_swigregister
TransducerHeaderException_swigregister(TransducerHeaderException)

class MissingOpenFstInputSymbolTableException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MissingOpenFstInputSymbolTableException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MissingOpenFstInputSymbolTableException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_MissingOpenFstInputSymbolTableException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_MissingOpenFstInputSymbolTableException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.MissingOpenFstInputSymbolTableException_what(self)
MissingOpenFstInputSymbolTableException_swigregister = _libhfst_dev.MissingOpenFstInputSymbolTableException_swigregister
MissingOpenFstInputSymbolTableException_swigregister(MissingOpenFstInputSymbolTableException)

class TransducerTypeMismatchException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerTypeMismatchException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerTypeMismatchException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerTypeMismatchException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerTypeMismatchException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerTypeMismatchException_what(self)
TransducerTypeMismatchException_swigregister = _libhfst_dev.TransducerTypeMismatchException_swigregister
TransducerTypeMismatchException_swigregister(TransducerTypeMismatchException)

class EmptySetOfContextsException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptySetOfContextsException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptySetOfContextsException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_EmptySetOfContextsException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_EmptySetOfContextsException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.EmptySetOfContextsException_what(self)
EmptySetOfContextsException_swigregister = _libhfst_dev.EmptySetOfContextsException_swigregister
EmptySetOfContextsException_swigregister(EmptySetOfContextsException)

class SpecifiedTypeRequiredException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpecifiedTypeRequiredException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpecifiedTypeRequiredException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_SpecifiedTypeRequiredException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_SpecifiedTypeRequiredException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.SpecifiedTypeRequiredException_what(self)
SpecifiedTypeRequiredException_swigregister = _libhfst_dev.SpecifiedTypeRequiredException_swigregister
SpecifiedTypeRequiredException_swigregister(SpecifiedTypeRequiredException)

class HfstFatalException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstFatalException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HfstFatalException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_HfstFatalException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstFatalException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.HfstFatalException_what(self)
HfstFatalException_swigregister = _libhfst_dev.HfstFatalException_swigregister
HfstFatalException_swigregister(HfstFatalException)

class TransducerHasWrongTypeException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerHasWrongTypeException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerHasWrongTypeException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerHasWrongTypeException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerHasWrongTypeException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerHasWrongTypeException_what(self)
TransducerHasWrongTypeException_swigregister = _libhfst_dev.TransducerHasWrongTypeException_swigregister
TransducerHasWrongTypeException_swigregister(TransducerHasWrongTypeException)

class IncorrectUtf8CodingException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IncorrectUtf8CodingException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IncorrectUtf8CodingException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_IncorrectUtf8CodingException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_IncorrectUtf8CodingException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.IncorrectUtf8CodingException_what(self)
IncorrectUtf8CodingException_swigregister = _libhfst_dev.IncorrectUtf8CodingException_swigregister
IncorrectUtf8CodingException_swigregister(IncorrectUtf8CodingException)

class EmptyStringException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptyStringException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptyStringException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_EmptyStringException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_EmptyStringException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.EmptyStringException_what(self)
EmptyStringException_swigregister = _libhfst_dev.EmptyStringException_swigregister
EmptyStringException_swigregister(EmptyStringException)

class SymbolNotFoundException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymbolNotFoundException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SymbolNotFoundException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_SymbolNotFoundException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_SymbolNotFoundException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.SymbolNotFoundException_what(self)
SymbolNotFoundException_swigregister = _libhfst_dev.SymbolNotFoundException_swigregister
SymbolNotFoundException_swigregister(SymbolNotFoundException)

class MetadataException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MetadataException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MetadataException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_MetadataException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_MetadataException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.MetadataException_what(self)
MetadataException_swigregister = _libhfst_dev.MetadataException_swigregister
MetadataException_swigregister(MetadataException)

class FlagDiacriticsAreNotIdentitiesException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FlagDiacriticsAreNotIdentitiesException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FlagDiacriticsAreNotIdentitiesException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_FlagDiacriticsAreNotIdentitiesException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_FlagDiacriticsAreNotIdentitiesException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.FlagDiacriticsAreNotIdentitiesException_what(self)
FlagDiacriticsAreNotIdentitiesException_swigregister = _libhfst_dev.FlagDiacriticsAreNotIdentitiesException_swigregister
FlagDiacriticsAreNotIdentitiesException_swigregister(FlagDiacriticsAreNotIdentitiesException)

class Location(_object):
    """

    Location of a pmatch result.

    Attributes:

        start:                  start index of match
        length:                 length of match
        input:                  the matched input string
        output:                 the matching output string
        tag:                    the tag of match
        weight:                 the weight of match
        input_parts:            tuple of indices in input_symbol_strings
        output_string:          tuple of indices in output_symbol_strings
        input_symbol_strings:   tuple of matched input symbol strings
        output_symbol_strings:  tuple of matching output symbol strings

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Location, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Location, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _libhfst_dev.Location_start_set
    __swig_getmethods__["start"] = _libhfst_dev.Location_start_get
    if _newclass:
        start = _swig_property(_libhfst_dev.Location_start_get, _libhfst_dev.Location_start_set)
    __swig_setmethods__["length"] = _libhfst_dev.Location_length_set
    __swig_getmethods__["length"] = _libhfst_dev.Location_length_get
    if _newclass:
        length = _swig_property(_libhfst_dev.Location_length_get, _libhfst_dev.Location_length_set)
    __swig_setmethods__["input"] = _libhfst_dev.Location_input_set
    __swig_getmethods__["input"] = _libhfst_dev.Location_input_get
    if _newclass:
        input = _swig_property(_libhfst_dev.Location_input_get, _libhfst_dev.Location_input_set)
    __swig_setmethods__["output"] = _libhfst_dev.Location_output_set
    __swig_getmethods__["output"] = _libhfst_dev.Location_output_get
    if _newclass:
        output = _swig_property(_libhfst_dev.Location_output_get, _libhfst_dev.Location_output_set)
    __swig_setmethods__["tag"] = _libhfst_dev.Location_tag_set
    __swig_getmethods__["tag"] = _libhfst_dev.Location_tag_get
    if _newclass:
        tag = _swig_property(_libhfst_dev.Location_tag_get, _libhfst_dev.Location_tag_set)
    __swig_setmethods__["weight"] = _libhfst_dev.Location_weight_set
    __swig_getmethods__["weight"] = _libhfst_dev.Location_weight_get
    if _newclass:
        weight = _swig_property(_libhfst_dev.Location_weight_get, _libhfst_dev.Location_weight_set)
    __swig_setmethods__["input_parts"] = _libhfst_dev.Location_input_parts_set
    __swig_getmethods__["input_parts"] = _libhfst_dev.Location_input_parts_get
    if _newclass:
        input_parts = _swig_property(_libhfst_dev.Location_input_parts_get, _libhfst_dev.Location_input_parts_set)
    __swig_setmethods__["output_parts"] = _libhfst_dev.Location_output_parts_set
    __swig_getmethods__["output_parts"] = _libhfst_dev.Location_output_parts_get
    if _newclass:
        output_parts = _swig_property(_libhfst_dev.Location_output_parts_get, _libhfst_dev.Location_output_parts_set)
    __swig_setmethods__["input_symbol_strings"] = _libhfst_dev.Location_input_symbol_strings_set
    __swig_getmethods__["input_symbol_strings"] = _libhfst_dev.Location_input_symbol_strings_get
    if _newclass:
        input_symbol_strings = _swig_property(_libhfst_dev.Location_input_symbol_strings_get, _libhfst_dev.Location_input_symbol_strings_set)
    __swig_setmethods__["output_symbol_strings"] = _libhfst_dev.Location_output_symbol_strings_set
    __swig_getmethods__["output_symbol_strings"] = _libhfst_dev.Location_output_symbol_strings_get
    if _newclass:
        output_symbol_strings = _swig_property(_libhfst_dev.Location_output_symbol_strings_get, _libhfst_dev.Location_output_symbol_strings_set)

    def __init__(self):
        this = _libhfst_dev.new_Location()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_Location
    __del__ = lambda self: None
Location_swigregister = _libhfst_dev.Location_swigregister
Location_swigregister(Location)


_libhfst_dev.SFST_TYPE_swigconstant(_libhfst_dev)
SFST_TYPE = _libhfst_dev.SFST_TYPE

_libhfst_dev.TROPICAL_OPENFST_TYPE_swigconstant(_libhfst_dev)
TROPICAL_OPENFST_TYPE = _libhfst_dev.TROPICAL_OPENFST_TYPE

_libhfst_dev.LOG_OPENFST_TYPE_swigconstant(_libhfst_dev)
LOG_OPENFST_TYPE = _libhfst_dev.LOG_OPENFST_TYPE

_libhfst_dev.FOMA_TYPE_swigconstant(_libhfst_dev)
FOMA_TYPE = _libhfst_dev.FOMA_TYPE

_libhfst_dev.XFSM_TYPE_swigconstant(_libhfst_dev)
XFSM_TYPE = _libhfst_dev.XFSM_TYPE

_libhfst_dev.HFST_OL_TYPE_swigconstant(_libhfst_dev)
HFST_OL_TYPE = _libhfst_dev.HFST_OL_TYPE

_libhfst_dev.HFST_OLW_TYPE_swigconstant(_libhfst_dev)
HFST_OLW_TYPE = _libhfst_dev.HFST_OLW_TYPE

_libhfst_dev.HFST2_TYPE_swigconstant(_libhfst_dev)
HFST2_TYPE = _libhfst_dev.HFST2_TYPE

_libhfst_dev.UNSPECIFIED_TYPE_swigconstant(_libhfst_dev)
UNSPECIFIED_TYPE = _libhfst_dev.UNSPECIFIED_TYPE

_libhfst_dev.ERROR_TYPE_swigconstant(_libhfst_dev)
ERROR_TYPE = _libhfst_dev.ERROR_TYPE

_libhfst_dev.REPL_UP_swigconstant(_libhfst_dev)
REPL_UP = _libhfst_dev.REPL_UP

_libhfst_dev.REPL_DOWN_swigconstant(_libhfst_dev)
REPL_DOWN = _libhfst_dev.REPL_DOWN

_libhfst_dev.REPL_RIGHT_swigconstant(_libhfst_dev)
REPL_RIGHT = _libhfst_dev.REPL_RIGHT

_libhfst_dev.REPL_LEFT_swigconstant(_libhfst_dev)
REPL_LEFT = _libhfst_dev.REPL_LEFT
class Rule(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rule, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_Rule(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_mapping(self):
        return _libhfst_dev.Rule_get_mapping(self)

    def get_context(self):
        return _libhfst_dev.Rule_get_context(self)

    def get_replType(self):
        return _libhfst_dev.Rule_get_replType(self)

    def encodeFlags(self):
        return _libhfst_dev.Rule_encodeFlags(self)
    __swig_destroy__ = _libhfst_dev.delete_Rule
    __del__ = lambda self: None
Rule_swigregister = _libhfst_dev.Rule_swigregister
Rule_swigregister(Rule)


def replace(*args):
    return _libhfst_dev.replace(*args)
replace = _libhfst_dev.replace

def xerox_replace_left(*args):
    return _libhfst_dev.xerox_replace_left(*args)
xerox_replace_left = _libhfst_dev.xerox_replace_left

def replace_leftmost_longest_match(*args):
    return _libhfst_dev.replace_leftmost_longest_match(*args)
replace_leftmost_longest_match = _libhfst_dev.replace_leftmost_longest_match

def replace_rightmost_longest_match(*args):
    return _libhfst_dev.replace_rightmost_longest_match(*args)
replace_rightmost_longest_match = _libhfst_dev.replace_rightmost_longest_match

def replace_leftmost_shortest_match(*args):
    return _libhfst_dev.replace_leftmost_shortest_match(*args)
replace_leftmost_shortest_match = _libhfst_dev.replace_leftmost_shortest_match

def replace_rightmost_shortest_match(*args):
    return _libhfst_dev.replace_rightmost_shortest_match(*args)
replace_rightmost_shortest_match = _libhfst_dev.replace_rightmost_shortest_match

def replace_epenthesis(*args):
    return _libhfst_dev.replace_epenthesis(*args)
replace_epenthesis = _libhfst_dev.replace_epenthesis

def xerox_restriction(automata, context):
    return _libhfst_dev.xerox_restriction(automata, context)
xerox_restriction = _libhfst_dev.xerox_restriction

def before(left, right):
    return _libhfst_dev.before(left, right)
before = _libhfst_dev.before

def after(left, right):
    return _libhfst_dev.after(left, right)
after = _libhfst_dev.after

def is_diacritic(symbol):
    """


    Whether symbol *symbol* is a flag diacritic.

    Flag diacritics are of the form

         @[PNDRCU][.][A-Z]+([.][A-Z]+)?@

    """
    return _libhfst_dev.is_diacritic(symbol)

def is_epsilon(symbol):
    return _libhfst_dev.is_epsilon(symbol)
is_epsilon = _libhfst_dev.is_epsilon

def compile_pmatch_expression(pmatch):
    """


    Compile a pmatch expression into a tuple of transducers.

    Parameters
    ----------
    * `expr` :
        A string defining how pmatch is done.

    See also: hfst.compile_pmatch_file

    """
    return _libhfst_dev.compile_pmatch_expression(pmatch)

def _is_string(s):
    if isinstance(s, str):
       return True
    else:
       return False
def _is_string_pair(sp):
    if not isinstance(sp, tuple):
       return False
    if len(sp) != 2:
       return False
    if not _is_string(sp[0]):
       return False
    if not _is_string(sp[1]):
       return False
    return True
def _is_string_vector(sv):
    if not isinstance(sv, tuple):
       return False
    for s in sv:
       if not _is_string(s):
          return False
    return True
def _is_string_pair_vector(spv):
    if not isinstance(spv, tuple):
       return False
    for sp in spv:
       if not _is_string_pair(sp):
          return False
    return True

def _two_level_paths_to_dict(tlps):
    retval = {}
    for tlp in tlps:
       input = ""
       output = ""
       for sp in tlp[1]:
          input += sp[0]
          output += sp[1]
       if input in retval:
          retval[input].append((output, tlp[0]))
       else:
          retval[input] = [(output, tlp[0])]
    return retval

def _one_level_paths_to_tuple(olps, show_special_symbols):
    retval = []
    for olp in olps:
       path = ""
       for s in olp[1]:
          if not show_special_symbols and (is_diacritic(s) or is_epsilon(s)):
             pass
          else:
             path += s
       retval.append((path, olp[0]))
    return tuple(retval)

class HfstTransducer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducer, name)
    __repr__ = _swig_repr

    def set_name(self, name):
        return _libhfst_dev.HfstTransducer_set_name(self, name)

    def get_name(self):
        return _libhfst_dev.HfstTransducer_get_name(self)

    def get_type(self):
        return _libhfst_dev.HfstTransducer_get_type(self)

    def set_property(self, property, value):
        return _libhfst_dev.HfstTransducer_set_property(self, property, value)

    def get_property(self, property):
        return _libhfst_dev.HfstTransducer_get_property(self, property)

    def get_properties(self):
        return _libhfst_dev.HfstTransducer_get_properties(self)

    def compare(self, arg2, harmonize=True):
        return _libhfst_dev.HfstTransducer_compare(self, arg2, harmonize)

    def number_of_states(self):
        return _libhfst_dev.HfstTransducer_number_of_states(self)

    def number_of_arcs(self):
        return _libhfst_dev.HfstTransducer_number_of_arcs(self)

    def get_alphabet(self):
        return _libhfst_dev.HfstTransducer_get_alphabet(self)

    def is_cyclic(self):
        return _libhfst_dev.HfstTransducer_is_cyclic(self)

    def is_automaton(self):
        return _libhfst_dev.HfstTransducer_is_automaton(self)

    def is_infinitely_ambiguous(self):
        return _libhfst_dev.HfstTransducer_is_infinitely_ambiguous(self)

    def is_lookup_infinitely_ambiguous(self, arg2):
        return _libhfst_dev.HfstTransducer_is_lookup_infinitely_ambiguous(self, arg2)

    def has_flag_diacritics(self):
        return _libhfst_dev.HfstTransducer_has_flag_diacritics(self)

    def insert_to_alphabet(self, arg2):
        return _libhfst_dev.HfstTransducer_insert_to_alphabet(self, arg2)

    def remove_from_alphabet(self, arg2):
        return _libhfst_dev.HfstTransducer_remove_from_alphabet(self, arg2)
    __swig_getmethods__["is_implementation_type_available"] = lambda x: _libhfst_dev.HfstTransducer_is_implementation_type_available
    if _newclass:
        is_implementation_type_available = staticmethod(_libhfst_dev.HfstTransducer_is_implementation_type_available)

    def longest_path_size(self, obey_flags=True):
        return _libhfst_dev.HfstTransducer_longest_path_size(self, obey_flags)

    def concatenate(self, tr, harmonize=True):
        return _libhfst_dev.HfstTransducer_concatenate(self, tr, harmonize)

    def disjunct(self, tr, harmonize=True):
        return _libhfst_dev.HfstTransducer_disjunct(self, tr, harmonize)

    def subtract(self, tr, harmonize=True):
        return _libhfst_dev.HfstTransducer_subtract(self, tr, harmonize)

    def intersect(self, tr, harmonize=True):
        return _libhfst_dev.HfstTransducer_intersect(self, tr, harmonize)

    def compose(self, tr, harmonize=True):
        return _libhfst_dev.HfstTransducer_compose(self, tr, harmonize)

    def compose_intersect(self, v, invert=False, harmonize=True):
        return _libhfst_dev.HfstTransducer_compose_intersect(self, v, invert, harmonize)

    def priority_union(self, another):
        return _libhfst_dev.HfstTransducer_priority_union(self, another)

    def lenient_composition(self, another, harmonize=True):
        return _libhfst_dev.HfstTransducer_lenient_composition(self, another, harmonize)

    def cross_product(self, another, harmonize=True):
        return _libhfst_dev.HfstTransducer_cross_product(self, another, harmonize)

    def shuffle(self, another, harmonize=True):
        return _libhfst_dev.HfstTransducer_shuffle(self, another, harmonize)

    def remove_epsilons(self):
        return _libhfst_dev.HfstTransducer_remove_epsilons(self)

    def determinize(self):
        return _libhfst_dev.HfstTransducer_determinize(self)

    def minimize(self):
        return _libhfst_dev.HfstTransducer_minimize(self)

    def prune(self):
        return _libhfst_dev.HfstTransducer_prune(self)

    def eliminate_flags(self):
        return _libhfst_dev.HfstTransducer_eliminate_flags(self)

    def eliminate_flag(self, f):
        return _libhfst_dev.HfstTransducer_eliminate_flag(self, f)

    def n_best(self, n):
        return _libhfst_dev.HfstTransducer_n_best(self, n)

    def convert(self, impl):
        return _libhfst_dev.HfstTransducer_convert(self, impl)

    def repeat_star(self):
        return _libhfst_dev.HfstTransducer_repeat_star(self)

    def repeat_plus(self):
        return _libhfst_dev.HfstTransducer_repeat_plus(self)

    def repeat_n(self, n):
        return _libhfst_dev.HfstTransducer_repeat_n(self, n)

    def repeat_n_to_k(self, n, k):
        return _libhfst_dev.HfstTransducer_repeat_n_to_k(self, n, k)

    def repeat_n_minus(self, n):
        return _libhfst_dev.HfstTransducer_repeat_n_minus(self, n)

    def repeat_n_plus(self, n):
        return _libhfst_dev.HfstTransducer_repeat_n_plus(self, n)

    def invert(self):
        return _libhfst_dev.HfstTransducer_invert(self)

    def reverse(self):
        return _libhfst_dev.HfstTransducer_reverse(self)

    def input_project(self):
        return _libhfst_dev.HfstTransducer_input_project(self)

    def output_project(self):
        return _libhfst_dev.HfstTransducer_output_project(self)

    def optionalize(self):
        return _libhfst_dev.HfstTransducer_optionalize(self)

    def insert_freely(self, *args):
        return _libhfst_dev.HfstTransducer_insert_freely(self, *args)

    def _substitute_symbol(self, old_symbol, new_symbol, input_side=True, output_side=True):
        return _libhfst_dev.HfstTransducer__substitute_symbol(self, old_symbol, new_symbol, input_side, output_side)

    def _substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair)

    def _substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set)

    def _substitute_symbol_pair_with_transducer(self, symbol_pair, transducer, harmonize=True):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pair_with_transducer(self, symbol_pair, transducer, harmonize)

    def _substitute_symbols(self, substitutions):
        return _libhfst_dev.HfstTransducer__substitute_symbols(self, substitutions)

    def _substitute_symbol_pairs(self, substitutions):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pairs(self, substitutions)

    def set_final_weights(self, weight, increment=False):
        return _libhfst_dev.HfstTransducer_set_final_weights(self, weight, increment)

    def push_weights_to_start(self):
        return _libhfst_dev.HfstTransducer_push_weights_to_start(self)

    def push_weights_to_end(self):
        return _libhfst_dev.HfstTransducer_push_weights_to_end(self)

    def minus(self, t, harmonize=True):
        return _libhfst_dev.HfstTransducer_minus(self, t, harmonize)

    def conjunct(self, t, harmonize=True):
        return _libhfst_dev.HfstTransducer_conjunct(self, t, harmonize)

    def lookup_optimize(self):
        return _libhfst_dev.HfstTransducer_lookup_optimize(self)

    def remove_optimization(self):
        return _libhfst_dev.HfstTransducer_remove_optimization(self)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducer
    __del__ = lambda self: None

    def __str__(self):
        return _libhfst_dev.HfstTransducer___str__(self)

    def write(self, os):
        return _libhfst_dev.HfstTransducer_write(self, os)

    def _get_dot_graph(self):
        return _libhfst_dev.HfstTransducer__get_dot_graph(self)

    def _extract_shortest_paths(self):
        return _libhfst_dev.HfstTransducer__extract_shortest_paths(self)

    def _extract_longest_paths(self, obey_flags):
        return _libhfst_dev.HfstTransducer__extract_longest_paths(self, obey_flags)

    def _extract_paths(self, max_num=-1, cycles=-1):
        return _libhfst_dev.HfstTransducer__extract_paths(self, max_num, cycles)

    def _extract_paths_fd(self, max_num=-1, cycles=-1, filter_fd=True):
        return _libhfst_dev.HfstTransducer__extract_paths_fd(self, max_num, cycles, filter_fd)

    def _extract_random_paths(self, max_num):
        return _libhfst_dev.HfstTransducer__extract_random_paths(self, max_num)

    def _extract_random_paths_fd(self, max_num, filter_fd):
        return _libhfst_dev.HfstTransducer__extract_random_paths_fd(self, max_num, filter_fd)

    def _lookup_vector(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_vector(self, s, limit, time_cutoff)

    def _lookup_fd_vector(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_fd_vector(self, s, limit, time_cutoff)

    def _lookup_fd_string(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_fd_string(self, s, limit, time_cutoff)

    def _lookup_string(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_string(self, s, limit, time_cutoff)


    def view(self):
        """
        Return a dot Digraph representation of the transducer as a graphviz.Source object.

        Examples:

        Inside a Jupyter notebook, the return value will be automatically
        rendered to an svg image and displayed on the console:

        tr = hfst_dev.regex('foo:bar')
        tr.view()

        If inside an intended block, 'display' must be called:

        if (Foo):
            tr = hfst_dev.regex('foo:bar')
            display(tr.view())

        On other environments, the return value must be explicitely rendered
        to an svg image before displaying it:

        tr = hfst_dev.regex('foo:bar')
        from IPython.core.display import display, SVG
        display(SVG(tr.view()._repr_svg_()))
        """
        from graphviz import Source
        graph = self._get_dot_graph()
        s = Source(graph)
        return s

    def copy(self):
        """
        Return a deep copy of the transducer.
        """
        return HfstTransducer(self)

    def write_to_file(self, filename_):
        """
        Write the transducer in binary format to file *filename_*.
        """
        ostr = HfstOutputStream(filename=filename_, type=self.get_type(), hfst_format=True)
        ostr.write(self)
        ostr.close()

    def read_from_file(filename_):
        """
        Read a binary transducer from file *filename_*.
        """
        istr = HfstInputStream(filename_)
        tr = istr.read()
        istr.close()
        return tr

    def read_all_from_file(filename_):
        """
        Read all binary transducers from file *filename_*.
        """
        istr = HfstInputStream(filename_)
        tr = istr.read_all()
        istr.close()
        return tr

    def write_prolog(self, f, write_weights=True):
        """
        Write the transducer in prolog format with name *name* to file *f*,
        *write_weights* defined whether weights are written.

        Parameters
        ----------
        * `f` :
            A python file where the transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstIterableTransducer(self)
        fsm.name = self.get_name()
        prologstr = fsm.get_prolog_string(write_weights)
        f.write(prologstr)

    def write_xfst(self, f, write_weights=True):
        """
        Write the transducer in xfst format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstIterableTransducer(self)
        fsm.name = self.get_name()
        xfststr = fsm.get_xfst_string(write_weights)
        f.write(xfst)

    def write_att(self, f, write_weights=True):
        """
        Write the transducer in AT&T format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstIterableTransducer(self)
        fsm.name = self.get_name()
        attstr = fsm.get_att_string(write_weights)
        f.write(attstr)

    def lookup(self, input, **kwargs):
        """
        Lookup string *input*.

        Parameters
        ----------
        * `input` :
            The input. A string or a pre-tokenized tuple of symbols (i.e. a tuple of strings).
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True,
            max_number=-1, time_cutoff=0.0, output='tuple'
        * `obey_flags` :
            Whether flag diacritics are obeyed. Always True for HFST_OL(W)_TYPE transducers.
        * `show_flags` :
            Whether flag diacritics are shown when output is 'text' or 'tuple'. Defaults to False.
        * `max_number` :
            Maximum number of results returned, defaults to -1, i.e. infinity.
        * `time_cutoff` :
            How long the function can search for results before returning, expressed in
            seconds. Defaults to 0.0, i.e. infinitely. Always 0.0 for transducers that are
            not of HFST_OL(W)_TYPE.
        * `output` :
            Possible values are 'tuple', 'text' and 'raw', 'tuple' being the default.

        Note: This function has an efficient implementation only for optimized lookup format
        (hfst.ImplementationType.HFST_OL_TYPE or hfst.ImplementationType.HFST_OLW_TYPE). Other formats perform the
        lookup via composition. Consider converting the transducer to optimized lookup format
        or to a HfstIterableTransducer. Conversion to HFST_OL(W)_TYPE might take a while but the
        lookup is fast. Conversion to HfstIterableTransducer is quick but lookup is slower.
        """
        obey_flags=True
        show_flags=False
        max_number=-1
        time_cutoff=0.0
        output='tuple' # 'tuple' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags':
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            if k == 'show_flags':
               if v == False:
                  pass
               elif v == True:
                  show_flags=True
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output='text'
               elif v == 'raw':
                  output='raw'
               elif v == 'tuple':
                  output='tuple'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'tuple' (default), 'text', 'raw'.")
            elif k == 'max_number' :
               max_number=v
            elif k == 'time_cutoff' :
               time_cutoff=v
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval=0

        if isinstance(input, tuple):
           if obey_flags:
              retval=self._lookup_fd_vector(input, max_number, time_cutoff)
           else:
              retval=self._lookup_vector(input, max_number, time_cutoff)
        elif isinstance(input, str):
           if obey_flags:
              retval=self._lookup_fd_string(input, max_number, time_cutoff)
           else:
              retval=self._lookup_string(input, max_number, time_cutoff)
        else:
           try:
              if obey_flags:
                  retval=self._lookup_fd_string(str(input), max_number, time_cutoff)
              else:
                  retval=self._lookup_string(str(input), max_number, time_cutoff)
           except:
              raise RuntimeError('Input argument must be string or tuple.')
        if output == 'text':
           return one_level_paths_to_string(retval, show_flags)
        elif output == 'tuple':
           return _one_level_paths_to_tuple(retval, show_flags)
        else:
           return retval

    def extract_longest_paths(self, **kwargs):
        """
        Extract longest paths of the transducer.

        Parameters
        ----------
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True,
            output='dict'
        * `obey_flags` :
            Whether flag diacritics are obeyed. The default is True.
        * `output` :
            Possible values are 'dict', 'text' and 'raw', 'dict' being the default.

        """
        obey_flags=True
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags':
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._extract_longest_paths(obey_flags)

        if output == 'text':
           return two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def extract_shortest_paths(self, **kwargs):
        """
        Extract shortest paths of the transducer.

        Parameters
        ----------
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True.
        * `output` :
            Possible values are 'dict', 'text' and 'raw', 'dict' being the default.

        """
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._extract_shortest_paths()

        if output == 'text':
           return two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def extract_paths(self, **kwargs):
        """

        Extract paths that are recognized by the transducer.

        Parameters
        ----------
        * `kwargs` :
            Arguments recognized are filter_flags, max_cycles, max_number, obey_flags,
            output, random.
        * `filter_flags` :
            Whether flags diacritics are filtered out from the result (default True).
        * `max_cycles` :
            Indicates how many times a cycle will be followed, with negative numbers
            indicating unlimited (default -1 i.e. unlimited).
        * `max_number` :
            The total number of resulting strings is capped at this value, with 0 or
            negative indicating unlimited (default -1 i.e. unlimited).
        * `obey_flags` :
            Whether flag diacritics are validated (default True).
        * `output` :
            Output format. Values recognized: 'text' (as a string, separated by
            newlines), 'raw' (a dictionary that maps each input string into a list of
            tuples of an output string and a weight), 'dict' (a dictionary that maps
            each input string into a tuple of tuples of an output string and a weight,
            the default).
        * `random` :
            Whether result strings are fetched randomly (default False).

        Returns
        -------
        The extracted strings. *output* controls how they are represented.

        pre: The transducer must be acyclic, if both *max_number* and *max_cycles* have
        unlimited values. Else a hfst.exceptions.TransducerIsCyclicException will be
        thrown.

        An example:

        >>> tr = hfst.regex('a:b+ (a:c+)')
        >>> print(tr)
        0       1       a       b       0.000000
        1       1       a       b       0.000000
        1       2       a       c       0.000000
        1       0.000000
        2       2       a       c       0.000000
        2       0.000000

        >>> print(tr.extract_paths(max_cycles=1, output='text'))
        a:b     0
        aa:bb   0
        aaa:bbc 0
        aaaa:bbcc       0
        aa:bc   0
        aaa:bcc 0

        >>> print(tr.extract_paths(max_number=4, output='text'))
        a:b     0
        aa:bc   0
        aaa:bcc 0
        aaaa:bccc       0

        >>> print(tr.extract_paths(max_cycles=1, max_number=4, output='text'))
        a:b     0
        aa:bb   0
        aa:bc   0
        aaa:bcc 0

        Exceptions
        ----------
        * `TransducerIsCyclicException` :

        See also: hfst.HfstTransducer.n_best
        """
        obey_flags=True
        filter_flags=True
        max_cycles=-1
        max_number=-1
        random=False
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags' :
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'filter_flags' :
               if v == True:
                  pass
               elif v == False:
                  filter_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'max_cycles' :
               max_cycles=v
            elif k == 'max_number' :
               max_number=v
            elif k == 'random' :
               if v == False:
                  pass
               elif v == True:
                  random=True
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output = 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval=0

        if obey_flags :
           if random :
              retval=self._extract_random_paths_fd(max_number, filter_flags)
           else :
              retval=self._extract_paths_fd(max_number, max_cycles)
        else :
           if random :
              retval=self._extract_random_paths(max_number)
           else :
              retval=self._extract_paths(max_number, max_cycles)

        if output == 'text':
           return two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def substitute(self, s, S=None, **kwargs):
        """
        Substitute symbols or transitions in the transducer.

        Parameters
        ----------
        * `s` :
            The symbol or transition to be substituted. Can also be a dictionary of
            substitutions, if S == None.
        * `S` :
            The symbol, transition, a tuple of transitions or a transducer
            (hfst.HfstTransducer) that substitutes *s*.
        * `kwargs` :
            Arguments recognized are 'input' and 'output', their values can be False or
            True, True being the default. These arguments are valid only if *s* and *S*
            are strings, else they are ignored.
        * `input` :
            Whether substitution is performed on input side, defaults to True. Valid
            only if *s* and *S* are strings.
        * `output` :
            Whether substitution is performed on output side, defaults to True. Valid
            only if *s* and \\ S are strings.

        For more information, see hfst.HfstIterableTransducer.substitute. The function
        works similarly, with the exception of argument *S*, which must be
        hfst.HfstTransducer instead of hfst.HfstIterableTransducer.

        See also: hfst.HfstIterableTransducer.substitute
        """
        if S == None:
           if not isinstance(s, dict):
              raise RuntimeError('Sole input argument must be a dictionary.')

           subst_type=""

           for k, v in s.items():
               if _is_string(k):
                  if subst_type == "":
                     subst_type="string"
                  elif subst_type == "string pair":
                     raise RuntimeError('')
                  if not _is_string(v):
                     raise RuntimeError('')
               elif _is_string_pair(k):
                  if subst_type == "":
                     subst_type="string pair"
                  elif subst_type == "string":
                     raise RuntimeError('')
                  if not _is_string_pair(v):
                     raise RuntimeError('')
               else:
                  raise RuntimeError('')

           if subst_type == "string":
              return self._substitute_symbols(s)
           else:
              return self._substitute_symbol_pairs(s)

        if _is_string(s):
           if _is_string(S):
              input=True
              output=True
              for k,v in kwargs.items():
                  if k == 'input':
                     if v == False:
                        input=False
                  elif k == 'output':
                     if v == False:
                        output=False
                  else:
                     raise RuntimeError('Free argument not recognized.')
              return self._substitute_symbol(s, S, input, output)
           else:
              raise RuntimeError('...')
        elif _is_string_pair(s):
           if _is_string_pair(S):
              return self._substitute_symbol_pair(s, S)
           elif _is_string_pair_vector(S):
              return self._substitute_symbol_pair_with_set(s, S)
           elif isinstance(S, HfstTransducer):
              return self._substitute_symbol_pair_with_transducer(s, S, True)
           else:
              raise RuntimeError('...')
        else:
           raise RuntimeError('...')

HfstTransducer_swigregister = _libhfst_dev.HfstTransducer_swigregister
HfstTransducer_swigregister(HfstTransducer)

def HfstTransducer_is_implementation_type_available(type):
    return _libhfst_dev.HfstTransducer_is_implementation_type_available(type)
HfstTransducer_is_implementation_type_available = _libhfst_dev.HfstTransducer_is_implementation_type_available


def create_hfst_output_stream(filename, type, hfst_format):
    return _libhfst_dev.create_hfst_output_stream(filename, type, hfst_format)
create_hfst_output_stream = _libhfst_dev.create_hfst_output_stream
class HfstOutputStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstOutputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstOutputStream, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst_dev.delete_HfstOutputStream
    __del__ = lambda self: None

    def flush(self):
        return _libhfst_dev.HfstOutputStream_flush(self)

    def close(self):
        return _libhfst_dev.HfstOutputStream_close(self)

    def redirect(self, arg2):
        return _libhfst_dev.HfstOutputStream_redirect(self, arg2)

    def __init__(self):
        this = _libhfst_dev.new_HfstOutputStream()
        try:
            self.this.append(this)
        except Exception:
            self.this = this


    def write(self, tr):
        """
        Write one or more transducers to stream.

        Parameters
        ----------
        * `tr` :
            An HfstTransducer or an iterable object of several HfstTransducers.
        """
        if isinstance(tr, HfstTransducer):
            self.redirect(tr)
        else:
            for t in tr:
                if isinstance(t, HfstTransducer):
                    self.redirect(t)
                else:
                    raise RuntimeError('Cannot write objects that are not instances of HfstTransducer')

    def __init__(self, **kwargs):
        """
        Open a stream for writing binary transducers. Note: hfst.HfstTransducer.write_to_file
        is probably the easiest way to write a single binary transducer to a file.

        Parameters
        ----------
        * `kwargs` :
            Arguments recognized are filename, hfst_format, type.
        * `filename` :
            The name of the file where transducers are written. If the file exists, it
            is overwritten. If *filename* is not given, transducers are written to
            standard output.
        * `hfst_format` :
            Whether transducers are written in hfst format (default is True) or as such
            in their backend format.
        * `type` :
            The type of the transducers that will be written to the stream. Default is
            hfst.get_default_fst_type().

        Examples:

    # a stream for writing default type transducers in hfst format to standard output
            ostr = hfst.HfstOutputStream()
            transducer = hfst.regex('foo:bar::0.5')
            ostr.write(transducer)
            ostr.flush()

    # a stream for writing native sfst type transducers to a file
            ostr = hfst.HfstOutputStream(filename='transducer.sfst', hfst_format=False, type=hfst.ImplementationType.SFST_TYPE)
            transducer1 = hfst.regex('foo:bar')
            transducer1.convert(hfst.ImplementationType.SFST_TYPE)  # if not set as the default type
            transducer2 = hfst.regex('bar:baz')
            transducer2.convert(hfst.ImplementationType.SFST_TYPE)  # if not set as the default type
            ostr.write(transducer1)
            ostr.write(transducer2)
            ostr.flush()
            ostr.close()
        """
        filename = ""
        hfst_format = True
        type = _libhfst_dev.get_default_fst_type()
        for k,v in kwargs.items():
            if k == 'filename':
                filename = v
            if k == 'hfst_format':
                hfst_format = v
            if k == 'type':
                type = v
        if filename == "":
            self.this = _libhfst_dev.create_hfst_output_stream("", type, hfst_format)
        else:
            self.this = _libhfst_dev.create_hfst_output_stream(filename, type, hfst_format)

HfstOutputStream_swigregister = _libhfst_dev.HfstOutputStream_swigregister
HfstOutputStream_swigregister(HfstOutputStream)

class HfstInputStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstInputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstInputStream, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstInputStream(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstInputStream
    __del__ = lambda self: None

    def close(self):
        return _libhfst_dev.HfstInputStream_close(self)

    def is_eof(self):
        return _libhfst_dev.HfstInputStream_is_eof(self)

    def is_bad(self):
        return _libhfst_dev.HfstInputStream_is_bad(self)

    def is_good(self):
        return _libhfst_dev.HfstInputStream_is_good(self)

    def get_type(self):
        return _libhfst_dev.HfstInputStream_get_type(self)

    def read(self):
        return _libhfst_dev.HfstInputStream_read(self)


    def read_all(self):
        """
        Read all transducers from stream and return them in a list.
        """
        retval = []
        while(not self.is_eof()):
            retval.append(self.read())
        return retval

    def __iter__(self):
        """
        Return *self*. Needed for 'for ... in' statement.
        """
        return self

    def next(self):
        """
        Read next transducer from stream and return it. Needed for 'for ... in' statement.
        """
        if self.is_eof():
            raise StopIteration
        else:
            return self.read();

    def __next__(self):
        """
        Read next transducer from stream and return it. Needed for 'for ... in' statement.
        """
        return self.next()


HfstInputStream_swigregister = _libhfst_dev.HfstInputStream_swigregister
HfstInputStream_swigregister(HfstInputStream)

class HfstTokenizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTokenizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTokenizer, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _libhfst_dev.new_HfstTokenizer()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add_skip_symbol(self, symbol):
        return _libhfst_dev.HfstTokenizer_add_skip_symbol(self, symbol)

    def add_multichar_symbol(self, symbol):
        return _libhfst_dev.HfstTokenizer_add_multichar_symbol(self, symbol)

    def add_multichar_symbols(self, symbols):
        return _libhfst_dev.HfstTokenizer_add_multichar_symbols(self, symbols)

    def tokenize_one_level(self, input_string):
        return _libhfst_dev.HfstTokenizer_tokenize_one_level(self, input_string)
    __swig_getmethods__["tokenize_space_separated"] = lambda x: _libhfst_dev.HfstTokenizer_tokenize_space_separated
    if _newclass:
        tokenize_space_separated = staticmethod(_libhfst_dev.HfstTokenizer_tokenize_space_separated)

    def tokenize(self, *args):
        return _libhfst_dev.HfstTokenizer_tokenize(self, *args)
    __swig_getmethods__["check_utf8_correctness"] = lambda x: _libhfst_dev.HfstTokenizer_check_utf8_correctness
    if _newclass:
        check_utf8_correctness = staticmethod(_libhfst_dev.HfstTokenizer_check_utf8_correctness)
    __swig_destroy__ = _libhfst_dev.delete_HfstTokenizer
    __del__ = lambda self: None
HfstTokenizer_swigregister = _libhfst_dev.HfstTokenizer_swigregister
HfstTokenizer_swigregister(HfstTokenizer)

def HfstTokenizer_tokenize_space_separated(str):
    return _libhfst_dev.HfstTokenizer_tokenize_space_separated(str)
HfstTokenizer_tokenize_space_separated = _libhfst_dev.HfstTokenizer_tokenize_space_separated

def HfstTokenizer_check_utf8_correctness(input_string):
    return _libhfst_dev.HfstTokenizer_check_utf8_correctness(input_string)
HfstTokenizer_check_utf8_correctness = _libhfst_dev.HfstTokenizer_check_utf8_correctness

class HfstIterableTransducer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstIterableTransducer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstIterableTransducer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstIterableTransducer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["name"] = _libhfst_dev.HfstIterableTransducer_name_set
    __swig_getmethods__["name"] = _libhfst_dev.HfstIterableTransducer_name_get
    if _newclass:
        name = _swig_property(_libhfst_dev.HfstIterableTransducer_name_get, _libhfst_dev.HfstIterableTransducer_name_set)

    def add_symbol_to_alphabet(self, symbol):
        return _libhfst_dev.HfstIterableTransducer_add_symbol_to_alphabet(self, symbol)

    def remove_symbol_from_alphabet(self, symbol):
        return _libhfst_dev.HfstIterableTransducer_remove_symbol_from_alphabet(self, symbol)

    def remove_symbols_from_alphabet(self, symbols):
        return _libhfst_dev.HfstIterableTransducer_remove_symbols_from_alphabet(self, symbols)

    def add_symbols_to_alphabet(self, symbols):
        return _libhfst_dev.HfstIterableTransducer_add_symbols_to_alphabet(self, symbols)

    def symbols_used(self):
        return _libhfst_dev.HfstIterableTransducer_symbols_used(self)

    def prune_alphabet(self, force=True):
        return _libhfst_dev.HfstIterableTransducer_prune_alphabet(self, force)

    def get_alphabet(self):
        return _libhfst_dev.HfstIterableTransducer_get_alphabet(self)

    def get_input_symbols(self):
        return _libhfst_dev.HfstIterableTransducer_get_input_symbols(self)

    def get_output_symbols(self):
        return _libhfst_dev.HfstIterableTransducer_get_output_symbols(self)

    def get_transition_pairs(self):
        return _libhfst_dev.HfstIterableTransducer_get_transition_pairs(self)

    def add_state(self, *args):
        return _libhfst_dev.HfstIterableTransducer_add_state(self, *args)

    def get_max_state(self):
        return _libhfst_dev.HfstIterableTransducer_get_max_state(self)

    def states(self):
        return _libhfst_dev.HfstIterableTransducer_states(self)

    def remove_transition(self, s, transition, remove_symbols_from_alphabet=False):
        return _libhfst_dev.HfstIterableTransducer_remove_transition(self, s, transition, remove_symbols_from_alphabet)

    def is_final_state(self, s):
        return _libhfst_dev.HfstIterableTransducer_is_final_state(self, s)

    def get_final_weight(self, s):
        return _libhfst_dev.HfstIterableTransducer_get_final_weight(self, s)

    def set_final_weight(self, s, weight):
        return _libhfst_dev.HfstIterableTransducer_set_final_weight(self, s, weight)

    def remove_final_weight(self, s):
        return _libhfst_dev.HfstIterableTransducer_remove_final_weight(self, s)

    def _transitions(self, s):
        return _libhfst_dev.HfstIterableTransducer__transitions(self, s)

    def is_infinitely_ambiguous(self):
        return _libhfst_dev.HfstIterableTransducer_is_infinitely_ambiguous(self)

    def is_lookup_infinitely_ambiguous(self, s):
        return _libhfst_dev.HfstIterableTransducer_is_lookup_infinitely_ambiguous(self, s)

    def longest_path_size(self):
        return _libhfst_dev.HfstIterableTransducer_longest_path_size(self)

    def _substitute_symbol(self, old_symbol, new_symbol, input_side=True, output_side=True):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol(self, old_symbol, new_symbol, input_side, output_side)

    def _substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair)

    def _substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set)

    def _substitute_symbol_pair_with_transducer(self, symbol_pair, transducer):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pair_with_transducer(self, symbol_pair, transducer)

    def _substitute_symbols(self, substitutions):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbols(self, substitutions)

    def _substitute_symbol_pairs(self, substitutions):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pairs(self, substitutions)

    def insert_freely(self, *args):
        return _libhfst_dev.HfstIterableTransducer_insert_freely(self, *args)

    def sort_arcs(self):
        return _libhfst_dev.HfstIterableTransducer_sort_arcs(self)

    def disjunct(self, spv, weight):
        return _libhfst_dev.HfstIterableTransducer_disjunct(self, spv, weight)

    def harmonize(self, another):
        return _libhfst_dev.HfstIterableTransducer_harmonize(self, another)
    __swig_getmethods__["read_binary_sfst_transducer"] = lambda x: _libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer
    if _newclass:
        read_binary_sfst_transducer = staticmethod(_libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer)

    def write_binary_sfst_transducer(self, filename):
        return _libhfst_dev.HfstIterableTransducer_write_binary_sfst_transducer(self, filename)

    def _lookup(self, lookup_path, infinite_cutoff, max_weight, obey_flags):
        return _libhfst_dev.HfstIterableTransducer__lookup(self, lookup_path, infinite_cutoff, max_weight, obey_flags)

    def get_prolog_string(self, write_weights):
        return _libhfst_dev.HfstIterableTransducer_get_prolog_string(self, write_weights)

    def get_xfst_string(self, write_weights):
        return _libhfst_dev.HfstIterableTransducer_get_xfst_string(self, write_weights)

    def get_att_string(self, write_weights):
        return _libhfst_dev.HfstIterableTransducer_get_att_string(self, write_weights)

    def __str__(self):
        return _libhfst_dev.HfstIterableTransducer___str__(self)

    def add_transition(self, *args):
        return _libhfst_dev.HfstIterableTransducer_add_transition(self, *args)


    def view(self):
        """
        Return a dot Digraph representation of the transducer as a graphviz.Source object.

        Examples:

        Inside a Jupyter notebook, the return value will be automatically
        rendered to an svg image and displayed on the console:

        tr = hfst_dev.regex('foo:bar')
        tr.view()

        If inside an intended block, 'display' must be called:

        if (Foo):
            tr = hfst_dev.regex('foo:bar')
            display(tr.view())

        On other environments, the return value must be explicitely rendered
        to an svg image before displaying it:

        tr = hfst_dev.regex('foo:bar')
        from IPython.core.display import display, SVG
        display(SVG(tr.view()._repr_svg_()))
        """
        TR = HfstTransducer(self)
        return TR.view()

    def transitions(self, s):
        """
        ...
        """
        tr = self._transitions(s)
        retval = []
        for i in range(0, len(tr)):
            retval.append(tr[i])
        return retval

    def states_and_transitions(self):
        """
        ...
        """
        retval = []
        for s in self.states():
            retval.append(self.transitions(s))
        return retval

    def __iter__(self):
        """
        Return states and transitions of the transducer.
        """
        return self.states_and_transitions().__iter__()

    def __enumerate__(self):
        """
        Return an enumeration of states and transitions of the transducer.
        """
        return enumerate(self.states_and_transitions())

    def write_prolog(self, f, write_weights=True):
        """
        Write the transducer in prolog format with name *name* to file *f*,
        *write_weights* defined whether weights are written.

        Parameters
        ----------
        * `f` :
            A python file where the transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        prologstr = self.get_prolog_string(write_weights)
        f.write(prologstr)

    def write_xfst(self, f, write_weights=True):
        """
        Write the transducer in xfst format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        xfststr = self.get_xfst_string(write_weights)
        f.write(prologstr)

    def write_att(self, f, write_weights=True):
        """
        Write the transducer in AT&T format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        attstr = self.get_att_string(write_weights)
        f.write(attstr)

    def lookup(self, lookup_path, **kwargs):
        """
        Lookup tokenized input *input* in the transducer.

        Parameters
        ----------
        * `str` :
            A list/tuple of strings to look up.
        * `kwargs` :
            infinite_cutoff=-1, max_weight=None, obey_flags=False
        * `max_epsilon_loops` :
            How many times epsilon input loops are followed. Defaults to -1, i.e. infinitely.
        * `max_weight` :
            What is the maximum weight of a result allowed. Defaults to None, i.e. infinity.
        * `obey_flags` :
            Whether flag diacritic constraints are obeyed. Defaults to False.
        """
        max_weight = None
        max_epsilon_loops = None
        obey_flags = False
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'max_weight' :
               max_weight=v
            elif k == 'max_epsilon_loops' :
               infinite_cutoff=v
            elif k == 'obey_flags' :
               obey_flags=v
            elif k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._lookup(lookup_path, max_epsilon_loops, max_weight, obey_flags)

        if output == 'text':
           return _two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def substitute(self, s, S=None, **kwargs):
        """

        Substitute symbols or transitions in the transducer.

        Parameters
        ----------
        * `s` :
            The symbol or transition to be substituted. Can also be a dictionary of
            substitutions, if S == None.
        * `S` :
            The symbol, transition, a tuple of transitions or a transducer
            (hfst.HfstIterableTransducer) that substitutes *s*.
        * `kwargs` :
            Arguments recognized are 'input' and 'output', their values can be False or
            True, True being the default. These arguments are valid only if *s* and *S*
            are strings, else they are ignored.
        * `input` :
            Whether substitution is performed on input side, defaults to True. Valid
            only if *s* and *S* are strings.
        * `output` :
            Whether substitution is performed on output side, defaults to True. Valid
            only if *s* and *S* are strings.

        Possible combinations of arguments and their types are:

        (1) substitute(str, str, input=bool, output=bool): substitute symbol with symbol
        on input, output or both sides of each transition in the transducer. (2)
        substitute(strpair, strpair): substitute transition with transition (3)
        substitute(strpair, strpairtuple): substitute transition with several
        transitions (4) substitute(strpair, transducer): substitute transition with a
        transducer (5) substitute(dict): perform several symbol-to-symbol substitutions
        (6) substitute(dict): perform several transition-to-transition substitutions

        Examples:

        (1) tr.substitute('a', 'A', input=True, output=False): substitute lowercase a:s
        with uppercase ones (2) tr.substitute(('a','b'),('A','B')): substitute
        transitions that map lowercase a into lowercase b with transitions that map
        uppercase a into uppercase b (3) tr.substitute(('a','b'),
        (('A','B'),('a','B'),('A','b'))): change either or both sides of a transition
        [a:b] to uppercase (4) tr.substitute(('a','b'), hfst.regex('[a:b]+')) change
        [a:b] transition into one or more consecutive [a:b] transitions (5)
        tr.substitute({'a':'A', 'b':'B', 'c':'C'}) change lowercase a, b and c into
        their uppercase variants (6) tr.substitute( {('a','a'):('A','A'),
        ('b','b'):('B','B'), ('c','c'):('C','C')} ): change lowercase a, b and c into
        their uppercase variants

        In case (4), epsilon transitions are used to attach copies of transducer *S*
        between the SOURCE and TARGET state of each transition that is substituted. The
        transition itself is deleted, but its weight is copied to the epsilon transition
        leading from SOURCE to the initial state of *S*. Each final state of *S* is made
        non-final and an epsilon transition leading to TARGET is attached to it. The
        final weight is copied to the epsilon transition.
        """
        if S == None:
           if not isinstance(s, dict):
              raise RuntimeError('First input argument must be a dictionary.')

           subst_type=""

           for k, v in s.items():
               if _is_string(k):
                  if subst_type == "":
                     subst_type="string"
                  elif subst_type == "string pair":
                     raise RuntimeError('')
                  if not _is_string(v):
                     raise RuntimeError('')
               elif _is_string_pair(k):
                  if subst_type == "":
                     subst_type="string pair"
                  elif subst_type == "string":
                     raise RuntimeError('')
                  if not _is_string_pair(v):
                     raise RuntimeError('')
               else:
                  raise RuntimeError('')

           if subst_type == "string":
              return self._substitute_symbols(s)
           else:
              return self._substitute_symbol_pairs(s)

        if _is_string(s):
           if _is_string(S):
              input=True
              output=True
              for k,v in kwargs.items():
                  if k == 'input':
                     if v == False:
                        input=False
                  elif k == 'output':
                     if v == False:
                        output=False
                  else:
                     raise RuntimeError('Free argument not recognized.')
              return self._substitute_symbol(s, S, input, output)
           else:
              raise RuntimeError('...')
        elif _is_string_pair(s):
           if _is_string_pair(S):
              return self._substitute_symbol_pair(s, S)
           elif _is_string_pair_vector(S):
              return self._substitute_symbol_pair_with_set(s, S)
           elif isinstance(S, HfstIterableTransducer):
              return self._substitute_symbol_pair_with_transducer(s, S)
           else:
              raise RuntimeError('...')
        else:
           raise RuntimeError('...')


    __swig_destroy__ = _libhfst_dev.delete_HfstIterableTransducer
    __del__ = lambda self: None
HfstIterableTransducer_swigregister = _libhfst_dev.HfstIterableTransducer_swigregister
HfstIterableTransducer_swigregister(HfstIterableTransducer)

def HfstIterableTransducer_read_binary_sfst_transducer(filename):
    return _libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer(filename)
HfstIterableTransducer_read_binary_sfst_transducer = _libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer

class HfstTransition(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransition, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransition, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransition(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstTransition
    __del__ = lambda self: None

    def get_target_state(self):
        return _libhfst_dev.HfstTransition_get_target_state(self)

    def get_input_symbol(self):
        return _libhfst_dev.HfstTransition_get_input_symbol(self)

    def set_input_symbol(self, symbol):
        return _libhfst_dev.HfstTransition_set_input_symbol(self, symbol)

    def get_output_symbol(self):
        return _libhfst_dev.HfstTransition_get_output_symbol(self)

    def set_output_symbol(self, symbol):
        return _libhfst_dev.HfstTransition_set_output_symbol(self, symbol)

    def get_weight(self):
        return _libhfst_dev.HfstTransition_get_weight(self)

    def set_weight(self, f):
        return _libhfst_dev.HfstTransition_set_weight(self, f)

    def __str__(self):
        return _libhfst_dev.HfstTransition___str__(self)
HfstTransition_swigregister = _libhfst_dev.HfstTransition_swigregister
HfstTransition_swigregister(HfstTransition)

class XreCompiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XreCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XreCompiler, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_XreCompiler(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def define_list(self, name, symbol_list):
        return _libhfst_dev.XreCompiler_define_list(self, name, symbol_list)

    def define_function(self, name, arguments, xre):
        return _libhfst_dev.XreCompiler_define_function(self, name, arguments, xre)

    def is_definition(self, name):
        return _libhfst_dev.XreCompiler_is_definition(self, name)

    def is_function_definition(self, name):
        return _libhfst_dev.XreCompiler_is_function_definition(self, name)

    def undefine(self, name):
        return _libhfst_dev.XreCompiler_undefine(self, name)

    def compile(self, xre):
        return _libhfst_dev.XreCompiler_compile(self, xre)

    def set_verbosity(self, verbose):
        return _libhfst_dev.XreCompiler_set_verbosity(self, verbose)

    def set_expand_definitions(self, expand):
        return _libhfst_dev.XreCompiler_set_expand_definitions(self, expand)

    def set_harmonization(self, harmonize):
        return _libhfst_dev.XreCompiler_set_harmonization(self, harmonize)

    def contained_only_comments(self):
        return _libhfst_dev.XreCompiler_contained_only_comments(self)

    def define_xre(self, name, xre):
        return _libhfst_dev.XreCompiler_define_xre(self, name, xre)

    def define_transducer(self, name, transducer):
        return _libhfst_dev.XreCompiler_define_transducer(self, name, transducer)

    def compile_first(self, xre):
        return _libhfst_dev.XreCompiler_compile_first(self, xre)

    def compile_iostream(self, xre):
        return _libhfst_dev.XreCompiler_compile_iostream(self, xre)
    __swig_destroy__ = _libhfst_dev.delete_XreCompiler
    __del__ = lambda self: None
XreCompiler_swigregister = _libhfst_dev.XreCompiler_swigregister
XreCompiler_swigregister(XreCompiler)

class LexcCompiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LexcCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LexcCompiler, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_LexcCompiler(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setVerbosity(self, verbose):
        return _libhfst_dev.LexcCompiler_setVerbosity(self, verbose)

    def print_output(self, str):
        return _libhfst_dev.LexcCompiler_print_output(self, str)

    def parse(self, filename):
        return _libhfst_dev.LexcCompiler_parse(self, filename)

    def parse_line(self, line):
        return _libhfst_dev.LexcCompiler_parse_line(self, line)

    def compileLexical(self):
        return _libhfst_dev.LexcCompiler_compileLexical(self)
    __swig_destroy__ = _libhfst_dev.delete_LexcCompiler
    __del__ = lambda self: None
LexcCompiler_swigregister = _libhfst_dev.LexcCompiler_swigregister
LexcCompiler_swigregister(LexcCompiler)

class XfstCompiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XfstCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XfstCompiler, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_XfstCompiler(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setReadInteractiveTextFromStdin(self, Value):
        return _libhfst_dev.XfstCompiler_setReadInteractiveTextFromStdin(self, Value)

    def setReadline(self, value):
        return _libhfst_dev.XfstCompiler_setReadline(self, value)

    def setVerbosity(self, verbosity):
        return _libhfst_dev.XfstCompiler_setVerbosity(self, verbosity)

    def setInspectNetSupported(self, value):
        return _libhfst_dev.XfstCompiler_setInspectNetSupported(self, value)

    def set(self, name, text):
        return _libhfst_dev.XfstCompiler_set(self, name, text)

    def get(self, name):
        return _libhfst_dev.XfstCompiler_get(self, name)

    def top(self, silent=False):
        return _libhfst_dev.XfstCompiler_top(self, silent)

    def get_prompt(self):
        return _libhfst_dev.XfstCompiler_get_prompt(self)

    def apply_up(self, indata):
        return _libhfst_dev.XfstCompiler_apply_up(self, indata)

    def apply_down(self, indata):
        return _libhfst_dev.XfstCompiler_apply_down(self, indata)

    def parse_line(self, line):
        return _libhfst_dev.XfstCompiler_parse_line(self, line)

    def quit_requested(self):
        return _libhfst_dev.XfstCompiler_quit_requested(self)
    __swig_destroy__ = _libhfst_dev.delete_XfstCompiler
    __del__ = lambda self: None
XfstCompiler_swigregister = _libhfst_dev.XfstCompiler_swigregister
XfstCompiler_swigregister(XfstCompiler)


def get_hfst_sfst_output():
    return _libhfst_dev.get_hfst_sfst_output()
get_hfst_sfst_output = _libhfst_dev.get_hfst_sfst_output

def hfst_compile_sfst(filename, error_stream, verbose):
    return _libhfst_dev.hfst_compile_sfst(filename, error_stream, verbose)
hfst_compile_sfst = _libhfst_dev.hfst_compile_sfst

def one_level_paths_to_string(arg1, show_flags):
    return _libhfst_dev.one_level_paths_to_string(arg1, show_flags)
one_level_paths_to_string = _libhfst_dev.one_level_paths_to_string

def two_level_paths_to_string(arg1):
    return _libhfst_dev.two_level_paths_to_string(arg1)
two_level_paths_to_string = _libhfst_dev.two_level_paths_to_string

def parse_prolog_network_line(line, graph):
    return _libhfst_dev.parse_prolog_network_line(line, graph)
parse_prolog_network_line = _libhfst_dev.parse_prolog_network_line

def parse_prolog_arc_line(line, graph):
    return _libhfst_dev.parse_prolog_arc_line(line, graph)
parse_prolog_arc_line = _libhfst_dev.parse_prolog_arc_line

def parse_prolog_symbol_line(line, graph):
    return _libhfst_dev.parse_prolog_symbol_line(line, graph)
parse_prolog_symbol_line = _libhfst_dev.parse_prolog_symbol_line

def parse_prolog_final_line(line, graph):
    return _libhfst_dev.parse_prolog_final_line(line, graph)
parse_prolog_final_line = _libhfst_dev.parse_prolog_final_line

def set_default_fst_type(t):
    """


    Set the default implementation type.

    Parameters
    ----------
    * `impl` :
        An hfst.ImplementationType.

    Set the implementation type (SFST_TYPE, TROPICAL_OPENFST_TYPE, FOMA_TYPE) that
    is used by default by all operations that create transducers. The default value
    is TROPICAL_OPENFST_TYPE

    """
    return _libhfst_dev.set_default_fst_type(t)

def get_default_fst_type():
    """


    Get default transducer implementation type.

    If the default type is not set, it defaults to hfst.ImplementationType.TROPICAL_OPENFST_TYPE

    """
    return _libhfst_dev.get_default_fst_type()

def fst_type_to_string(t):
    """


    Get a string representation of transducer implementation type *type*.

    Parameters
    ----------
    * `type` :
        An hfst.ImplementationType.

    """
    return _libhfst_dev.fst_type_to_string(t)

def two_level_if(context, mappings, alphabet):
    return _libhfst_dev.two_level_if(context, mappings, alphabet)
two_level_if = _libhfst_dev.two_level_if

def two_level_only_if(context, mappings, alphabet):
    return _libhfst_dev.two_level_only_if(context, mappings, alphabet)
two_level_only_if = _libhfst_dev.two_level_only_if

def two_level_if_and_only_if(context, mappings, alphabet):
    return _libhfst_dev.two_level_if_and_only_if(context, mappings, alphabet)
two_level_if_and_only_if = _libhfst_dev.two_level_if_and_only_if

def replace_down_karttunen(context, mapping, optional, alphabet):
    return _libhfst_dev.replace_down_karttunen(context, mapping, optional, alphabet)
replace_down_karttunen = _libhfst_dev.replace_down_karttunen

def replace_right(context, mapping, optional, alphabet):
    return _libhfst_dev.replace_right(context, mapping, optional, alphabet)
replace_right = _libhfst_dev.replace_right

def replace_left(context, mapping, optional, alphabet):
    return _libhfst_dev.replace_left(context, mapping, optional, alphabet)
replace_left = _libhfst_dev.replace_left

def replace_up(mapping, optional, alphabet):
    return _libhfst_dev.replace_up(mapping, optional, alphabet)
replace_up = _libhfst_dev.replace_up

def replace_down(*args):
    return _libhfst_dev.replace_down(*args)
replace_down = _libhfst_dev.replace_down

def left_replace_up(*args):
    return _libhfst_dev.left_replace_up(*args)
left_replace_up = _libhfst_dev.left_replace_up

def left_replace_down(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_down(context, mapping, optional, alphabet)
left_replace_down = _libhfst_dev.left_replace_down

def left_replace_down_karttunen(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_down_karttunen(context, mapping, optional, alphabet)
left_replace_down_karttunen = _libhfst_dev.left_replace_down_karttunen

def left_replace_left(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_left(context, mapping, optional, alphabet)
left_replace_left = _libhfst_dev.left_replace_left

def left_replace_right(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_right(context, mapping, optional, alphabet)
left_replace_right = _libhfst_dev.left_replace_right

def restriction(contexts, mapping, alphabet):
    return _libhfst_dev.restriction(contexts, mapping, alphabet)
restriction = _libhfst_dev.restriction

def coercion(contexts, mapping, alphabet):
    return _libhfst_dev.coercion(contexts, mapping, alphabet)
coercion = _libhfst_dev.coercion

def restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.restriction_and_coercion(contexts, mapping, alphabet)
restriction_and_coercion = _libhfst_dev.restriction_and_coercion

def surface_restriction(contexts, mapping, alphabet):
    return _libhfst_dev.surface_restriction(contexts, mapping, alphabet)
surface_restriction = _libhfst_dev.surface_restriction

def surface_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.surface_coercion(contexts, mapping, alphabet)
surface_coercion = _libhfst_dev.surface_coercion

def surface_restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.surface_restriction_and_coercion(contexts, mapping, alphabet)
surface_restriction_and_coercion = _libhfst_dev.surface_restriction_and_coercion

def deep_restriction(contexts, mapping, alphabet):
    return _libhfst_dev.deep_restriction(contexts, mapping, alphabet)
deep_restriction = _libhfst_dev.deep_restriction

def deep_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.deep_coercion(contexts, mapping, alphabet)
deep_coercion = _libhfst_dev.deep_coercion

def deep_restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.deep_restriction_and_coercion(contexts, mapping, alphabet)
deep_restriction_and_coercion = _libhfst_dev.deep_restriction_and_coercion
class TwolcCompiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TwolcCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TwolcCompiler, name)
    __repr__ = _swig_repr
    __swig_getmethods__["compile_file_and_get_storable_rules"] = lambda x: _libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules
    if _newclass:
        compile_file_and_get_storable_rules = staticmethod(_libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules)
    __swig_getmethods__["compile_script_and_get_storable_rules"] = lambda x: _libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules
    if _newclass:
        compile_script_and_get_storable_rules = staticmethod(_libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules)

    def __init__(self):
        this = _libhfst_dev.new_TwolcCompiler()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TwolcCompiler
    __del__ = lambda self: None
TwolcCompiler_swigregister = _libhfst_dev.TwolcCompiler_swigregister
TwolcCompiler_swigregister(TwolcCompiler)

def TwolcCompiler_compile_file_and_get_storable_rules(inputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr=None):
    return _libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules(inputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr)
TwolcCompiler_compile_file_and_get_storable_rules = _libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules

def TwolcCompiler_compile_script_and_get_storable_rules(script, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr=None):
    return _libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules(script, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr)
TwolcCompiler_compile_script_and_get_storable_rules = _libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules


def pmatch_get_tokenized_output(cont, input_text, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar):
    return _libhfst_dev.pmatch_get_tokenized_output(cont, input_text, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar)
pmatch_get_tokenized_output = _libhfst_dev.pmatch_get_tokenized_output

def pmatch_locate(*args):
    return _libhfst_dev.pmatch_locate(*args)
pmatch_locate = _libhfst_dev.pmatch_locate
class PmatchContainer(_object):
    """


    A class for performing pattern matching.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PmatchContainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PmatchContainer, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst_dev.delete_PmatchContainer
    __del__ = lambda self: None

    def match(self, input, time_cutoff=0.0):
        """


        Match input *input*.

        """
        return _libhfst_dev.PmatchContainer_match(self, input, time_cutoff)


    def get_profiling_info(self):
        """


        todo

        """
        return _libhfst_dev.PmatchContainer_get_profiling_info(self)


    def set_verbose(self, b):
        """


        todo

        """
        return _libhfst_dev.PmatchContainer_set_verbose(self, b)


    def set_profile(self, b):
        """


        todo

        """
        return _libhfst_dev.PmatchContainer_set_profile(self, b)


    def __init__(self, *args):
        this = _libhfst_dev.new_PmatchContainer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def locate(self, *args):
        """


        The locations of pmatched strings for string *input* where the results are limited
        as defined by *time_cutoff* and *weight_cutoff*.

        Parameters
        ----------
        * `input` :
            The input string.
        * `time_cutoff` :
            Time cutoff, defaults to zero, i.e. no cutoff.
        * `weight_cutoff` :
            Weight cutoff, defaults to infinity, i.e. no cutoff.

        Returns
        -------
        A tuple of tuples of Location.

        """
        return _libhfst_dev.PmatchContainer_locate(self, *args)


    def get_tokenized_output(self, input, **kwargs):
        """
        Tokenize *input* and get a string representation of the tokenization
        (essentially the same that command line tool hfst-tokenize would give).

        Parameters
        ----------
        * `input` :
            The input string to be tokenized.
        * `kwargs` :
            Possible parameters are:
            output_format, max_weight_classes, dedupe, print_weights, print_all,
            time_cutoff, verbose, beam, tokenize_multichar.
        * `output_format` :
            The format of output; possible values are 'tokenize', 'xerox', 'cg', 'finnpos',
            'giellacg', 'conllu' and 'visl'; 'tokenize' being the default.
        * `max_weight_classes` :
            Maximum number of best weight classes to output
            (where analyses with equal weight constitute a class), defaults to None i.e. no limit.
        * `dedupe` :
            Whether duplicate analyses are removed, defaults to False.
        * `print_weights` :
            Whether weights are printd, defaults to False.
        * `print_all` :
            Whether nonmatching text is printed, defaults to False.
        * `time_cutoff` :
            Maximum number of seconds used per input after limiting the search.
        * `verbose` :
            Whether input is processed verbosely, defaults to True.
        * `beam` :
            Beam within analyses must be to get printed.
        * `tokenize_multichar` :
            Tokenize input into multicharacter symbols present in the transducer, defaults to false.
        """
        output_format='tokenize'
        max_weight_classes=None
        dedupe=False
        print_weights=False
        print_all=False
        time_cutoff=0.0
        verbose=True
        beam=-1.0
        tokenize_multichar=False
        for k,v in kwargs.items():
           if k == 'output_format':
              if v == 'tokenize' or v == 'space_separated' or v == 'xerox' or v == 'cg' or v == 'finnpos' or v == 'giellacg' or v == 'conllu':
                 output_format=v
              else:
                 print('Warning: ignoring unknown value %s for argument %s.' % (v,k))
           elif k == 'max_weight_classes':
              max_weight_classes=int(v)
           elif k == 'dedupe':
              dedupe=v
           elif k == 'print_weights':
              print_weights=v
           elif k == 'print_all':
              print_all=v
           elif k == 'time_cutoff':
              time_cutoff=float(v)
           elif k == 'verbose':
              verbose=v
           elif k == 'beam':
              beam=float(v)
           elif k == 'tokenize_multichar':
              tokenize_multichar=v
           else:
              print('Warning: ignoring unknown argument %s.' % (k))
        return pmatch_get_tokenized_output(self, input, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar)

    def tokenize(self, input):
        """
        Tokenize *input* and return a list of tokens i.e. strings.

        Parameters
        ----------
        * `input` :
            The string to be tokenized.
        """
        retval = []
        locations = self.locate(input)
        for loc in locations:
           if loc[0].output != "@_NONMATCHING_@":
              retval.append(loc[0].input)
        return retval


PmatchContainer_swigregister = _libhfst_dev.PmatchContainer_swigregister
PmatchContainer_swigregister(PmatchContainer)



class ImplementationType:
    """
    Back-end implementation.

    Attributes:

        SFST_TYPE:               SFST type, unweighted
        TROPICAL_OPENFST_TYPE:   OpenFst type with tropical weights
        LOG_OPENFST_TYPE:        OpenFst type with logarithmic weights (limited support)
        FOMA_TYPE:               FOMA type, unweighted
        XFSM_TYPE:               XFST type, unweighted (limited support)
        HFST_OL_TYPE:            HFST optimized-lookup type, unweighted
        HFST_OLW_TYPE:           HFST optimized-lookup type, weighted
        HFST2_TYPE:              HFST version 2 legacy type
        UNSPECIFIED_TYPE:        type not specified
        ERROR_TYPE:              (something went wrong)

    """
    SFST_TYPE = _libhfst_dev.SFST_TYPE
    TROPICAL_OPENFST_TYPE = _libhfst_dev.TROPICAL_OPENFST_TYPE
    LOG_OPENFST_TYPE = _libhfst_dev.LOG_OPENFST_TYPE
    FOMA_TYPE = _libhfst_dev.FOMA_TYPE
    XFSM_TYPE = _libhfst_dev.XFSM_TYPE
    HFST_OL_TYPE = _libhfst_dev.HFST_OL_TYPE
    HFST_OLW_TYPE = _libhfst_dev.HFST_OLW_TYPE
    HFST2_TYPE = _libhfst_dev.HFST2_TYPE
    UNSPECIFIED_TYPE = _libhfst_dev.UNSPECIFIED_TYPE
    ERROR_TYPE = _libhfst_dev.ERROR_TYPE

class ReplaceType:
    """
    Replace type in Xerox-type rules.

    Attributes:

        REPL_UP:      Match contexts on input level
        REPL_DOWN:    Match contexts on output level
        REPL_RIGHT:   Match left contexts on input level and right contexts on output level
        REPL_LEFT:    Match left contexts on output level and right contexts on input level

    """
    REPL_UP = _libhfst_dev.REPL_UP
    REPL_DOWN = _libhfst_dev.REPL_DOWN
    REPL_RIGHT = _libhfst_dev.REPL_RIGHT
    REPL_LEFT = _libhfst_dev.REPL_LEFT


# This file is compatible with both classic and new-style classes.


