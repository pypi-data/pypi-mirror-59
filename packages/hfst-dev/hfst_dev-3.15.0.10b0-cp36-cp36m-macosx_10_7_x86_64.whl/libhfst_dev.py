# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_libhfst_dev', [dirname(__file__)])
        except ImportError:
            import _libhfst_dev
            return _libhfst_dev
        if fp is not None:
            try:
                _mod = imp.load_module('_libhfst_dev', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _libhfst_dev = swig_import_helper()
    del swig_import_helper
else:
    import _libhfst_dev
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst_dev.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _libhfst_dev.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _libhfst_dev.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _libhfst_dev.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _libhfst_dev.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _libhfst_dev.SwigPyIterator_equal(self, x)

    def copy(self):
        return _libhfst_dev.SwigPyIterator_copy(self)

    def next(self):
        return _libhfst_dev.SwigPyIterator_next(self)

    def __next__(self):
        return _libhfst_dev.SwigPyIterator___next__(self)

    def previous(self):
        return _libhfst_dev.SwigPyIterator_previous(self)

    def advance(self, n):
        return _libhfst_dev.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _libhfst_dev.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _libhfst_dev.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _libhfst_dev.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _libhfst_dev.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _libhfst_dev.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _libhfst_dev.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _libhfst_dev.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.StringVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.StringVector_pop(self)

    def append(self, x):
        return _libhfst_dev.StringVector_append(self, x)

    def empty(self):
        return _libhfst_dev.StringVector_empty(self)

    def size(self):
        return _libhfst_dev.StringVector_size(self)

    def swap(self, v):
        return _libhfst_dev.StringVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.StringVector_begin(self)

    def end(self):
        return _libhfst_dev.StringVector_end(self)

    def rbegin(self):
        return _libhfst_dev.StringVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringVector_rend(self)

    def clear(self):
        return _libhfst_dev.StringVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.StringVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.StringVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.StringVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.StringVector_front(self)

    def back(self):
        return _libhfst_dev.StringVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.StringVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.StringVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.StringVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.StringVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _libhfst_dev.StringVector_swigregister
StringVector_swigregister(StringVector)

class StringPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_StringPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.StringPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.StringPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.StringPair_first_get, _libhfst_dev.StringPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.StringPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.StringPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.StringPair_second_get, _libhfst_dev.StringPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_StringPair
    __del__ = lambda self: None
StringPair_swigregister = _libhfst_dev.StringPair_swigregister
StringPair_swigregister(StringPair)

class StringPairVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringPairVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringPairVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringPairVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringPairVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringPairVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.StringPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.StringPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.StringPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.StringPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.StringPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.StringPairVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.StringPairVector_pop(self)

    def append(self, x):
        return _libhfst_dev.StringPairVector_append(self, x)

    def empty(self):
        return _libhfst_dev.StringPairVector_empty(self)

    def size(self):
        return _libhfst_dev.StringPairVector_size(self)

    def swap(self, v):
        return _libhfst_dev.StringPairVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.StringPairVector_begin(self)

    def end(self):
        return _libhfst_dev.StringPairVector_end(self)

    def rbegin(self):
        return _libhfst_dev.StringPairVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringPairVector_rend(self)

    def clear(self):
        return _libhfst_dev.StringPairVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.StringPairVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.StringPairVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.StringPairVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringPairVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.StringPairVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.StringPairVector_front(self)

    def back(self):
        return _libhfst_dev.StringPairVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.StringPairVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.StringPairVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.StringPairVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.StringPairVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.StringPairVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_StringPairVector
    __del__ = lambda self: None
StringPairVector_swigregister = _libhfst_dev.StringPairVector_swigregister
StringPairVector_swigregister(StringPairVector)

class FloatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.FloatVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.FloatVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.FloatVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.FloatVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.FloatVector_pop(self)

    def append(self, x):
        return _libhfst_dev.FloatVector_append(self, x)

    def empty(self):
        return _libhfst_dev.FloatVector_empty(self)

    def size(self):
        return _libhfst_dev.FloatVector_size(self)

    def swap(self, v):
        return _libhfst_dev.FloatVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.FloatVector_begin(self)

    def end(self):
        return _libhfst_dev.FloatVector_end(self)

    def rbegin(self):
        return _libhfst_dev.FloatVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.FloatVector_rend(self)

    def clear(self):
        return _libhfst_dev.FloatVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.FloatVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.FloatVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.FloatVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_FloatVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.FloatVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.FloatVector_front(self)

    def back(self):
        return _libhfst_dev.FloatVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.FloatVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.FloatVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.FloatVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.FloatVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.FloatVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_FloatVector
    __del__ = lambda self: None
FloatVector_swigregister = _libhfst_dev.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class StringSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringSet, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringSet___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringSet___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringSet___len__(self)

    def append(self, x):
        return _libhfst_dev.StringSet_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.StringSet___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.StringSet___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.StringSet_add(self, x)

    def discard(self, x):
        return _libhfst_dev.StringSet_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringSet(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.StringSet_empty(self)

    def size(self):
        return _libhfst_dev.StringSet_size(self)

    def clear(self):
        return _libhfst_dev.StringSet_clear(self)

    def swap(self, v):
        return _libhfst_dev.StringSet_swap(self, v)

    def count(self, x):
        return _libhfst_dev.StringSet_count(self, x)

    def begin(self):
        return _libhfst_dev.StringSet_begin(self)

    def end(self):
        return _libhfst_dev.StringSet_end(self)

    def rbegin(self):
        return _libhfst_dev.StringSet_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringSet_rend(self)

    def erase(self, *args):
        return _libhfst_dev.StringSet_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.StringSet_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.StringSet_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.StringSet_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.StringSet_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.StringSet_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_StringSet
    __del__ = lambda self: None
StringSet_swigregister = _libhfst_dev.StringSet_swigregister
StringSet_swigregister(StringSet)

class StringPairSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringPairSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringPairSet, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.StringPairSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.StringPairSet___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.StringPairSet___bool__(self)

    def __len__(self):
        return _libhfst_dev.StringPairSet___len__(self)

    def append(self, x):
        return _libhfst_dev.StringPairSet_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.StringPairSet___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.StringPairSet___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.StringPairSet_add(self, x)

    def discard(self, x):
        return _libhfst_dev.StringPairSet_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_StringPairSet(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.StringPairSet_empty(self)

    def size(self):
        return _libhfst_dev.StringPairSet_size(self)

    def clear(self):
        return _libhfst_dev.StringPairSet_clear(self)

    def swap(self, v):
        return _libhfst_dev.StringPairSet_swap(self, v)

    def count(self, x):
        return _libhfst_dev.StringPairSet_count(self, x)

    def begin(self):
        return _libhfst_dev.StringPairSet_begin(self)

    def end(self):
        return _libhfst_dev.StringPairSet_end(self)

    def rbegin(self):
        return _libhfst_dev.StringPairSet_rbegin(self)

    def rend(self):
        return _libhfst_dev.StringPairSet_rend(self)

    def erase(self, *args):
        return _libhfst_dev.StringPairSet_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.StringPairSet_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.StringPairSet_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.StringPairSet_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.StringPairSet_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.StringPairSet_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_StringPairSet
    __del__ = lambda self: None
StringPairSet_swigregister = _libhfst_dev.StringPairSet_swigregister
StringPairSet_swigregister(StringPairSet)

class HfstTransducerVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTransducerVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTransducerVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTransducerVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTransducerVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstTransducerVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstTransducerVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstTransducerVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstTransducerVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstTransducerVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstTransducerVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstTransducerVector_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstTransducerVector_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstTransducerVector_empty(self)

    def size(self):
        return _libhfst_dev.HfstTransducerVector_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstTransducerVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstTransducerVector_begin(self)

    def end(self):
        return _libhfst_dev.HfstTransducerVector_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTransducerVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTransducerVector_rend(self)

    def clear(self):
        return _libhfst_dev.HfstTransducerVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstTransducerVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstTransducerVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTransducerVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstTransducerVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstTransducerVector_front(self)

    def back(self):
        return _libhfst_dev.HfstTransducerVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstTransducerVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstTransducerVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstTransducerVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstTransducerVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstTransducerVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerVector
    __del__ = lambda self: None
HfstTransducerVector_swigregister = _libhfst_dev.HfstTransducerVector_swigregister
HfstTransducerVector_swigregister(HfstTransducerVector)

class HfstSymbolSubstitutions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstSymbolSubstitutions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstSymbolSubstitutions, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstSymbolSubstitutions___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstSymbolSubstitutions___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstSymbolSubstitutions___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions___getitem__(self, key)

    def __delitem__(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions___delitem__(self, key)

    def has_key(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions_has_key(self, key)

    def keys(self):
        return _libhfst_dev.HfstSymbolSubstitutions_keys(self)

    def values(self):
        return _libhfst_dev.HfstSymbolSubstitutions_values(self)

    def items(self):
        return _libhfst_dev.HfstSymbolSubstitutions_items(self)

    def __contains__(self, key):
        return _libhfst_dev.HfstSymbolSubstitutions___contains__(self, key)

    def key_iterator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_key_iterator(self)

    def value_iterator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_value_iterator(self)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstSymbolSubstitutions___setitem__(self, *args)

    def asdict(self):
        return _libhfst_dev.HfstSymbolSubstitutions_asdict(self)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstSymbolSubstitutions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstSymbolSubstitutions_empty(self)

    def size(self):
        return _libhfst_dev.HfstSymbolSubstitutions_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstSymbolSubstitutions_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstSymbolSubstitutions_begin(self)

    def end(self):
        return _libhfst_dev.HfstSymbolSubstitutions_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstSymbolSubstitutions_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstSymbolSubstitutions_rend(self)

    def clear(self):
        return _libhfst_dev.HfstSymbolSubstitutions_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstSymbolSubstitutions_get_allocator(self)

    def count(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_count(self, x)

    def erase(self, *args):
        return _libhfst_dev.HfstSymbolSubstitutions_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstSymbolSubstitutions_upper_bound(self, x)
    __swig_destroy__ = _libhfst_dev.delete_HfstSymbolSubstitutions
    __del__ = lambda self: None
HfstSymbolSubstitutions_swigregister = _libhfst_dev.HfstSymbolSubstitutions_swigregister
HfstSymbolSubstitutions_swigregister(HfstSymbolSubstitutions)

class HfstSymbolPairSubstitutions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstSymbolPairSubstitutions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstSymbolPairSubstitutions, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions___getitem__(self, key)

    def __delitem__(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions___delitem__(self, key)

    def has_key(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions_has_key(self, key)

    def keys(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_keys(self)

    def values(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_values(self)

    def items(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_items(self)

    def __contains__(self, key):
        return _libhfst_dev.HfstSymbolPairSubstitutions___contains__(self, key)

    def key_iterator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_key_iterator(self)

    def value_iterator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_value_iterator(self)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstSymbolPairSubstitutions___setitem__(self, *args)

    def asdict(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_asdict(self)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstSymbolPairSubstitutions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_empty(self)

    def size(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstSymbolPairSubstitutions_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_begin(self)

    def end(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_rend(self)

    def clear(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstSymbolPairSubstitutions_get_allocator(self)

    def count(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_count(self, x)

    def erase(self, *args):
        return _libhfst_dev.HfstSymbolPairSubstitutions_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstSymbolPairSubstitutions_upper_bound(self, x)
    __swig_destroy__ = _libhfst_dev.delete_HfstSymbolPairSubstitutions
    __del__ = lambda self: None
HfstSymbolPairSubstitutions_swigregister = _libhfst_dev.HfstSymbolPairSubstitutions_swigregister
HfstSymbolPairSubstitutions_swigregister(HfstSymbolPairSubstitutions)

class UIntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UIntVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.UIntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.UIntVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.UIntVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.UIntVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.UIntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.UIntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.UIntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.UIntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.UIntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.UIntVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.UIntVector_pop(self)

    def append(self, x):
        return _libhfst_dev.UIntVector_append(self, x)

    def empty(self):
        return _libhfst_dev.UIntVector_empty(self)

    def size(self):
        return _libhfst_dev.UIntVector_size(self)

    def swap(self, v):
        return _libhfst_dev.UIntVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.UIntVector_begin(self)

    def end(self):
        return _libhfst_dev.UIntVector_end(self)

    def rbegin(self):
        return _libhfst_dev.UIntVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.UIntVector_rend(self)

    def clear(self):
        return _libhfst_dev.UIntVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.UIntVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.UIntVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.UIntVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_UIntVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.UIntVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.UIntVector_front(self)

    def back(self):
        return _libhfst_dev.UIntVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.UIntVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.UIntVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.UIntVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.UIntVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.UIntVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_UIntVector
    __del__ = lambda self: None
UIntVector_swigregister = _libhfst_dev.UIntVector_swigregister
UIntVector_swigregister(UIntVector)

class HfstTransitions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransitions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransitions, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTransitions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTransitions___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTransitions___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTransitions___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstTransitions___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstTransitions___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstTransitions___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstTransitions___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstTransitions___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstTransitions___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstTransitions_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstTransitions_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstTransitions_empty(self)

    def size(self):
        return _libhfst_dev.HfstTransitions_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstTransitions_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstTransitions_begin(self)

    def end(self):
        return _libhfst_dev.HfstTransitions_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTransitions_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTransitions_rend(self)

    def clear(self):
        return _libhfst_dev.HfstTransitions_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstTransitions_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstTransitions_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTransitions_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransitions(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstTransitions_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstTransitions_front(self)

    def back(self):
        return _libhfst_dev.HfstTransitions_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstTransitions_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstTransitions_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstTransitions_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstTransitions_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstTransitions_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstTransitions
    __del__ = lambda self: None
HfstTransitions_swigregister = _libhfst_dev.HfstTransitions_swigregister
HfstTransitions_swigregister(HfstTransitions)

class HfstOneLevelPath(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstOneLevelPath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstOneLevelPath, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstOneLevelPath(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstOneLevelPath_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstOneLevelPath_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstOneLevelPath_first_get, _libhfst_dev.HfstOneLevelPath_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstOneLevelPath_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstOneLevelPath_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstOneLevelPath_second_get, _libhfst_dev.HfstOneLevelPath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstOneLevelPath
    __del__ = lambda self: None
HfstOneLevelPath_swigregister = _libhfst_dev.HfstOneLevelPath_swigregister
HfstOneLevelPath_swigregister(HfstOneLevelPath)

class HfstOneLevelPaths(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstOneLevelPaths, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstOneLevelPaths, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstOneLevelPaths_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstOneLevelPaths___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstOneLevelPaths___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstOneLevelPaths___len__(self)

    def append(self, x):
        return _libhfst_dev.HfstOneLevelPaths_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.HfstOneLevelPaths___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.HfstOneLevelPaths___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.HfstOneLevelPaths_add(self, x)

    def discard(self, x):
        return _libhfst_dev.HfstOneLevelPaths_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstOneLevelPaths(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstOneLevelPaths_empty(self)

    def size(self):
        return _libhfst_dev.HfstOneLevelPaths_size(self)

    def clear(self):
        return _libhfst_dev.HfstOneLevelPaths_clear(self)

    def swap(self, v):
        return _libhfst_dev.HfstOneLevelPaths_swap(self, v)

    def count(self, x):
        return _libhfst_dev.HfstOneLevelPaths_count(self, x)

    def begin(self):
        return _libhfst_dev.HfstOneLevelPaths_begin(self)

    def end(self):
        return _libhfst_dev.HfstOneLevelPaths_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstOneLevelPaths_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstOneLevelPaths_rend(self)

    def erase(self, *args):
        return _libhfst_dev.HfstOneLevelPaths_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstOneLevelPaths_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstOneLevelPaths_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstOneLevelPaths_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.HfstOneLevelPaths_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.HfstOneLevelPaths_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_HfstOneLevelPaths
    __del__ = lambda self: None
HfstOneLevelPaths_swigregister = _libhfst_dev.HfstOneLevelPaths_swigregister
HfstOneLevelPaths_swigregister(HfstOneLevelPaths)

class HfstTwoLevelPath(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTwoLevelPath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTwoLevelPath, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTwoLevelPath(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTwoLevelPath_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTwoLevelPath_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTwoLevelPath_first_get, _libhfst_dev.HfstTwoLevelPath_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTwoLevelPath_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTwoLevelPath_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTwoLevelPath_second_get, _libhfst_dev.HfstTwoLevelPath_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTwoLevelPath
    __del__ = lambda self: None
HfstTwoLevelPath_swigregister = _libhfst_dev.HfstTwoLevelPath_swigregister
HfstTwoLevelPath_swigregister(HfstTwoLevelPath)

class HfstTwoLevelPaths(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTwoLevelPaths, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTwoLevelPaths, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTwoLevelPaths_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTwoLevelPaths___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTwoLevelPaths___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTwoLevelPaths___len__(self)

    def append(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_append(self, x)

    def __contains__(self, x):
        return _libhfst_dev.HfstTwoLevelPaths___contains__(self, x)

    def __getitem__(self, i):
        return _libhfst_dev.HfstTwoLevelPaths___getitem__(self, i)

    def add(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_add(self, x)

    def discard(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_discard(self, x)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTwoLevelPaths(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def empty(self):
        return _libhfst_dev.HfstTwoLevelPaths_empty(self)

    def size(self):
        return _libhfst_dev.HfstTwoLevelPaths_size(self)

    def clear(self):
        return _libhfst_dev.HfstTwoLevelPaths_clear(self)

    def swap(self, v):
        return _libhfst_dev.HfstTwoLevelPaths_swap(self, v)

    def count(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_count(self, x)

    def begin(self):
        return _libhfst_dev.HfstTwoLevelPaths_begin(self)

    def end(self):
        return _libhfst_dev.HfstTwoLevelPaths_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTwoLevelPaths_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTwoLevelPaths_rend(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTwoLevelPaths_erase(self, *args)

    def find(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_find(self, x)

    def lower_bound(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_lower_bound(self, x)

    def upper_bound(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_upper_bound(self, x)

    def equal_range(self, x):
        return _libhfst_dev.HfstTwoLevelPaths_equal_range(self, x)

    def insert(self, __x):
        return _libhfst_dev.HfstTwoLevelPaths_insert(self, __x)
    __swig_destroy__ = _libhfst_dev.delete_HfstTwoLevelPaths
    __del__ = lambda self: None
HfstTwoLevelPaths_swigregister = _libhfst_dev.HfstTwoLevelPaths_swigregister
HfstTwoLevelPaths_swigregister(HfstTwoLevelPaths)

class HfstTransducerPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTransducerPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTransducerPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTransducerPair_first_get, _libhfst_dev.HfstTransducerPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTransducerPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTransducerPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTransducerPair_second_get, _libhfst_dev.HfstTransducerPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerPair
    __del__ = lambda self: None
HfstTransducerPair_swigregister = _libhfst_dev.HfstTransducerPair_swigregister
HfstTransducerPair_swigregister(HfstTransducerPair)

class HfstTransducerPairVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerPairVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerPairVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstTransducerPairVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstTransducerPairVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstTransducerPairVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstTransducerPairVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstTransducerPairVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstTransducerPairVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstTransducerPairVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstTransducerPairVector_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstTransducerPairVector_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstTransducerPairVector_empty(self)

    def size(self):
        return _libhfst_dev.HfstTransducerPairVector_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstTransducerPairVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstTransducerPairVector_begin(self)

    def end(self):
        return _libhfst_dev.HfstTransducerPairVector_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstTransducerPairVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstTransducerPairVector_rend(self)

    def clear(self):
        return _libhfst_dev.HfstTransducerPairVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstTransducerPairVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstTransducerPairVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstTransducerPairVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerPairVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstTransducerPairVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstTransducerPairVector_front(self)

    def back(self):
        return _libhfst_dev.HfstTransducerPairVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstTransducerPairVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstTransducerPairVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstTransducerPairVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstTransducerPairVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstTransducerPairVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerPairVector
    __del__ = lambda self: None
HfstTransducerPairVector_swigregister = _libhfst_dev.HfstTransducerPairVector_swigregister
HfstTransducerPairVector_swigregister(HfstTransducerPairVector)

class HfstRuleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstRuleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstRuleVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.HfstRuleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.HfstRuleVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.HfstRuleVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.HfstRuleVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.HfstRuleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.HfstRuleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.HfstRuleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.HfstRuleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.HfstRuleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.HfstRuleVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.HfstRuleVector_pop(self)

    def append(self, x):
        return _libhfst_dev.HfstRuleVector_append(self, x)

    def empty(self):
        return _libhfst_dev.HfstRuleVector_empty(self)

    def size(self):
        return _libhfst_dev.HfstRuleVector_size(self)

    def swap(self, v):
        return _libhfst_dev.HfstRuleVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.HfstRuleVector_begin(self)

    def end(self):
        return _libhfst_dev.HfstRuleVector_end(self)

    def rbegin(self):
        return _libhfst_dev.HfstRuleVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.HfstRuleVector_rend(self)

    def clear(self):
        return _libhfst_dev.HfstRuleVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.HfstRuleVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.HfstRuleVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.HfstRuleVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstRuleVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.HfstRuleVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.HfstRuleVector_front(self)

    def back(self):
        return _libhfst_dev.HfstRuleVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.HfstRuleVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.HfstRuleVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.HfstRuleVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.HfstRuleVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.HfstRuleVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_HfstRuleVector
    __del__ = lambda self: None
HfstRuleVector_swigregister = _libhfst_dev.HfstRuleVector_swigregister
HfstRuleVector_swigregister(HfstRuleVector)

class HfstTransducerUIntPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerUIntPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerUIntPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerUIntPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTransducerUIntPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTransducerUIntPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTransducerUIntPair_first_get, _libhfst_dev.HfstTransducerUIntPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTransducerUIntPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTransducerUIntPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTransducerUIntPair_second_get, _libhfst_dev.HfstTransducerUIntPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerUIntPair
    __del__ = lambda self: None
HfstTransducerUIntPair_swigregister = _libhfst_dev.HfstTransducerUIntPair_swigregister
HfstTransducerUIntPair_swigregister(HfstTransducerUIntPair)

class LocationVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocationVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocationVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.LocationVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.LocationVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.LocationVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.LocationVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.LocationVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.LocationVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.LocationVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.LocationVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.LocationVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.LocationVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.LocationVector_pop(self)

    def append(self, x):
        return _libhfst_dev.LocationVector_append(self, x)

    def empty(self):
        return _libhfst_dev.LocationVector_empty(self)

    def size(self):
        return _libhfst_dev.LocationVector_size(self)

    def swap(self, v):
        return _libhfst_dev.LocationVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.LocationVector_begin(self)

    def end(self):
        return _libhfst_dev.LocationVector_end(self)

    def rbegin(self):
        return _libhfst_dev.LocationVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.LocationVector_rend(self)

    def clear(self):
        return _libhfst_dev.LocationVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.LocationVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.LocationVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.LocationVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_LocationVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.LocationVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.LocationVector_front(self)

    def back(self):
        return _libhfst_dev.LocationVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.LocationVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.LocationVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.LocationVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.LocationVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.LocationVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_LocationVector
    __del__ = lambda self: None
LocationVector_swigregister = _libhfst_dev.LocationVector_swigregister
LocationVector_swigregister(LocationVector)

class LocationVectorVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocationVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocationVectorVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _libhfst_dev.LocationVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _libhfst_dev.LocationVectorVector___nonzero__(self)

    def __bool__(self):
        return _libhfst_dev.LocationVectorVector___bool__(self)

    def __len__(self):
        return _libhfst_dev.LocationVectorVector___len__(self)

    def __getslice__(self, i, j):
        return _libhfst_dev.LocationVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _libhfst_dev.LocationVectorVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _libhfst_dev.LocationVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _libhfst_dev.LocationVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _libhfst_dev.LocationVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _libhfst_dev.LocationVectorVector___setitem__(self, *args)

    def pop(self):
        return _libhfst_dev.LocationVectorVector_pop(self)

    def append(self, x):
        return _libhfst_dev.LocationVectorVector_append(self, x)

    def empty(self):
        return _libhfst_dev.LocationVectorVector_empty(self)

    def size(self):
        return _libhfst_dev.LocationVectorVector_size(self)

    def swap(self, v):
        return _libhfst_dev.LocationVectorVector_swap(self, v)

    def begin(self):
        return _libhfst_dev.LocationVectorVector_begin(self)

    def end(self):
        return _libhfst_dev.LocationVectorVector_end(self)

    def rbegin(self):
        return _libhfst_dev.LocationVectorVector_rbegin(self)

    def rend(self):
        return _libhfst_dev.LocationVectorVector_rend(self)

    def clear(self):
        return _libhfst_dev.LocationVectorVector_clear(self)

    def get_allocator(self):
        return _libhfst_dev.LocationVectorVector_get_allocator(self)

    def pop_back(self):
        return _libhfst_dev.LocationVectorVector_pop_back(self)

    def erase(self, *args):
        return _libhfst_dev.LocationVectorVector_erase(self, *args)

    def __init__(self, *args):
        this = _libhfst_dev.new_LocationVectorVector(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def push_back(self, x):
        return _libhfst_dev.LocationVectorVector_push_back(self, x)

    def front(self):
        return _libhfst_dev.LocationVectorVector_front(self)

    def back(self):
        return _libhfst_dev.LocationVectorVector_back(self)

    def assign(self, n, x):
        return _libhfst_dev.LocationVectorVector_assign(self, n, x)

    def resize(self, *args):
        return _libhfst_dev.LocationVectorVector_resize(self, *args)

    def insert(self, *args):
        return _libhfst_dev.LocationVectorVector_insert(self, *args)

    def reserve(self, n):
        return _libhfst_dev.LocationVectorVector_reserve(self, n)

    def capacity(self):
        return _libhfst_dev.LocationVectorVector_capacity(self)
    __swig_destroy__ = _libhfst_dev.delete_LocationVectorVector
    __del__ = lambda self: None
LocationVectorVector_swigregister = _libhfst_dev.LocationVectorVector_swigregister
LocationVectorVector_swigregister(LocationVectorVector)

class HfstTransducerStringPair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerStringPair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerStringPair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducerStringPair(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["first"] = _libhfst_dev.HfstTransducerStringPair_first_set
    __swig_getmethods__["first"] = _libhfst_dev.HfstTransducerStringPair_first_get
    if _newclass:
        first = _swig_property(_libhfst_dev.HfstTransducerStringPair_first_get, _libhfst_dev.HfstTransducerStringPair_first_set)
    __swig_setmethods__["second"] = _libhfst_dev.HfstTransducerStringPair_second_set
    __swig_getmethods__["second"] = _libhfst_dev.HfstTransducerStringPair_second_get
    if _newclass:
        second = _swig_property(_libhfst_dev.HfstTransducerStringPair_second_get, _libhfst_dev.HfstTransducerStringPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerStringPair
    __del__ = lambda self: None
HfstTransducerStringPair_swigregister = _libhfst_dev.HfstTransducerStringPair_swigregister
HfstTransducerStringPair_swigregister(HfstTransducerStringPair)

class HfstException(Exception):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstException, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstException(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.HfstException_what(self)

    def __str__(self):
        return _libhfst_dev.HfstException___str__(self)
HfstException_swigregister = _libhfst_dev.HfstException_swigregister
HfstException_swigregister(HfstException)

class HfstTransducerTypeMismatchException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducerTypeMismatchException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducerTypeMismatchException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_HfstTransducerTypeMismatchException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducerTypeMismatchException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.HfstTransducerTypeMismatchException_what(self)
HfstTransducerTypeMismatchException_swigregister = _libhfst_dev.HfstTransducerTypeMismatchException_swigregister
HfstTransducerTypeMismatchException_swigregister(HfstTransducerTypeMismatchException)

class ImplementationTypeNotAvailableException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImplementationTypeNotAvailableException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImplementationTypeNotAvailableException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4, type):
        this = _libhfst_dev.new_ImplementationTypeNotAvailableException(arg2, arg3, arg4, type)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_ImplementationTypeNotAvailableException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.ImplementationTypeNotAvailableException_what(self)

    def get_type(self):
        return _libhfst_dev.ImplementationTypeNotAvailableException_get_type(self)
ImplementationTypeNotAvailableException_swigregister = _libhfst_dev.ImplementationTypeNotAvailableException_swigregister
ImplementationTypeNotAvailableException_swigregister(ImplementationTypeNotAvailableException)

class FunctionNotImplementedException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FunctionNotImplementedException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FunctionNotImplementedException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_FunctionNotImplementedException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_FunctionNotImplementedException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.FunctionNotImplementedException_what(self)
FunctionNotImplementedException_swigregister = _libhfst_dev.FunctionNotImplementedException_swigregister
FunctionNotImplementedException_swigregister(FunctionNotImplementedException)

class StreamNotReadableException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamNotReadableException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamNotReadableException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StreamNotReadableException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StreamNotReadableException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StreamNotReadableException_what(self)
StreamNotReadableException_swigregister = _libhfst_dev.StreamNotReadableException_swigregister
StreamNotReadableException_swigregister(StreamNotReadableException)

class StreamCannotBeWrittenException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamCannotBeWrittenException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamCannotBeWrittenException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StreamCannotBeWrittenException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StreamCannotBeWrittenException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StreamCannotBeWrittenException_what(self)
StreamCannotBeWrittenException_swigregister = _libhfst_dev.StreamCannotBeWrittenException_swigregister
StreamCannotBeWrittenException_swigregister(StreamCannotBeWrittenException)

class StreamIsClosedException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamIsClosedException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamIsClosedException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StreamIsClosedException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StreamIsClosedException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StreamIsClosedException_what(self)
StreamIsClosedException_swigregister = _libhfst_dev.StreamIsClosedException_swigregister
StreamIsClosedException_swigregister(StreamIsClosedException)

class EndOfStreamException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndOfStreamException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EndOfStreamException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_EndOfStreamException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_EndOfStreamException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.EndOfStreamException_what(self)
EndOfStreamException_swigregister = _libhfst_dev.EndOfStreamException_swigregister
EndOfStreamException_swigregister(EndOfStreamException)

class TransducerIsCyclicException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerIsCyclicException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerIsCyclicException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerIsCyclicException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerIsCyclicException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerIsCyclicException_what(self)
TransducerIsCyclicException_swigregister = _libhfst_dev.TransducerIsCyclicException_swigregister
TransducerIsCyclicException_swigregister(TransducerIsCyclicException)

class NotTransducerStreamException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotTransducerStreamException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotTransducerStreamException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotTransducerStreamException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotTransducerStreamException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotTransducerStreamException_what(self)
NotTransducerStreamException_swigregister = _libhfst_dev.NotTransducerStreamException_swigregister
NotTransducerStreamException_swigregister(NotTransducerStreamException)

class NotValidAttFormatException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotValidAttFormatException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotValidAttFormatException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotValidAttFormatException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotValidAttFormatException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotValidAttFormatException_what(self)
NotValidAttFormatException_swigregister = _libhfst_dev.NotValidAttFormatException_swigregister
NotValidAttFormatException_swigregister(NotValidAttFormatException)

class NotValidPrologFormatException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotValidPrologFormatException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotValidPrologFormatException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotValidPrologFormatException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotValidPrologFormatException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotValidPrologFormatException_what(self)
NotValidPrologFormatException_swigregister = _libhfst_dev.NotValidPrologFormatException_swigregister
NotValidPrologFormatException_swigregister(NotValidPrologFormatException)

class NotValidLexcFormatException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NotValidLexcFormatException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NotValidLexcFormatException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_NotValidLexcFormatException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_NotValidLexcFormatException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.NotValidLexcFormatException_what(self)
NotValidLexcFormatException_swigregister = _libhfst_dev.NotValidLexcFormatException_swigregister
NotValidLexcFormatException_swigregister(NotValidLexcFormatException)

class StateIsNotFinalException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StateIsNotFinalException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StateIsNotFinalException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StateIsNotFinalException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StateIsNotFinalException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StateIsNotFinalException_what(self)
StateIsNotFinalException_swigregister = _libhfst_dev.StateIsNotFinalException_swigregister
StateIsNotFinalException_swigregister(StateIsNotFinalException)

class ContextTransducersAreNotAutomataException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContextTransducersAreNotAutomataException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContextTransducersAreNotAutomataException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_ContextTransducersAreNotAutomataException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_ContextTransducersAreNotAutomataException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.ContextTransducersAreNotAutomataException_what(self)
ContextTransducersAreNotAutomataException_swigregister = _libhfst_dev.ContextTransducersAreNotAutomataException_swigregister
ContextTransducersAreNotAutomataException_swigregister(ContextTransducersAreNotAutomataException)

class TransducersAreNotAutomataException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducersAreNotAutomataException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducersAreNotAutomataException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducersAreNotAutomataException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducersAreNotAutomataException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducersAreNotAutomataException_what(self)
TransducersAreNotAutomataException_swigregister = _libhfst_dev.TransducersAreNotAutomataException_swigregister
TransducersAreNotAutomataException_swigregister(TransducersAreNotAutomataException)

class StateIndexOutOfBoundsException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StateIndexOutOfBoundsException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StateIndexOutOfBoundsException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_StateIndexOutOfBoundsException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_StateIndexOutOfBoundsException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.StateIndexOutOfBoundsException_what(self)
StateIndexOutOfBoundsException_swigregister = _libhfst_dev.StateIndexOutOfBoundsException_swigregister
StateIndexOutOfBoundsException_swigregister(StateIndexOutOfBoundsException)

class TransducerHeaderException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerHeaderException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerHeaderException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerHeaderException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerHeaderException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerHeaderException_what(self)
TransducerHeaderException_swigregister = _libhfst_dev.TransducerHeaderException_swigregister
TransducerHeaderException_swigregister(TransducerHeaderException)

class MissingOpenFstInputSymbolTableException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MissingOpenFstInputSymbolTableException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MissingOpenFstInputSymbolTableException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_MissingOpenFstInputSymbolTableException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_MissingOpenFstInputSymbolTableException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.MissingOpenFstInputSymbolTableException_what(self)
MissingOpenFstInputSymbolTableException_swigregister = _libhfst_dev.MissingOpenFstInputSymbolTableException_swigregister
MissingOpenFstInputSymbolTableException_swigregister(MissingOpenFstInputSymbolTableException)

class TransducerTypeMismatchException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerTypeMismatchException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerTypeMismatchException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerTypeMismatchException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerTypeMismatchException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerTypeMismatchException_what(self)
TransducerTypeMismatchException_swigregister = _libhfst_dev.TransducerTypeMismatchException_swigregister
TransducerTypeMismatchException_swigregister(TransducerTypeMismatchException)

class EmptySetOfContextsException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptySetOfContextsException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptySetOfContextsException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_EmptySetOfContextsException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_EmptySetOfContextsException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.EmptySetOfContextsException_what(self)
EmptySetOfContextsException_swigregister = _libhfst_dev.EmptySetOfContextsException_swigregister
EmptySetOfContextsException_swigregister(EmptySetOfContextsException)

class SpecifiedTypeRequiredException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpecifiedTypeRequiredException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpecifiedTypeRequiredException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_SpecifiedTypeRequiredException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_SpecifiedTypeRequiredException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.SpecifiedTypeRequiredException_what(self)
SpecifiedTypeRequiredException_swigregister = _libhfst_dev.SpecifiedTypeRequiredException_swigregister
SpecifiedTypeRequiredException_swigregister(SpecifiedTypeRequiredException)

class HfstFatalException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstFatalException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HfstFatalException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_HfstFatalException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstFatalException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.HfstFatalException_what(self)
HfstFatalException_swigregister = _libhfst_dev.HfstFatalException_swigregister
HfstFatalException_swigregister(HfstFatalException)

class TransducerHasWrongTypeException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransducerHasWrongTypeException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransducerHasWrongTypeException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_TransducerHasWrongTypeException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TransducerHasWrongTypeException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.TransducerHasWrongTypeException_what(self)
TransducerHasWrongTypeException_swigregister = _libhfst_dev.TransducerHasWrongTypeException_swigregister
TransducerHasWrongTypeException_swigregister(TransducerHasWrongTypeException)

class IncorrectUtf8CodingException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IncorrectUtf8CodingException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IncorrectUtf8CodingException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_IncorrectUtf8CodingException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_IncorrectUtf8CodingException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.IncorrectUtf8CodingException_what(self)
IncorrectUtf8CodingException_swigregister = _libhfst_dev.IncorrectUtf8CodingException_swigregister
IncorrectUtf8CodingException_swigregister(IncorrectUtf8CodingException)

class EmptyStringException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptyStringException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EmptyStringException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_EmptyStringException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_EmptyStringException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.EmptyStringException_what(self)
EmptyStringException_swigregister = _libhfst_dev.EmptyStringException_swigregister
EmptyStringException_swigregister(EmptyStringException)

class SymbolNotFoundException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SymbolNotFoundException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SymbolNotFoundException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_SymbolNotFoundException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_SymbolNotFoundException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.SymbolNotFoundException_what(self)
SymbolNotFoundException_swigregister = _libhfst_dev.SymbolNotFoundException_swigregister
SymbolNotFoundException_swigregister(SymbolNotFoundException)

class MetadataException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MetadataException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MetadataException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_MetadataException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_MetadataException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.MetadataException_what(self)
MetadataException_swigregister = _libhfst_dev.MetadataException_swigregister
MetadataException_swigregister(MetadataException)

class FlagDiacriticsAreNotIdentitiesException(HfstException):
    __swig_setmethods__ = {}
    for _s in [HfstException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FlagDiacriticsAreNotIdentitiesException, name, value)
    __swig_getmethods__ = {}
    for _s in [HfstException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FlagDiacriticsAreNotIdentitiesException, name)
    __repr__ = _swig_repr

    def __init__(self, arg2, arg3, arg4):
        this = _libhfst_dev.new_FlagDiacriticsAreNotIdentitiesException(arg2, arg3, arg4)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_FlagDiacriticsAreNotIdentitiesException
    __del__ = lambda self: None

    def what(self):
        return _libhfst_dev.FlagDiacriticsAreNotIdentitiesException_what(self)
FlagDiacriticsAreNotIdentitiesException_swigregister = _libhfst_dev.FlagDiacriticsAreNotIdentitiesException_swigregister
FlagDiacriticsAreNotIdentitiesException_swigregister(FlagDiacriticsAreNotIdentitiesException)

class Location(_object):
    """

    Location of a pmatch result.

    Attributes:

        start:                  start index of match
        length:                 length of match
        input:                  the matched input string
        output:                 the matching output string
        tag:                    the tag of match
        weight:                 the weight of match
        input_parts:            tuple of indices in input_symbol_strings
        output_string:          tuple of indices in output_symbol_strings
        input_symbol_strings:   tuple of matched input symbol strings
        output_symbol_strings:  tuple of matching output symbol strings

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Location, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Location, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _libhfst_dev.Location_start_set
    __swig_getmethods__["start"] = _libhfst_dev.Location_start_get
    if _newclass:
        start = _swig_property(_libhfst_dev.Location_start_get, _libhfst_dev.Location_start_set)
    __swig_setmethods__["length"] = _libhfst_dev.Location_length_set
    __swig_getmethods__["length"] = _libhfst_dev.Location_length_get
    if _newclass:
        length = _swig_property(_libhfst_dev.Location_length_get, _libhfst_dev.Location_length_set)
    __swig_setmethods__["input"] = _libhfst_dev.Location_input_set
    __swig_getmethods__["input"] = _libhfst_dev.Location_input_get
    if _newclass:
        input = _swig_property(_libhfst_dev.Location_input_get, _libhfst_dev.Location_input_set)
    __swig_setmethods__["output"] = _libhfst_dev.Location_output_set
    __swig_getmethods__["output"] = _libhfst_dev.Location_output_get
    if _newclass:
        output = _swig_property(_libhfst_dev.Location_output_get, _libhfst_dev.Location_output_set)
    __swig_setmethods__["tag"] = _libhfst_dev.Location_tag_set
    __swig_getmethods__["tag"] = _libhfst_dev.Location_tag_get
    if _newclass:
        tag = _swig_property(_libhfst_dev.Location_tag_get, _libhfst_dev.Location_tag_set)
    __swig_setmethods__["weight"] = _libhfst_dev.Location_weight_set
    __swig_getmethods__["weight"] = _libhfst_dev.Location_weight_get
    if _newclass:
        weight = _swig_property(_libhfst_dev.Location_weight_get, _libhfst_dev.Location_weight_set)
    __swig_setmethods__["input_parts"] = _libhfst_dev.Location_input_parts_set
    __swig_getmethods__["input_parts"] = _libhfst_dev.Location_input_parts_get
    if _newclass:
        input_parts = _swig_property(_libhfst_dev.Location_input_parts_get, _libhfst_dev.Location_input_parts_set)
    __swig_setmethods__["output_parts"] = _libhfst_dev.Location_output_parts_set
    __swig_getmethods__["output_parts"] = _libhfst_dev.Location_output_parts_get
    if _newclass:
        output_parts = _swig_property(_libhfst_dev.Location_output_parts_get, _libhfst_dev.Location_output_parts_set)
    __swig_setmethods__["input_symbol_strings"] = _libhfst_dev.Location_input_symbol_strings_set
    __swig_getmethods__["input_symbol_strings"] = _libhfst_dev.Location_input_symbol_strings_get
    if _newclass:
        input_symbol_strings = _swig_property(_libhfst_dev.Location_input_symbol_strings_get, _libhfst_dev.Location_input_symbol_strings_set)
    __swig_setmethods__["output_symbol_strings"] = _libhfst_dev.Location_output_symbol_strings_set
    __swig_getmethods__["output_symbol_strings"] = _libhfst_dev.Location_output_symbol_strings_get
    if _newclass:
        output_symbol_strings = _swig_property(_libhfst_dev.Location_output_symbol_strings_get, _libhfst_dev.Location_output_symbol_strings_set)

    def __init__(self):
        this = _libhfst_dev.new_Location()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_Location
    __del__ = lambda self: None
Location_swigregister = _libhfst_dev.Location_swigregister
Location_swigregister(Location)


_libhfst_dev.SFST_TYPE_swigconstant(_libhfst_dev)
SFST_TYPE = _libhfst_dev.SFST_TYPE

_libhfst_dev.TROPICAL_OPENFST_TYPE_swigconstant(_libhfst_dev)
TROPICAL_OPENFST_TYPE = _libhfst_dev.TROPICAL_OPENFST_TYPE

_libhfst_dev.LOG_OPENFST_TYPE_swigconstant(_libhfst_dev)
LOG_OPENFST_TYPE = _libhfst_dev.LOG_OPENFST_TYPE

_libhfst_dev.FOMA_TYPE_swigconstant(_libhfst_dev)
FOMA_TYPE = _libhfst_dev.FOMA_TYPE

_libhfst_dev.XFSM_TYPE_swigconstant(_libhfst_dev)
XFSM_TYPE = _libhfst_dev.XFSM_TYPE

_libhfst_dev.HFST_OL_TYPE_swigconstant(_libhfst_dev)
HFST_OL_TYPE = _libhfst_dev.HFST_OL_TYPE

_libhfst_dev.HFST_OLW_TYPE_swigconstant(_libhfst_dev)
HFST_OLW_TYPE = _libhfst_dev.HFST_OLW_TYPE

_libhfst_dev.HFST2_TYPE_swigconstant(_libhfst_dev)
HFST2_TYPE = _libhfst_dev.HFST2_TYPE

_libhfst_dev.UNSPECIFIED_TYPE_swigconstant(_libhfst_dev)
UNSPECIFIED_TYPE = _libhfst_dev.UNSPECIFIED_TYPE

_libhfst_dev.ERROR_TYPE_swigconstant(_libhfst_dev)
ERROR_TYPE = _libhfst_dev.ERROR_TYPE

_libhfst_dev.REPL_UP_swigconstant(_libhfst_dev)
REPL_UP = _libhfst_dev.REPL_UP

_libhfst_dev.REPL_DOWN_swigconstant(_libhfst_dev)
REPL_DOWN = _libhfst_dev.REPL_DOWN

_libhfst_dev.REPL_RIGHT_swigconstant(_libhfst_dev)
REPL_RIGHT = _libhfst_dev.REPL_RIGHT

_libhfst_dev.REPL_LEFT_swigconstant(_libhfst_dev)
REPL_LEFT = _libhfst_dev.REPL_LEFT
class Rule(_object):
    """

    todo

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rule, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rule, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_Rule(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def get_mapping(self):
        return _libhfst_dev.Rule_get_mapping(self)

    def get_context(self):
        return _libhfst_dev.Rule_get_context(self)

    def get_replType(self):
        return _libhfst_dev.Rule_get_replType(self)

    def encodeFlags(self):
        return _libhfst_dev.Rule_encodeFlags(self)
    __swig_destroy__ = _libhfst_dev.delete_Rule
    __del__ = lambda self: None
Rule_swigregister = _libhfst_dev.Rule_swigregister
Rule_swigregister(Rule)


def replace(*args):
    """

    todo

    """
    return _libhfst_dev.replace(*args)

def replace_left(*args):
    """

    todo

    """
    return _libhfst_dev.replace_left(*args)

def replace_leftmost_longest_match(*args):
    """

    todo

    """
    return _libhfst_dev.replace_leftmost_longest_match(*args)

def replace_rightmost_longest_match(*args):
    """

    todo

    """
    return _libhfst_dev.replace_rightmost_longest_match(*args)

def replace_leftmost_shortest_match(*args):
    """

    todo

    """
    return _libhfst_dev.replace_leftmost_shortest_match(*args)

def replace_rightmost_shortest_match(*args):
    """

    todo

    """
    return _libhfst_dev.replace_rightmost_shortest_match(*args)

def replace_epenthesis(*args):
    """

    todo

    """
    return _libhfst_dev.replace_epenthesis(*args)

def restriction(automata, context):
    """

    todo

    """
    return _libhfst_dev.restriction(automata, context)

def before(left, right):
    """

    todo

    """
    return _libhfst_dev.before(left, right)

def after(left, right):
    """

    todo

    """
    return _libhfst_dev.after(left, right)

def is_diacritic(symbol):
    """


    Whether symbol *symbol* is a flag diacritic.

    Flag diacritics are of the form

         @[PNDRCU][.][A-Z]+([.][A-Z]+)?@

    """
    return _libhfst_dev.is_diacritic(symbol)

def is_epsilon(symbol):
    """


    Whether symbol *symbol* is the epsilon, i.e. "@_EPSILON_SYMBOL_@".


    """
    return _libhfst_dev.is_epsilon(symbol)

def compile_pmatch_expression(pmatch):
    """


    Compile a pmatch expression into a tuple of transducers.

    Parameters
    ----------
    * `expr` :
        A string defining how pmatch is done.

    See also: hfst.compile_pmatch_file

    """
    return _libhfst_dev.compile_pmatch_expression(pmatch)

def _is_string(s):
    if isinstance(s, str):
       return True
    else:
       return False
def _is_string_pair(sp):
    if not isinstance(sp, tuple):
       return False
    if len(sp) != 2:
       return False
    if not _is_string(sp[0]):
       return False
    if not _is_string(sp[1]):
       return False
    return True
def _is_string_vector(sv):
    if not isinstance(sv, tuple):
       return False
    for s in sv:
       if not _is_string(s):
          return False
    return True
def _is_string_pair_vector(spv):
    if not isinstance(spv, tuple):
       return False
    for sp in spv:
       if not _is_string_pair(sp):
          return False
    return True

def _two_level_paths_to_dict(tlps):
    retval = {}
    for tlp in tlps:
       input = ""
       output = ""
       for sp in tlp[1]:
          input += sp[0]
          output += sp[1]
       if input in retval:
          retval[input].append((output, tlp[0]))
       else:
          retval[input] = [(output, tlp[0])]
    return retval

def _one_level_paths_to_tuple(olps, show_special_symbols):
    retval = []
    for olp in olps:
       path = ""
       for s in olp[1]:
          if not show_special_symbols and (is_diacritic(s) or is_epsilon(s)):
             pass
          else:
             path += s
       retval.append((path, olp[0]))
    return tuple(retval)

class HfstTransducer(_object):
    """


    A synchronous finite-state transducer.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransducer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransducer, name)
    __repr__ = _swig_repr

    def set_name(self, name):
        """


        Rename the transducer *name*.

        Parameters
        ----------
        * `name` :
            The name of the transducer.

        See also: get_name

        """
        return _libhfst_dev.HfstTransducer_set_name(self, name)


    def get_name(self):
        """


        Get the name of the transducer.

        See also: set_name

        """
        return _libhfst_dev.HfstTransducer_get_name(self)


    def get_type(self):
        """


        The implementation type of the transducer.

        Returns
        -------
        hfst.ImplementationType

        """
        return _libhfst_dev.HfstTransducer_get_type(self)


    def set_property(self, property, value):
        """


        Set arbitrary string property *property* to *value*.

        Parameters
        ----------
        * `property` :
            A string naming the property.
        * `value` :
            A string expressing the value of *property*.

        set_property('name', 'name of the transducer') equals set_name('name of the
        transducer').

        note: While this function is capable of creating endless amounts of arbitrary
            metadata, it is suggested that property names are drawn from central
            repository, or prefixed with "x-". A property that does not follow this
            convention may affect the behavior of transducer in future releases.

        """
        return _libhfst_dev.HfstTransducer_set_property(self, property, value)


    def get_property(self, property):
        """


        Get arbitrary string propert *property*.

        Parameters
        ----------
        * `property` :
            The name of the property whose value is returned. get_property('name') works
            like get_name().

        """
        return _libhfst_dev.HfstTransducer_get_property(self, property)


    def get_properties(self):
        """


        Get all properties from the transducer.

        Returns
        -------
        A dictionary whose keys are properties and whose values are the values of those
        properties.

        """
        return _libhfst_dev.HfstTransducer_get_properties(self)


    def compare(self, arg2, harmonize=True):
        """


        Whether this transducer and *another* are equivalent.

        Parameters
        ----------
        * `another` :
            The compared transducer.

        pre: *self* and *another* must have the same implementation type.

        Two transducers are equivalent iff they accept the same input/output string
        pairs with the same weights and the same alignments.

        note: For weighted transducers, the function often returns false negatives due
            to weight precision issues.

        """
        return _libhfst_dev.HfstTransducer_compare(self, arg2, harmonize)


    def number_of_states(self):
        """


        The number of states in the transducer.

        """
        return _libhfst_dev.HfstTransducer_number_of_states(self)


    def number_of_arcs(self):
        """


        The number of transitions in the transducer.

        """
        return _libhfst_dev.HfstTransducer_number_of_arcs(self)


    def get_alphabet(self):
        """


        Get the alphabet of the transducer.

        The alphabet is defined as the set of symbols known to the transducer.

        Returns
        -------
        A tuple of strings.

        """
        return _libhfst_dev.HfstTransducer_get_alphabet(self)


    def is_cyclic(self):
        """


        Whether the transducer is cyclic.

        """
        return _libhfst_dev.HfstTransducer_is_cyclic(self)


    def is_automaton(self):
        """


        Whether each transition in the transducer has equivalent input and output
        symbols.

        note: Transition with hfst.UNKNOWN on both sides IS NOT a transition with
            equivalent input and output symbols.

        note: Transition with hfst.IDENTITY on both sides IS a transition with
            equivalent input and output symbols.

        """
        return _libhfst_dev.HfstTransducer_is_automaton(self)


    def is_infinitely_ambiguous(self):
        """


        Whether the transducer is infinitely ambiguous.

        A transducer is infinitely ambiguous if there exists an input that will yield
        infinitely many results, i.e. there are input epsilon loops that are traversed
        with that input.

        """
        return _libhfst_dev.HfstTransducer_is_infinitely_ambiguous(self)


    def is_lookup_infinitely_ambiguous(self, arg2):
        """


        Whether lookup of path *input* will have infinite results.

        Currently, this function will return whether the transducer is infinitely
        ambiguous on any lookup path found in the transducer, i.e. the argument *input*
        is ignored.

        Todo
        Do not ignore the argument *input*

        """
        return _libhfst_dev.HfstTransducer_is_lookup_infinitely_ambiguous(self, arg2)


    def has_flag_diacritics(self):
        """


        Whether the transducer has flag diacritics in its transitions.

        """
        return _libhfst_dev.HfstTransducer_has_flag_diacritics(self)


    def insert_to_alphabet(self, arg2):
        """


        Explicitly insert *symbol* to the alphabet of the transducer.

        Parameters
        ----------
        * `symbol` :
            The symbol (string) to be inserted.

        note: Usually this function is not needed since new symbols are added to the
            alphabet by default.

        """
        return _libhfst_dev.HfstTransducer_insert_to_alphabet(self, arg2)


    def remove_from_alphabet(self, arg2):
        """


        Remove *symbol* from the alphabet of the transducer.

        Parameters
        ----------
        * `symbol` :
            The symbol (string) to be removed.

        pre: *symbol* does not occur in any transition of the transducer.

        note: Use with care, removing a symbol that occurs in a transition of the
            transducer can have unexpected results.

        """
        return _libhfst_dev.HfstTransducer_remove_from_alphabet(self, arg2)


    def is_implementation_type_available(type):
        """


        Whether HFST is linked to the transducer library needed by implementation type
        *type*.

        """
        return _libhfst_dev.HfstTransducer_is_implementation_type_available(type)

    if _newclass:
        is_implementation_type_available = staticmethod(is_implementation_type_available)
    __swig_getmethods__["is_implementation_type_available"] = lambda x: is_implementation_type_available

    def longest_path_size(self, obey_flags=True):
        """


        Get length of longest path of the transducer.

        """
        return _libhfst_dev.HfstTransducer_longest_path_size(self, obey_flags)


    def concatenate(self, tr, harmonize=True):
        """


        Concatenate this transducer with *another*.

        """
        return _libhfst_dev.HfstTransducer_concatenate(self, tr, harmonize)


    def disjunct(self, tr, harmonize=True):
        """


        Disjunct this transducer with *another*.

        """
        return _libhfst_dev.HfstTransducer_disjunct(self, tr, harmonize)


    def subtract(self, tr, harmonize=True):
        """


        Subtract transducer *another* from this transducer.

        """
        return _libhfst_dev.HfstTransducer_subtract(self, tr, harmonize)


    def intersect(self, tr, harmonize=True):
        """


        Intersect this transducer with *another*.

        """
        return _libhfst_dev.HfstTransducer_intersect(self, tr, harmonize)


    def compose(self, tr, harmonize=True):
        """


        Compose this transducer with *another*.

        Parameters
        ----------
        * `another` :
            The second argument in the composition. Not modified.

        """
        return _libhfst_dev.HfstTransducer_compose(self, tr, harmonize)


    def compose_intersect(self, v, invert=False, harmonize=True):
        """


        Compose this transducer with the intersection of transducers in *v*.

        If *invert* is true, then compose the intersection of the transducers in *v*
        with this transducer.

        The algorithm used by this function is faster than intersecting all transducers
        one by one and then composing this transducer with the intersection.

        pre: The transducers in *v* are deterministic and epsilon-free.

        Parameters
        ----------
        * `v` :
            A tuple of transducers.
        * `invert` :
            Whether the intersection of the transducers in *v* is composed with this
            transducer.

        """
        return _libhfst_dev.HfstTransducer_compose_intersect(self, v, invert, harmonize)


    def priority_union(self, another):
        """


        Make priority union of this transducer with *another*.

        For the operation t1.priority_union(t2), the result is a union of t1 and t2,
        except that whenever t1 and t2 have the same string on left side, the path in t2
        overrides the path in t1.

        Example

             Transducer 1 (t1):
             a : a
             b : b

             Transducer 2 (t2):
             b : B
             c : C

             Result ( t1.priority_union(t2) ):
             a : a
             b : B
             c : C For more information, read fsmbook.

        """
        return _libhfst_dev.HfstTransducer_priority_union(self, another)


    def lenient_composition(self, another, harmonize=True):
        """


        Perform a lenient composition on this transducer and *another*.

        TODO: explain more.

        """
        return _libhfst_dev.HfstTransducer_lenient_composition(self, another, harmonize)


    def cross_product(self, another, harmonize=True):
        """


        Make cross product of this transducer with *another*.

        It pairs every string of this with every string of *another*. If strings are not
        the same length, epsilon padding will be added in the end of the shorter string.

        pre: Both transducers must be automata, i.e. map strings onto themselves.

        """
        return _libhfst_dev.HfstTransducer_cross_product(self, another, harmonize)


    def shuffle(self, another, harmonize=True):
        """


        Shuffle this transducer with transducer *another*.

        If transducer A accepts string 'foo' and transducer B string 'bar', the
        transducer that results from shuffling A and B accepts all strings
        [(f|b)(o|a)(o|r)].

        pre: Both transducers must be automata, i.e. map strings onto themselves.

        """
        return _libhfst_dev.HfstTransducer_shuffle(self, another, harmonize)


    def remove_epsilons(self):
        """


        Remove all *epsilon:epsilon* transitions from the transducer so that the
        resulting transducer is equivalent to the original one.

        """
        return _libhfst_dev.HfstTransducer_remove_epsilons(self)


    def determinize(self):
        """


        Determinize the transducer.

        Determinizing a transducer yields an equivalent transducer that has no state
        with two or more transitions whose input:output symbol pairs are the same.

        """
        return _libhfst_dev.HfstTransducer_determinize(self)


    def minimize(self):
        """


        Minimize the transducer.

        Minimizing a transducer yields an equivalent transducer with the smallest number
        of states.

        Bug
        OpenFst's minimization algorithm seems to add epsilon transitions to weighted
        transducers?

        """
        return _libhfst_dev.HfstTransducer_minimize(self)


    def prune(self):
        """


        Make transducer coaccessible.

        A transducer is coaccessible iff there is a path from every state to a final
        state.

        """
        return _libhfst_dev.HfstTransducer_prune(self)


    def eliminate_flags(self):
        """


        Eliminate flag diacritics listed in *symbols* from the transducer.

        Parameters
        ----------
        * `symbols` :
            The flags to be eliminated. TODO: explain more.

        An equivalent transducer with no flags listed in *symbols*.

        """
        return _libhfst_dev.HfstTransducer_eliminate_flags(self)


    def eliminate_flag(self, f):
        """


        Eliminate flag diacritic *symbol* from the transducer.

        Parameters
        ----------
        * `symbol` :
            The flag to be eliminated. TODO: explain more.

        An equivalent transducer with no flags *symbol*.

        """
        return _libhfst_dev.HfstTransducer_eliminate_flag(self, f)


    def n_best(self, n):
        """


        Extract *n* best paths of the transducer.

        In the case of a weighted transducer (hfst.ImplementationType.TROPICAL_OPENFST_TYPE or
        hfst.ImplementationType.LOG_OPENFST_TYPE), best paths are defined as paths with the lowest
        weight. In the case of an unweighted transducer (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), the function returns random paths.

        This function is not implemented for hfst.ImplementationType.FOMA_TYPE or
        hfst.ImplementationType.SFST_TYPE. If this function is called by an HfstTransducer of type
        hfst.ImplementationType.FOMA_TYPE or hfst.ImplementationType.SFST_TYPE, it is converted to
        hfst.ImplementationType.TROPICAL_OPENFST_TYPE, paths are extracted and it is converted back
        to hfst.ImplementationType.FOMA_TYPE or hfst.ImplementationType.SFST_TYPE. If HFST is not linked to
        OpenFst library, an hfst.exceptions.ImplementationTypeNotAvailableException is
        thrown.

        """
        return _libhfst_dev.HfstTransducer_n_best(self, n)


    def convert(self, impl):
        """


        Convert the transducer into an equivalent transducer in format *type*.

        If a weighted transducer is converted into an unweighted one, all weights are
        lost. In the reverse case, all weights are initialized to the semiring's one.

        A transducer of type hfst.ImplementationType.SFST_TYPE, hfst.ImplementationType.TROPICAL_OPENFST_TYPE,
        hfst.ImplementationType.LOG_OPENFST_TYPE or hfst.ImplementationType.FOMA_TYPE can be converted into an
        hfst.ImplementationType.HFST_OL_TYPE or hfst.ImplementationType.HFST_OLW_TYPE transducer, but an
        hfst.ImplementationType.HFST_OL_TYPE or hfst.ImplementationType.HFST_OLW_TYPE transducer cannot be
        converted to any other type.

        note: For conversion between HfstIterableTransducer and HfstTransducer, see
            hfst.HfstTransducer.__init__ and hfst.HfstIterableTransducer.__init__

        """
        return _libhfst_dev.HfstTransducer_convert(self, impl)


    def repeat_star(self):
        """


        A concatenation of N transducers where N is any number from zero to infinity.

        """
        return _libhfst_dev.HfstTransducer_repeat_star(self)


    def repeat_plus(self):
        """


        A concatenation of N transducers where N is any number from one to infinity.

        """
        return _libhfst_dev.HfstTransducer_repeat_plus(self)


    def repeat_n(self, n):
        """


        A concatenation of *n* transducers.

        """
        return _libhfst_dev.HfstTransducer_repeat_n(self, n)


    def repeat_n_to_k(self, n, k):
        """


        A concatenation of N transducers where N is any number from *n* to *k*,
        inclusive.

        """
        return _libhfst_dev.HfstTransducer_repeat_n_to_k(self, n, k)


    def repeat_n_minus(self, n):
        """


        A concatenation of N transducers where N is any number from zero to *n*,
        inclusive.

        """
        return _libhfst_dev.HfstTransducer_repeat_n_minus(self, n)


    def repeat_n_plus(self, n):
        """


        A concatenation of N transducers where N is any number from *n* to infinity,
        inclusive.

        """
        return _libhfst_dev.HfstTransducer_repeat_n_plus(self, n)


    def invert(self):
        """


        Swap the input and output symbols of each transition in the transducer.

        """
        return _libhfst_dev.HfstTransducer_invert(self)


    def reverse(self):
        """


        Reverse the transducer.

        A reverted transducer accepts the string 'n(0) n(1) ... n(N)' iff the original
        transducer accepts the string 'n(N) n(N-1) ... n(0)'

        """
        return _libhfst_dev.HfstTransducer_reverse(self)


    def input_project(self):
        """


        Extract the input language of the transducer.

        All transition symbol pairs *isymbol:osymbol* are changed to *isymbol:isymbol*.

        """
        return _libhfst_dev.HfstTransducer_input_project(self)


    def output_project(self):
        """


        Extract the output language of the transducer.

        All transition symbol pairs *isymbol:osymbol* are changed to *osymbol:osymbol*.

        """
        return _libhfst_dev.HfstTransducer_output_project(self)


    def optionalize(self):
        """


        Disjunct the transducer with an epsilon transducer.

        """
        return _libhfst_dev.HfstTransducer_optionalize(self)


    def insert_freely(self, *args):
        """


        Freely insert a transition or a transducer into the transducer.

        Parameters
        ----------
        * `ins` :
            The transition or transducer to be inserted.

        If *ins* is a transition, i.e. a 2-tuple of strings: A transition is added to
        each state in this transducer. The transition leads from that state to itself
        with input and output symbols defined by *ins*. The weight of the transition is
        zero.

        If *ins* is an hfst.HfstTransducer: A copy of *ins* is attached with epsilon
        transitions to each state of this transducer. After the operation, for each
        state S in this transducer, there is an epsilon transition that leads from state
        S to the initial state of *ins*, and for each final state of *ins*, there is an
        epsilon transition that leads from that final state to state S in this
        transducer. The weights of the final states in *ins* are copied to the epsilon
        transitions leading to state S.

        """
        return _libhfst_dev.HfstTransducer_insert_freely(self, *args)


    def _substitute_symbol(self, old_symbol, new_symbol, input_side=True, output_side=True):
        return _libhfst_dev.HfstTransducer__substitute_symbol(self, old_symbol, new_symbol, input_side, output_side)

    def _substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair)

    def _substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set)

    def _substitute_symbol_pair_with_transducer(self, symbol_pair, transducer, harmonize=True):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pair_with_transducer(self, symbol_pair, transducer, harmonize)

    def _substitute_symbols(self, substitutions):
        return _libhfst_dev.HfstTransducer__substitute_symbols(self, substitutions)

    def _substitute_symbol_pairs(self, substitutions):
        return _libhfst_dev.HfstTransducer__substitute_symbol_pairs(self, substitutions)

    def set_final_weights(self, weight, increment=False):
        """


        Set the weights of all final states to *weight*.

        If the HfstTransducer is of unweighted type (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), nothing is done.

        """
        return _libhfst_dev.HfstTransducer_set_final_weights(self, weight, increment)


    def push_weights_to_start(self):
        """


        Push weights towards initial state.

        If the HfstTransducer is of unweighted type (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), nothing is done.

        An example:

             >>> import hfst
             >>> tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
             >>> tr.push_weights_to_start()
             >>> print(tr)
             0       1       a       a       2.000000
             1       2       a       b       0.000000
             2       3       b       b       0.000000
             2       0.000000
             3       0.000000

        See also: hfst.HfstTransducer.push_weights_to_end

        """
        return _libhfst_dev.HfstTransducer_push_weights_to_start(self)


    def push_weights_to_end(self):
        """


        Push weights towards final state(s).

        If the HfstTransducer is of unweighted type (hfst.ImplementationType.SFST_TYPE or
        hfst.ImplementationType.FOMA_TYPE), nothing is done.

        An example:

             >>> import hfst
             >>> tr = hfst.regex('[a::1 a:b::0.3 (b::0)]::0.7;')
             >>> tr.push_weights_to_end()
             >>> print(tr)
             0       1       a       a       0.000000
             1       2       a       b       0.000000
             2       3       b       b       0.000000
             2       2.000000
             3       2.000000

        See also: hfst.HfstTransducer.push_weights_to_start

        """
        return _libhfst_dev.HfstTransducer_push_weights_to_end(self)


    def minus(self, t, harmonize=True):
        """


        Alias for subtract.

        See also: hfst.HfstTransducer.subtract

        """
        return _libhfst_dev.HfstTransducer_minus(self, t, harmonize)


    def conjunct(self, t, harmonize=True):
        """


        Alias for intersect.

        See also: hfst.HfstTransducer.intersect

        """
        return _libhfst_dev.HfstTransducer_conjunct(self, t, harmonize)


    def lookup_optimize(self):
        """


        Optimize the transducer for lookup.

        This effectively converts the transducer into hfst.ImplementationType.HFST_OL_TYPE.

        """
        return _libhfst_dev.HfstTransducer_lookup_optimize(self)


    def remove_optimization(self):
        """


        Remove lookup optimization.

        This effectively converts transducer (back) into default fst type.

        """
        return _libhfst_dev.HfstTransducer_remove_optimization(self)


    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransducer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstTransducer
    __del__ = lambda self: None

    def __str__(self):
        """


        An AT&T representation of the transducer.

        Defined for print command. An example:

             >>> print(hfst.regex('[foo:bar::2]+'))
             0       1       foo     bar     2.000000
             1       1       foo     bar     2.000000
             1       0.000000 Todo
        Works only for small transducers.

        """
        return _libhfst_dev.HfstTransducer___str__(self)


    def write(self, os):
        """


        Write the transducer in binary format to *ostr*.

        Parameters
        ----------
        * `ostr` :
            A hfst.HfstOutputStream where the transducer is written.

        """
        return _libhfst_dev.HfstTransducer_write(self, os)


    def _get_dot_graph(self):
        return _libhfst_dev.HfstTransducer__get_dot_graph(self)

    def _extract_shortest_paths(self):
        return _libhfst_dev.HfstTransducer__extract_shortest_paths(self)

    def _extract_longest_paths(self, obey_flags):
        return _libhfst_dev.HfstTransducer__extract_longest_paths(self, obey_flags)

    def _extract_paths(self, max_num=-1, cycles=-1):
        return _libhfst_dev.HfstTransducer__extract_paths(self, max_num, cycles)

    def _extract_paths_fd(self, max_num=-1, cycles=-1, filter_fd=True):
        return _libhfst_dev.HfstTransducer__extract_paths_fd(self, max_num, cycles, filter_fd)

    def _extract_random_paths(self, max_num):
        return _libhfst_dev.HfstTransducer__extract_random_paths(self, max_num)

    def _extract_random_paths_fd(self, max_num, filter_fd):
        return _libhfst_dev.HfstTransducer__extract_random_paths_fd(self, max_num, filter_fd)

    def _lookup_vector(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_vector(self, s, limit, time_cutoff)

    def _lookup_fd_vector(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_fd_vector(self, s, limit, time_cutoff)

    def _lookup_fd_string(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_fd_string(self, s, limit, time_cutoff)

    def _lookup_string(self, s, limit=-1, time_cutoff=0.0):
        return _libhfst_dev.HfstTransducer__lookup_string(self, s, limit, time_cutoff)


    def view(self):
        """
        Return a dot Digraph representation of the transducer as a graphviz.Source object.

        Inside a Jupyter notebook, the return value will be automatically
        rendered to an svg image and displayed on the console.

        Examples:

        tr = hfst_dev.regex('foo:bar')
        tr.view()

        If inside an intended block, 'display' must be called:

        if (Foo):
            tr = hfst_dev.regex('foo:bar')
            display(tr.view())

        Note: The function requires graphviz package.
        """
        from graphviz import Source
        graph = self._get_dot_graph()
        s = Source(graph)
        return s

    def copy(self):
        """
        Return a deep copy of the transducer.
        """
        return HfstTransducer(self)

    def write_to_file(self, filename_):
        """
        Write the transducer in binary format to file *filename_*.
        """
        ostr = HfstOutputStream(filename=filename_, type=self.get_type(), hfst_format=True)
        ostr.write(self)
        ostr.close()

    def read_from_file(filename_):
        """
        Read a binary transducer from file *filename_*.
        """
        istr = HfstInputStream(filename_)
        tr = istr.read()
        istr.close()
        return tr

    def read_all_from_file(filename_):
        """
        Read all binary transducers from file *filename_*.
        """
        istr = HfstInputStream(filename_)
        tr = istr.read_all()
        istr.close()
        return tr

    def write_prolog(self, f, write_weights=True):
        """
        Write the transducer in prolog format with name *name* to file *f*,
        *write_weights* defined whether weights are written.

        Parameters
        ----------
        * `f` :
            A python file where the transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstIterableTransducer(self)
        fsm.name = self.get_name()
        prologstr = fsm.get_prolog_string(write_weights)
        f.write(prologstr)

    def write_xfst(self, f, write_weights=True):
        """
        Write the transducer in xfst format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstIterableTransducer(self)
        fsm.name = self.get_name()
        xfststr = fsm.get_xfst_string(write_weights)
        f.write(xfst)

    def write_att(self, f, write_weights=True):
        """
        Write the transducer in AT&T format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        fsm = HfstIterableTransducer(self)
        fsm.name = self.get_name()
        attstr = fsm.get_att_string(write_weights)
        f.write(attstr)

    def lookup(self, input, **kwargs):
        """
        Lookup string *input*.

        Parameters
        ----------
        * `input` :
            The input. A string or a pre-tokenized tuple of symbols (i.e. a tuple of strings).
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True,
            max_number=-1, time_cutoff=0.0, output='tuple'
        * `obey_flags` :
            Whether flag diacritics are obeyed. Always True for HFST_OL(W)_TYPE transducers.
        * `show_flags` :
            Whether flag diacritics are shown when output is 'text' or 'tuple'. Defaults to False.
        * `max_number` :
            Maximum number of results returned, defaults to -1, i.e. infinity.
        * `time_cutoff` :
            How long the function can search for results before returning, expressed in
            seconds. Defaults to 0.0, i.e. infinitely. Always 0.0 for transducers that are
            not of HFST_OL(W)_TYPE.
        * `output` :
            Possible values are 'tuple', 'text' and 'raw', 'tuple' being the default.

        Note: This function has an efficient implementation only for optimized lookup format
        (hfst.ImplementationType.HFST_OL_TYPE or hfst.ImplementationType.HFST_OLW_TYPE). Other formats perform the
        lookup via composition. Consider converting the transducer to optimized lookup format
        or to a HfstIterableTransducer. Conversion to HFST_OL(W)_TYPE might take a while but the
        lookup is fast. Conversion to HfstIterableTransducer is quick but lookup is slower.
        """
        obey_flags=True
        show_flags=False
        max_number=-1
        time_cutoff=0.0
        output='tuple' # 'tuple' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags':
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            if k == 'show_flags':
               if v == False:
                  pass
               elif v == True:
                  show_flags=True
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output='text'
               elif v == 'raw':
                  output='raw'
               elif v == 'tuple':
                  output='tuple'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'tuple' (default), 'text', 'raw'.")
            elif k == 'max_number' :
               max_number=v
            elif k == 'time_cutoff' :
               time_cutoff=v
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval=0

        if isinstance(input, tuple):
           if obey_flags:
              retval=self._lookup_fd_vector(input, max_number, time_cutoff)
           else:
              retval=self._lookup_vector(input, max_number, time_cutoff)
        elif isinstance(input, str):
           if obey_flags:
              retval=self._lookup_fd_string(input, max_number, time_cutoff)
           else:
              retval=self._lookup_string(input, max_number, time_cutoff)
        else:
           try:
              if obey_flags:
                  retval=self._lookup_fd_string(str(input), max_number, time_cutoff)
              else:
                  retval=self._lookup_string(str(input), max_number, time_cutoff)
           except:
              raise RuntimeError('Input argument must be string or tuple.')
        if output == 'text':
           return _one_level_paths_to_string(retval, show_flags)
        elif output == 'tuple':
           return _one_level_paths_to_tuple(retval, show_flags)
        else:
           return retval

    def extract_longest_paths(self, **kwargs):
        """
        Extract longest paths of the transducer.

        Parameters
        ----------
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True,
            output='dict'
        * `obey_flags` :
            Whether flag diacritics are obeyed. The default is True.
        * `output` :
            Possible values are 'dict', 'text' and 'raw', 'dict' being the default.

        """
        obey_flags=True
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags':
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._extract_longest_paths(obey_flags)

        if output == 'text':
           return _two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def extract_shortest_paths(self, **kwargs):
        """
        Extract shortest paths of the transducer.

        Parameters
        ----------
        * `kwargs` :
            Possible parameters and their default values are: obey_flags=True.
        * `output` :
            Possible values are 'dict', 'text' and 'raw', 'dict' being the default.

        """
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._extract_shortest_paths()

        if output == 'text':
           return _two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def extract_paths(self, **kwargs):
        """

        Extract paths that are recognized by the transducer.

        Parameters
        ----------
        * `kwargs` :
            Arguments recognized are filter_flags, max_cycles, max_number, obey_flags,
            output, random.
        * `filter_flags` :
            Whether flags diacritics are filtered out from the result (default True).
        * `max_cycles` :
            Indicates how many times a cycle will be followed, with negative numbers
            indicating unlimited (default -1 i.e. unlimited).
        * `max_number` :
            The total number of resulting strings is capped at this value, with 0 or
            negative indicating unlimited (default -1 i.e. unlimited).
        * `obey_flags` :
            Whether flag diacritics are validated (default True).
        * `output` :
            Output format. Values recognized: 'text' (as a string, separated by
            newlines), 'raw' (a dictionary that maps each input string into a list of
            tuples of an output string and a weight), 'dict' (a dictionary that maps
            each input string into a tuple of tuples of an output string and a weight,
            the default).
        * `random` :
            Whether result strings are fetched randomly (default False).

        Returns
        -------
        The extracted strings. *output* controls how they are represented.

        pre: The transducer must be acyclic, if both *max_number* and *max_cycles* have
        unlimited values. Else a hfst.exceptions.TransducerIsCyclicException will be
        thrown.

        An example:

        >>> tr = hfst.regex('a:b+ (a:c+)')
        >>> print(tr)
        0       1       a       b       0.000000
        1       1       a       b       0.000000
        1       2       a       c       0.000000
        1       0.000000
        2       2       a       c       0.000000
        2       0.000000

        >>> print(tr.extract_paths(max_cycles=1, output='text'))
        a:b     0
        aa:bb   0
        aaa:bbc 0
        aaaa:bbcc       0
        aa:bc   0
        aaa:bcc 0

        >>> print(tr.extract_paths(max_number=4, output='text'))
        a:b     0
        aa:bc   0
        aaa:bcc 0
        aaaa:bccc       0

        >>> print(tr.extract_paths(max_cycles=1, max_number=4, output='text'))
        a:b     0
        aa:bb   0
        aa:bc   0
        aaa:bcc 0

        Exceptions
        ----------
        * `TransducerIsCyclicException` :

        See also: hfst.HfstTransducer.n_best
        """
        obey_flags=True
        filter_flags=True
        max_cycles=-1
        max_number=-1
        random=False
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'obey_flags' :
               if v == True:
                  pass
               elif v == False:
                  obey_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'filter_flags' :
               if v == True:
                  pass
               elif v == False:
                  filter_flags=False
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'max_cycles' :
               max_cycles=v
            elif k == 'max_number' :
               max_number=v
            elif k == 'random' :
               if v == False:
                  pass
               elif v == True:
                  random=True
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are True and False.")
            elif k == 'output':
               if v == 'text':
                  output = 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval=0

        if obey_flags :
           if random :
              retval=self._extract_random_paths_fd(max_number, filter_flags)
           else :
              retval=self._extract_paths_fd(max_number, max_cycles)
        else :
           if random :
              retval=self._extract_random_paths(max_number)
           else :
              retval=self._extract_paths(max_number, max_cycles)

        if output == 'text':
           return _two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def substitute(self, s, S=None, **kwargs):
        """
        Substitute symbols or transitions in the transducer.

        Parameters
        ----------
        * `s` :
            The symbol or transition to be substituted. Can also be a dictionary of
            substitutions, if S == None.
        * `S` :
            The symbol, transition, a tuple of transitions or a transducer
            (hfst.HfstTransducer) that substitutes *s*.
        * `kwargs` :
            Arguments recognized are 'input' and 'output', their values can be False or
            True, True being the default. These arguments are valid only if *s* and *S*
            are strings, else they are ignored.
        * `input` :
            Whether substitution is performed on input side, defaults to True. Valid
            only if *s* and *S* are strings.
        * `output` :
            Whether substitution is performed on output side, defaults to True. Valid
            only if *s* and \\ S are strings.

        For more information, see hfst.HfstIterableTransducer.substitute. The function
        works similarly, with the exception of argument *S*, which must be
        hfst.HfstTransducer instead of hfst.HfstIterableTransducer.

        See also: hfst.HfstIterableTransducer.substitute
        """
        if S == None:
           if not isinstance(s, dict):
              raise RuntimeError('Sole input argument must be a dictionary.')

           subst_type=""

           for k, v in s.items():
               if _is_string(k):
                  if subst_type == "":
                     subst_type="string"
                  elif subst_type == "string pair":
                     raise RuntimeError('')
                  if not _is_string(v):
                     raise RuntimeError('')
               elif _is_string_pair(k):
                  if subst_type == "":
                     subst_type="string pair"
                  elif subst_type == "string":
                     raise RuntimeError('')
                  if not _is_string_pair(v):
                     raise RuntimeError('')
               else:
                  raise RuntimeError('')

           if subst_type == "string":
              return self._substitute_symbols(s)
           else:
              return self._substitute_symbol_pairs(s)

        if _is_string(s):
           if _is_string(S):
              input=True
              output=True
              for k,v in kwargs.items():
                  if k == 'input':
                     if v == False:
                        input=False
                  elif k == 'output':
                     if v == False:
                        output=False
                  else:
                     raise RuntimeError('Free argument not recognized.')
              return self._substitute_symbol(s, S, input, output)
           else:
              raise RuntimeError('...')
        elif _is_string_pair(s):
           if _is_string_pair(S):
              return self._substitute_symbol_pair(s, S)
           elif _is_string_pair_vector(S):
              return self._substitute_symbol_pair_with_set(s, S)
           elif isinstance(S, HfstTransducer):
              return self._substitute_symbol_pair_with_transducer(s, S, True)
           else:
              raise RuntimeError('...')
        else:
           raise RuntimeError('...')

HfstTransducer_swigregister = _libhfst_dev.HfstTransducer_swigregister
HfstTransducer_swigregister(HfstTransducer)

def HfstTransducer_is_implementation_type_available(type):
    """


    Whether HFST is linked to the transducer library needed by implementation type
    *type*.

    """
    return _libhfst_dev.HfstTransducer_is_implementation_type_available(type)


def _create_hfst_output_stream(filename, type, hfst_format):
    return _libhfst_dev._create_hfst_output_stream(filename, type, hfst_format)
_create_hfst_output_stream = _libhfst_dev._create_hfst_output_stream
class HfstOutputStream(_object):
    """


    A stream for writing binary transducers.

    An example:

         res = ['foo:bar','0','0 - 0','"?":?','a* b+']
         ostr = hfst.HfstOutputStream(filename='testfile1.hfst')
         for re in res:
             ostr.write(hfst.regex(re))
             ostr.flush()
         ostr.close()

    For more information on HFST transducer structure, see this page.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstOutputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstOutputStream, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst_dev.delete_HfstOutputStream
    __del__ = lambda self: None

    def flush(self):
        """


        Flush the stream.

        """
        return _libhfst_dev.HfstOutputStream_flush(self)


    def close(self):
        """


        Close the stream.

        If the stream points to standard output, nothing is done.

        """
        return _libhfst_dev.HfstOutputStream_close(self)


    def redirect(self, arg2):
        return _libhfst_dev.HfstOutputStream_redirect(self, arg2)

    def __init__(self):
        this = _libhfst_dev.new_HfstOutputStream()
        try:
            self.this.append(this)
        except Exception:
            self.this = this


    def write(self, tr):
        """
        Write one or more transducers to stream.

        Parameters
        ----------
        * `tr` :
            An HfstTransducer or an iterable object of several HfstTransducers.
        """
        if isinstance(tr, HfstTransducer):
            self.redirect(tr)
        else:
            for t in tr:
                if isinstance(t, HfstTransducer):
                    self.redirect(t)
                else:
                    raise RuntimeError('Cannot write objects that are not instances of HfstTransducer')

    def __init__(self, **kwargs):
        """
        Open a stream for writing binary transducers. Note: hfst.HfstTransducer.write_to_file
        is probably the easiest way to write a single binary transducer to a file.

        Parameters
        ----------
        * `kwargs` :
            Arguments recognized are filename, hfst_format, type.
        * `filename` :
            The name of the file where transducers are written. If the file exists, it
            is overwritten. If *filename* is not given, transducers are written to
            standard output.
        * `hfst_format` :
            Whether transducers are written in hfst format (default is True) or as such
            in their backend format.
        * `type` :
            The type of the transducers that will be written to the stream. Default is
            hfst.get_default_fst_type().

        Examples:

    # a stream for writing default type transducers in hfst format to standard output
            ostr = hfst.HfstOutputStream()
            transducer = hfst.regex('foo:bar::0.5')
            ostr.write(transducer)
            ostr.flush()

    # a stream for writing native sfst type transducers to a file
            ostr = hfst.HfstOutputStream(filename='transducer.sfst', hfst_format=False, type=hfst.ImplementationType.SFST_TYPE)
            transducer1 = hfst.regex('foo:bar')
            transducer1.convert(hfst.ImplementationType.SFST_TYPE)  # if not set as the default type
            transducer2 = hfst.regex('bar:baz')
            transducer2.convert(hfst.ImplementationType.SFST_TYPE)  # if not set as the default type
            ostr.write(transducer1)
            ostr.write(transducer2)
            ostr.flush()
            ostr.close()
        """
        filename = ""
        hfst_format = True
        type = _libhfst_dev.get_default_fst_type()
        for k,v in kwargs.items():
            if k == 'filename':
                filename = v
            if k == 'hfst_format':
                hfst_format = v
            if k == 'type':
                type = v
        if filename == "":
            self.this = _libhfst_dev._create_hfst_output_stream("", type, hfst_format)
        else:
            self.this = _libhfst_dev._create_hfst_output_stream(filename, type, hfst_format)

HfstOutputStream_swigregister = _libhfst_dev.HfstOutputStream_swigregister
HfstOutputStream_swigregister(HfstOutputStream)

class HfstInputStream(_object):
    """


    A stream for reading HFST binary transducers.

    An example:

         istr = hfst.HfstInputStream('testfile1.hfst')
         transducers = []
         while not (istr.is_eof()):
             transducers.append(istr.read())
         istr.close()
         print("Read %i transducers in total." % len(transducers))

    For documentation on the HFST binary transducer format, see here.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstInputStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstInputStream, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstInputStream(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstInputStream
    __del__ = lambda self: None

    def close(self):
        """


        Close the stream.

        If the stream points to standard input, nothing is done.

        """
        return _libhfst_dev.HfstInputStream_close(self)


    def is_eof(self):
        """


        Whether the stream is at end.

        """
        return _libhfst_dev.HfstInputStream_is_eof(self)


    def is_bad(self):
        """


        Whether badbit is set.

        """
        return _libhfst_dev.HfstInputStream_is_bad(self)


    def is_good(self):
        """


        Whether the state of the stream is good for input operations.

        """
        return _libhfst_dev.HfstInputStream_is_good(self)


    def get_type(self):
        """


        The type of the first transducer in the stream.

        By default, all transducers in a stream have the same type, else a
        TransducerTypeMismatchException is thrown when reading the first transducer that
        has a different type than the previous ones.

        """
        return _libhfst_dev.HfstInputStream_get_type(self)


    def read(self):
        """


        Return next transducer.

        Exceptions
        ----------
        * `EndOfStreamException` :

        """
        return _libhfst_dev.HfstInputStream_read(self)



    def read_all(self):
        """
        Read all transducers from stream and return them in a list.
        """
        retval = []
        while(not self.is_eof()):
            retval.append(self.read())
        return retval

    def __iter__(self):
        """
        Return *self*. Needed for 'for ... in' statement.
        """
        return self

    def next(self):
        """
        Read next transducer from stream and return it. Needed for 'for ... in' statement.
        """
        if self.is_eof():
            raise StopIteration
        else:
            return self.read();

    def __next__(self):
        """
        Read next transducer from stream and return it. Needed for 'for ... in' statement.
        """
        return self.next()


HfstInputStream_swigregister = _libhfst_dev.HfstInputStream_swigregister
HfstInputStream_swigregister(HfstInputStream)

class HfstTokenizer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTokenizer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTokenizer, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _libhfst_dev.new_HfstTokenizer()
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def add_skip_symbol(self, symbol):
        return _libhfst_dev.HfstTokenizer_add_skip_symbol(self, symbol)

    def add_multichar_symbol(self, symbol):
        return _libhfst_dev.HfstTokenizer_add_multichar_symbol(self, symbol)

    def add_multichar_symbols(self, symbols):
        return _libhfst_dev.HfstTokenizer_add_multichar_symbols(self, symbols)

    def tokenize_one_level(self, input_string):
        return _libhfst_dev.HfstTokenizer_tokenize_one_level(self, input_string)
    __swig_getmethods__["tokenize_space_separated"] = lambda x: _libhfst_dev.HfstTokenizer_tokenize_space_separated
    if _newclass:
        tokenize_space_separated = staticmethod(_libhfst_dev.HfstTokenizer_tokenize_space_separated)

    def tokenize(self, *args):
        return _libhfst_dev.HfstTokenizer_tokenize(self, *args)
    __swig_getmethods__["check_utf8_correctness"] = lambda x: _libhfst_dev.HfstTokenizer_check_utf8_correctness
    if _newclass:
        check_utf8_correctness = staticmethod(_libhfst_dev.HfstTokenizer_check_utf8_correctness)
    __swig_destroy__ = _libhfst_dev.delete_HfstTokenizer
    __del__ = lambda self: None
HfstTokenizer_swigregister = _libhfst_dev.HfstTokenizer_swigregister
HfstTokenizer_swigregister(HfstTokenizer)

def HfstTokenizer_tokenize_space_separated(str):
    return _libhfst_dev.HfstTokenizer_tokenize_space_separated(str)
HfstTokenizer_tokenize_space_separated = _libhfst_dev.HfstTokenizer_tokenize_space_separated

def HfstTokenizer_check_utf8_correctness(input_string):
    return _libhfst_dev.HfstTokenizer_check_utf8_correctness(input_string)
HfstTokenizer_check_utf8_correctness = _libhfst_dev.HfstTokenizer_check_utf8_correctness

class HfstIterableTransducer(_object):
    """


    A simple transducer class with tropical weights.

    An example of creating an HfstIterableTransducer [foo:bar baz:baz] with weight 0.4
    from scratch:

          # Create an empty transducer
          # The transducer has initially one start state (number zero)
          # that is not final
          fsm = hfst.HfstIterableTransducer()
          # Add two states to the transducer
          fsm.add_state(1)
          fsm.add_state(2)
          # Create a transition [foo:bar] leading to state 1 with weight 0.1
          tr = hfst.HfstTransition(1, 'foo', 'bar', 0.1)
          # and add it to state zero
          fsm.add_transition(0, tr)
          # Add a transition [baz:baz] with weight 0 from state 1 to state 2
          fsm.add_transition(1, hfst.HfstTransition(2, 'baz', 'baz', 0.0))
          # Set state 2 as final with weight 0.3
          fsm.set_final_weight(2, 0.3)

    An example of iterating through the states and transitions of the above
    transducer when printing them in AT&T format to standard output:

          # Go through all states
          for state, arcs in enumerate(fsm):
            for arc in arcs:
              print('%i ' % (state), end='')
              print(arc)
            if fsm.is_final_state(state):
              print('%i %f' % (state, fsm.get_final_weight(state)) )

    See also: hfst.HfstTransition

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstIterableTransducer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstIterableTransducer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstIterableTransducer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_setmethods__["name"] = _libhfst_dev.HfstIterableTransducer_name_set
    __swig_getmethods__["name"] = _libhfst_dev.HfstIterableTransducer_name_get
    if _newclass:
        name = _swig_property(_libhfst_dev.HfstIterableTransducer_name_get, _libhfst_dev.HfstIterableTransducer_name_set)

    def add_symbol_to_alphabet(self, symbol):
        """


        Explicitly add *symbol* to the alphabet of the graph.

        note: Usually the user does not have to take care of the alphabet of a graph.
            This function can be useful in some special cases. @ param symbol The string
            to be added.

        """
        return _libhfst_dev.HfstIterableTransducer_add_symbol_to_alphabet(self, symbol)


    def remove_symbol_from_alphabet(self, symbol):
        """


        Remove symbol *symbol* from the alphabet of the graph.

        note: Use with care, removing symbols that occur in the transitions of the graph
            can have unexpected results.

        Parameters
        ----------
        * `symbol` :
            The string to be removed.

        """
        return _libhfst_dev.HfstIterableTransducer_remove_symbol_from_alphabet(self, symbol)


    def remove_symbols_from_alphabet(self, symbols):
        """


        Remove symbols *symbols* from the alphabet of the graph.

        note: Use with care, removing symbols that occur in the transitions of the graph
            can have unexpected results.

        Parameters
        ----------
        * `symbols` :
            A tuple of strings to be removed.

        """
        return _libhfst_dev.HfstIterableTransducer_remove_symbols_from_alphabet(self, symbols)


    def add_symbols_to_alphabet(self, symbols):
        """


        Explicitly add *symbols* to the alphabet of the graph.

        note: Usually the user does not have to take care of the alphabet of a graph.
            This function can be useful in some special cases.

        Parameters
        ----------
        * `symbols` :
            A tuple of strings to be added.

        """
        return _libhfst_dev.HfstIterableTransducer_add_symbols_to_alphabet(self, symbols)


    def symbols_used(self):
        """


        Get a list of all symbols used in the transitions of this transducer.

        """
        return _libhfst_dev.HfstIterableTransducer_symbols_used(self)


    def prune_alphabet(self, force=True):
        """


        Remove all symbols that do not occur in transitions of the transducer from its
        alphabet.

        Epsilon, unknown and identity symbols are always included in the alphabet.

        """
        return _libhfst_dev.HfstIterableTransducer_prune_alphabet(self, force)


    def get_alphabet(self):
        """


        The symbols in the alphabet of the transducer.

        The symbols do not necessarily occur in any transitions of the transducer.
        Epsilon, unknown and identity symbols are always included in the alphabet.

        Returns
        -------
        A tuple of strings.

        """
        return _libhfst_dev.HfstIterableTransducer_get_alphabet(self)


    def get_input_symbols(self):
        return _libhfst_dev.HfstIterableTransducer_get_input_symbols(self)

    def get_output_symbols(self):
        return _libhfst_dev.HfstIterableTransducer_get_output_symbols(self)

    def get_transition_pairs(self):
        """


        Get a list of all input/output symbol pairs used in the transitions of this
        transducer.

        """
        return _libhfst_dev.HfstIterableTransducer_get_transition_pairs(self)


    def add_state(self, *args):
        """


        Add a state to this graph. The parameters (*args) are:

        Parameters
        ----------
        * `state (arg1, optional)` :
            The number of the state to be added. Defaults to the next (smallest) free state number.

        Returns
        -------
        The number of state that was added.

        If the state already exists, it is not added again. All states with a smaller
        state number are also added to the transducer if they did not exist before.

        Examples
        --------
        tr = HfstIterableTransducer()  # has one initial state, 0
        tr.add_state()  # adds state 1
        tr.add_state(5) # adds states 2, 3, 4 and 5
        tr.add_state()  # adds state 6

        """
        return _libhfst_dev.HfstIterableTransducer_add_state(self, *args)


    def get_max_state(self):
        """


        Get the biggest state number in use.

        Returns
        -------
        The biggest state number in use.

        """
        return _libhfst_dev.HfstIterableTransducer_get_max_state(self)


    def states(self):
        """


        The states of the transducer.

        Returns
        -------
        A tuple of state numbers.

        An example: /verbatim for state in fsm.states(): for arc in
        fsm.transitions(state): print('i ' % (state), end='') print(arc) if
        fsm.is_final_state(state): print('i f' % (state, fsm.get_final_weight(state)) )
        /endverbatim

        """
        return _libhfst_dev.HfstIterableTransducer_states(self)


    def remove_transition(self, s, transition, remove_symbols_from_alphabet=False):
        """

        Remove all transitions equivalent to *transition* from state *s*.

        Parameters
        ----------
        * `s` :
            The state which *transition* belongs to.
        * `transition` :
            A transition which is compared with all transitions of state *s*, ignoring
            the weights. It a transition is equivalent to *transition*, it is removed
            from the transducer.
        * `remove_symbols_from_alphabet` :
            Remove such symbols from transducer alphabet that no longer occur in its
            transitions (as a result of transition removal). Defaults to False.

        Note: Removing transitions during iteration (e.g. with 'transitions') will
        invalidate the iteration. Iteration of states (e.g. with 'states') is possible.

        """
        return _libhfst_dev.HfstIterableTransducer_remove_transition(self, s, transition, remove_symbols_from_alphabet)


    def is_final_state(self, s):
        """


        Whether state *state* is final.

        Parameters
        ----------
        * `state` :
            The state whose finality is returned.

        """
        return _libhfst_dev.HfstIterableTransducer_is_final_state(self, s)


    def get_final_weight(self, s):
        """


        Get the final weight of state *state* in this transducer.

        Parameters
        ----------
        * `state` :
            The number of the state. If it does not exist, a StateIsNotFinalException is
            thrown.

        Exceptions
        ----------
        * `hfst.exceptions.StateIsNotFinalException.` :

        """
        return _libhfst_dev.HfstIterableTransducer_get_final_weight(self, s)


    def set_final_weight(self, s, weight):
        """


        Set the final weight of state *state* in this transducer to *weight*.

        If the state does not exist, it is created.

        """
        return _libhfst_dev.HfstIterableTransducer_set_final_weight(self, s, weight)


    def remove_final_weight(self, s):
        """


        Remove the final weight of state *state* in this transducer, i.e. make the state non-final.

        """
        return _libhfst_dev.HfstIterableTransducer_remove_final_weight(self, s)


    def is_infinitely_ambiguous(self):
        """


        Whether the transducer is infinitely ambiguous.

        A transducer is infinitely ambiguous if there exists an input that will yield
        infinitely many results, i.e. there are input epsilon loops that are traversed
        with that input.

        """
        return _libhfst_dev.HfstIterableTransducer_is_infinitely_ambiguous(self)


    def is_lookup_infinitely_ambiguous(self, s):
        """


        Whether the transducer is infinitely ambiguous with input *str*.

        Parameters
        ----------
        * `str` :
            The input.

        A transducer is infinitely ambiguous with a given input if the input yields
        infinitely many results, i.e. there are input epsilon loops that are traversed
        with the input.

        """
        return _libhfst_dev.HfstIterableTransducer_is_lookup_infinitely_ambiguous(self, s)


    def longest_path_size(self):
        """


        The length of the longest path in transducer.

        Length of a path means number of arcs on that path.

        """
        return _libhfst_dev.HfstIterableTransducer_longest_path_size(self)


    def _transitions(self, s):
        return _libhfst_dev.HfstIterableTransducer__transitions(self, s)

    def _substitute_symbol(self, old_symbol, new_symbol, input_side=True, output_side=True):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol(self, old_symbol, new_symbol, input_side, output_side)

    def _substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pair(self, old_symbol_pair, new_symbol_pair)

    def _substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pair_with_set(self, old_symbol_pair, new_symbol_pair_set)

    def _substitute_symbol_pair_with_transducer(self, symbol_pair, transducer):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pair_with_transducer(self, symbol_pair, transducer)

    def _substitute_symbols(self, substitutions):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbols(self, substitutions)

    def _substitute_symbol_pairs(self, substitutions):
        return _libhfst_dev.HfstIterableTransducer__substitute_symbol_pairs(self, substitutions)

    def insert_freely(self, *args):
        """


        Insert freely any number of transition or copy of a transducer.
        The parameters (*args) can be defined in two ways:

        Parameters (1)
        --------------
        * `symbol_pair (arg1)` :
            A string pair to be inserted.
        * `weight (arg2, optional)` :
            The weight of the inserted symbol pair. Defaults to zero.

        Parameters (2)
        --------------
        * `transducer (arg1)` :
            An HfstIterableTransducer to be inserted.

        Examples
        --------

        # [foo:bar]
        tr = HfstIterableTransducer()
        tr.add_transition(0, 1, 'foo', 'bar')
        tr.set_final_weight(1, 0)

        # [BAZ::0.2]
        TR = HfstIterableTransducer()
        TR.add_transition(0, 1, 'BAZ', 'BAZ', 0.2)
        TR.set_final_weight(1, 0)

        # [[baz::0.1]* foo:bar [baz::0.1]*]
        tr.insert_freely(('baz', 'baz'), 0.1)

        # [[BAZ::0.2]* [baz::0.1]* foo:bar [baz::0.1]* [BAZ::0.2]*]
        tr.insert_freely(TR)

        """
        return _libhfst_dev.HfstIterableTransducer_insert_freely(self, *args)


    def sort_arcs(self):
        """


        Sort the arcs of this transducer according to input and output symbols.

        Returns
        -------
        This transducer.

        """
        return _libhfst_dev.HfstIterableTransducer_sort_arcs(self)


    def disjunct(self, spv, weight):
        """


        Disjunct this transducer with a one-path transducer defined by consecutive
        string pairs in *spv* that has weight *weight*.

        pre: This graph must be a trie where all weights are in final states, i.e. all
            transitions have a zero weight.

        There is no way to test whether a graph is a trie, so the use of this function
        is probably limited to fast construction of a lexicon. Here is an example:

             lexicon = hfst.HfstIterableTransducer()
             tok = hfst.HfstTokenizer()
             lexicon.disjunct(tok.tokenize('dog'), 0.3)
             lexicon.disjunct(tok.tokenize('cat'), 0.5)
             lexicon.disjunct(tok.tokenize('elephant'), 1.6)

        """
        return _libhfst_dev.HfstIterableTransducer_disjunct(self, spv, weight)


    def harmonize(self, another):
        """


        Harmonize this transducer and *another*.

        In harmonization the unknown and identity symbols in transitions of both graphs
        are expanded according to the symbols that are previously unknown to the graph.

        For example the graphs

             [a:b ?:?]
             [c:d ? ?:c] are expanded to

             [ a:b [?:? | ?:c | ?:d | c:d | d:c | c:? | d:?] ]
             [ c:d [? | a | b] [?:c| a:c | b:?] ] when harmonized.

        The symbol '?' means hfst.UNKNOWN in either or both sides of a transition
        (transitions of type [?:x], [x:?] and [?:?]). The transition [?] means
        hfst.IDENTITY.

        note: This function is always called for all transducer arguments of functions
            that take two or more graphs as their arguments, unless otherwise said.

        """
        return _libhfst_dev.HfstIterableTransducer_harmonize(self, another)

    __swig_getmethods__["read_binary_sfst_transducer"] = lambda x: _libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer
    if _newclass:
        read_binary_sfst_transducer = staticmethod(_libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer)

    def write_binary_sfst_transducer(self, filename):
        return _libhfst_dev.HfstIterableTransducer_write_binary_sfst_transducer(self, filename)

    def _lookup(self, lookup_path, infinite_cutoff, max_weight, obey_flags):
        return _libhfst_dev.HfstIterableTransducer__lookup(self, lookup_path, infinite_cutoff, max_weight, obey_flags)

    def get_prolog_string(self, write_weights):
        return _libhfst_dev.HfstIterableTransducer_get_prolog_string(self, write_weights)

    def get_xfst_string(self, write_weights):
        return _libhfst_dev.HfstIterableTransducer_get_xfst_string(self, write_weights)

    def get_att_string(self, write_weights):
        return _libhfst_dev.HfstIterableTransducer_get_att_string(self, write_weights)

    def __str__(self):
        """


        Return a string representation of the transducer.

             print(fsm)

        """
        return _libhfst_dev.HfstIterableTransducer___str__(self)


    def add_transition(self, *args):
        """

        Add transition to a state. The parameters (*args) can be defined in two ways:

        Parameters (1)
        --------------
        * `state (arg1)` :
            The number of the state where the transition is added. If it does not exist,
            it is created.
        * `transition (arg2)` :
            An hfst.HfstTransition that is added to *state*.
        * `add_symbols_to_alphabet (arg3, optional)` :
            Whether the transition symbols are added to the alphabet of the transducer.
            (In special cases this is not wanted.) Defaults to True.

        Parameters (2)
        --------------
        * `source (arg1)` :
            The number of the state where the transition is added. If it does not exist,
            it is created.
        * `target (arg2)` :
            The number of the state where the transition leads. If it does not exist, it
            is created.
        * `input (arg3)` :
            The input symbol of the transition.
        * `output (arg4)` :
            The output symbol of the transition.
        * `weight (arg5, optional)` :
            The weight of the transition. Defaults to zero.
        * `add_symbols_to_alphabet (arg6, optional)` :
            Whether the transition symbols are added to the alphabet of the transducer.
            (In special cases this is not wanted.) Defaults to True.

        Note: Adding transitions during iteration (e.g. with 'transitions') will
        invalidate the iteration. Iteration of states (e.g. with 'states') is possible.

        Examples
        --------
        tr = HfstIterableTransducer()  # has one initial state, 0
        transition = HfstTransition(1, 'foo', 'bar', 0.5)
        tr.add_transition(0, transition)
        tr.add_transition(1, 2, 'Foo', 'Bar')
        tr.add_transition(1, 2, 'FOO', 'BAR', 0.3)
        tr.set_final_weight(2, 0.4)
        # tr now maps 'fooFooFOO' to 'barBarBAR' with weight 1.2.

        """
        return _libhfst_dev.HfstIterableTransducer_add_transition(self, *args)



    def view(self):
        """
        Return a dot Digraph representation of the transducer as a graphviz.Source object.

        Examples:

        Inside a Jupyter notebook, the return value will be automatically
        rendered to an svg image and displayed on the console:

        tr = hfst_dev.regex('foo:bar')
        tr.view()

        If inside an intended block, 'display' must be called:

        if (Foo):
            tr = hfst_dev.regex('foo:bar')
            display(tr.view())

        On other environments, the return value must be explicitely rendered
        to an svg image before displaying it:

        tr = hfst_dev.regex('foo:bar')
        from IPython.core.display import display, SVG
        display(SVG(tr.view()._repr_svg_()))
        """
        TR = HfstTransducer(self)
        return TR.view()

    def transitions(self, s):
        """
        ...
        """
        tr = self._transitions(s)
        retval = []
        for i in range(0, len(tr)):
            retval.append(tr[i])
        return retval

    def states_and_transitions(self):
        """
        ...
        """
        retval = []
        for s in self.states():
            retval.append(self.transitions(s))
        return retval

    def __iter__(self):
        """
        Return states and transitions of the transducer.
        """
        return self.states_and_transitions().__iter__()

    def __enumerate__(self):
        """
        Return an enumeration of states and transitions of the transducer.
        """
        return enumerate(self.states_and_transitions())

    def write_prolog(self, f, write_weights=True):
        """
        Write the transducer in prolog format with name *name* to file *f*,
        *write_weights* defined whether weights are written.

        Parameters
        ----------
        * `f` :
            A python file where the transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        prologstr = self.get_prolog_string(write_weights)
        f.write(prologstr)

    def write_xfst(self, f, write_weights=True):
        """
        Write the transducer in xfst format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        xfststr = self.get_xfst_string(write_weights)
        f.write(prologstr)

    def write_att(self, f, write_weights=True):
        """
        Write the transducer in AT&T format to file *f*, *write_weights* defined whether
        weights are written.

        Parameters
        ----------
        * `f` :
            A python file where transducer is written.
        * `write_weights` :
            Whether weights are written.
        """
        attstr = self.get_att_string(write_weights)
        f.write(attstr)

    def lookup(self, lookup_path, **kwargs):
        """
        Lookup tokenized input *input* in the transducer.

        Parameters
        ----------
        * `str` :
            A list/tuple of strings to look up.
        * `kwargs` :
            infinite_cutoff=-1, max_weight=None, obey_flags=False
        * `max_epsilon_loops` :
            How many times epsilon input loops are followed. Defaults to -1, i.e. infinitely.
        * `max_weight` :
            What is the maximum weight of a result allowed. Defaults to None, i.e. infinity.
        * `obey_flags` :
            Whether flag diacritic constraints are obeyed. Defaults to False.
        """
        max_weight = None
        max_epsilon_loops = None
        obey_flags = False
        output='dict' # 'dict' (default), 'text', 'raw'

        for k,v in kwargs.items():
            if k == 'max_weight' :
               max_weight=v
            elif k == 'max_epsilon_loops' :
               infinite_cutoff=v
            elif k == 'obey_flags' :
               obey_flags=v
            elif k == 'output':
               if v == 'text':
                  output == 'text'
               elif v == 'raw':
                  output='raw'
               elif v == 'dict':
                  output='dict'
               else:
                  print('Warning: ignoring argument %s as it has value %s.' % (k, v))
                  print("Possible values are 'dict' (default), 'text', 'raw'.")
            else:
               print('Warning: ignoring unknown argument %s.' % (k))

        retval = self._lookup(lookup_path, max_epsilon_loops, max_weight, obey_flags)

        if output == 'text':
           return _two_level_paths_to_string(retval)
        elif output == 'dict':
           return _two_level_paths_to_dict(retval)
        else:
           return retval

    def substitute(self, s, S=None, **kwargs):
        """

        Substitute symbols or transitions in the transducer.

        Parameters
        ----------
        * `s` :
            The symbol or transition to be substituted. Can also be a dictionary of
            substitutions, if S == None.
        * `S` :
            The symbol, transition, a tuple of transitions or a transducer
            (hfst.HfstIterableTransducer) that substitutes *s*.
        * `kwargs` :
            Arguments recognized are 'input' and 'output', their values can be False or
            True, True being the default. These arguments are valid only if *s* and *S*
            are strings, else they are ignored.
        * `input` :
            Whether substitution is performed on input side, defaults to True. Valid
            only if *s* and *S* are strings.
        * `output` :
            Whether substitution is performed on output side, defaults to True. Valid
            only if *s* and *S* are strings.

        Possible combinations of arguments and their types are:

        (1) substitute(str, str, input=bool, output=bool): substitute symbol with symbol
        on input, output or both sides of each transition in the transducer. (2)
        substitute(strpair, strpair): substitute transition with transition (3)
        substitute(strpair, strpairtuple): substitute transition with several
        transitions (4) substitute(strpair, transducer): substitute transition with a
        transducer (5) substitute(dict): perform several symbol-to-symbol substitutions
        (6) substitute(dict): perform several transition-to-transition substitutions

        Examples:

        (1) tr.substitute('a', 'A', input=True, output=False): substitute lowercase a:s
        with uppercase ones (2) tr.substitute(('a','b'),('A','B')): substitute
        transitions that map lowercase a into lowercase b with transitions that map
        uppercase a into uppercase b (3) tr.substitute(('a','b'),
        (('A','B'),('a','B'),('A','b'))): change either or both sides of a transition
        [a:b] to uppercase (4) tr.substitute(('a','b'), hfst.regex('[a:b]+')) change
        [a:b] transition into one or more consecutive [a:b] transitions (5)
        tr.substitute({'a':'A', 'b':'B', 'c':'C'}) change lowercase a, b and c into
        their uppercase variants (6) tr.substitute( {('a','a'):('A','A'),
        ('b','b'):('B','B'), ('c','c'):('C','C')} ): change lowercase a, b and c into
        their uppercase variants

        In case (4), epsilon transitions are used to attach copies of transducer *S*
        between the SOURCE and TARGET state of each transition that is substituted. The
        transition itself is deleted, but its weight is copied to the epsilon transition
        leading from SOURCE to the initial state of *S*. Each final state of *S* is made
        non-final and an epsilon transition leading to TARGET is attached to it. The
        final weight is copied to the epsilon transition.
        """
        if S == None:
           if not isinstance(s, dict):
              raise RuntimeError('First input argument must be a dictionary.')

           subst_type=""

           for k, v in s.items():
               if _is_string(k):
                  if subst_type == "":
                     subst_type="string"
                  elif subst_type == "string pair":
                     raise RuntimeError('')
                  if not _is_string(v):
                     raise RuntimeError('')
               elif _is_string_pair(k):
                  if subst_type == "":
                     subst_type="string pair"
                  elif subst_type == "string":
                     raise RuntimeError('')
                  if not _is_string_pair(v):
                     raise RuntimeError('')
               else:
                  raise RuntimeError('')

           if subst_type == "string":
              return self._substitute_symbols(s)
           else:
              return self._substitute_symbol_pairs(s)

        if _is_string(s):
           if _is_string(S):
              input=True
              output=True
              for k,v in kwargs.items():
                  if k == 'input':
                     if v == False:
                        input=False
                  elif k == 'output':
                     if v == False:
                        output=False
                  else:
                     raise RuntimeError('Free argument not recognized.')
              return self._substitute_symbol(s, S, input, output)
           else:
              raise RuntimeError('...')
        elif _is_string_pair(s):
           if _is_string_pair(S):
              return self._substitute_symbol_pair(s, S)
           elif _is_string_pair_vector(S):
              return self._substitute_symbol_pair_with_set(s, S)
           elif isinstance(S, HfstIterableTransducer):
              return self._substitute_symbol_pair_with_transducer(s, S)
           else:
              raise RuntimeError('...')
        else:
           raise RuntimeError('...')


    __swig_destroy__ = _libhfst_dev.delete_HfstIterableTransducer
    __del__ = lambda self: None
HfstIterableTransducer_swigregister = _libhfst_dev.HfstIterableTransducer_swigregister
HfstIterableTransducer_swigregister(HfstIterableTransducer)

def HfstIterableTransducer_read_binary_sfst_transducer(filename):
    return _libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer(filename)
HfstIterableTransducer_read_binary_sfst_transducer = _libhfst_dev.HfstIterableTransducer_read_binary_sfst_transducer

class HfstTransition(_object):
    """


    A transition class that consists of a target state, input and output symbols and
    a a tropical weight.

    See also: hfst.HfstIterableTransducer

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HfstTransition, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HfstTransition, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_HfstTransition(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_HfstTransition
    __del__ = lambda self: None

    def get_target_state(self):
        """


        Get number of the target state of the transition.

        """
        return _libhfst_dev.HfstTransition_get_target_state(self)


    def get_input_symbol(self):
        """


        Get the input symbol of the transition.

        """
        return _libhfst_dev.HfstTransition_get_input_symbol(self)


    def set_input_symbol(self, symbol):
        return _libhfst_dev.HfstTransition_set_input_symbol(self, symbol)

    def get_output_symbol(self):
        """


        Get the output symbol of the transition.

        """
        return _libhfst_dev.HfstTransition_get_output_symbol(self)


    def set_output_symbol(self, symbol):
        return _libhfst_dev.HfstTransition_set_output_symbol(self, symbol)

    def get_weight(self):
        """


        Get the weight of the transition.

        """
        return _libhfst_dev.HfstTransition_get_weight(self)


    def set_weight(self, f):
        """


        Set the weight of the transition.

        Parameters
        ----------
        * `weight` :
            Weight of the transition.

        """
        return _libhfst_dev.HfstTransition_set_weight(self, f)


    def __str__(self):
        return _libhfst_dev.HfstTransition___str__(self)
HfstTransition_swigregister = _libhfst_dev.HfstTransition_swigregister
HfstTransition_swigregister(HfstTransition)

class XreCompiler(_object):
    """


    A regular expression compiler.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XreCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XreCompiler, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_XreCompiler(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def define_list(self, name, symbol_list):
        """


        todo

        """
        return _libhfst_dev.XreCompiler_define_list(self, name, symbol_list)


    def define_function(self, name, arguments, xre):
        """


        todo

        """
        return _libhfst_dev.XreCompiler_define_function(self, name, arguments, xre)


    def is_definition(self, name):
        """


        Whether *name* is a definition.

        """
        return _libhfst_dev.XreCompiler_is_definition(self, name)


    def is_function_definition(self, name):
        """


        Whether *name* is a function definition.

        """
        return _libhfst_dev.XreCompiler_is_function_definition(self, name)


    def undefine(self, name):
        """


        todo

        """
        return _libhfst_dev.XreCompiler_undefine(self, name)


    def compile(self, xre):
        """


        Compile a transducer defined by *xre*.

        May return a pointer to *empty* transducer on non-fatal error. A None pointer is
        returned on fatal error, if abort is not called.

        Returns
        -------
        An HfstTransducer pointer.

        """
        return _libhfst_dev.XreCompiler_compile(self, xre)


    def set_verbosity(self, verbose):
        """


        Set the verbosity of the compiler.

        *   v True or False

        """
        return _libhfst_dev.XreCompiler_set_verbosity(self, verbose)


    def set_expand_definitions(self, expand):
        """


        Whether definitions are expanded.

        *   v True or False

        """
        return _libhfst_dev.XreCompiler_set_expand_definitions(self, expand)


    def set_harmonization(self, harmonize):
        return _libhfst_dev.XreCompiler_set_harmonization(self, harmonize)

    def contained_only_comments(self):
        return _libhfst_dev.XreCompiler_contained_only_comments(self)

    def define_xre(self, name, xre):
        """


        Add a definition macro.

        Compilers will replace arcs labeled *name*, with a transducer defined by regular
        expression *xre* in later phases of compilation (if set_expand_definitions(True)
        has been called).

        """
        return _libhfst_dev.XreCompiler_define_xre(self, name, xre)


    def define_transducer(self, name, transducer):
        """


        Add a definition macro.

        Compilers will replace arcs labeled *name*, with a transducer *transducer* in
        later phases of compilation (if set_expand_definitions(True) has been called).

        """
        return _libhfst_dev.XreCompiler_define_transducer(self, name, transducer)


    def compile_first(self, xre):
        return _libhfst_dev.XreCompiler_compile_first(self, xre)

    def compile_iostream(self, xre):
        return _libhfst_dev.XreCompiler_compile_iostream(self, xre)
    __swig_destroy__ = _libhfst_dev.delete_XreCompiler
    __del__ = lambda self: None
XreCompiler_swigregister = _libhfst_dev.XreCompiler_swigregister
XreCompiler_swigregister(XreCompiler)

class LexcCompiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LexcCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LexcCompiler, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_LexcCompiler(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setVerbosity(self, verbose):
        return _libhfst_dev.LexcCompiler_setVerbosity(self, verbose)

    def print_output(self, str):
        return _libhfst_dev.LexcCompiler_print_output(self, str)

    def parse(self, filename):
        return _libhfst_dev.LexcCompiler_parse(self, filename)

    def parse_line(self, line):
        return _libhfst_dev.LexcCompiler_parse_line(self, line)

    def compileLexical(self):
        return _libhfst_dev.LexcCompiler_compileLexical(self)
    __swig_destroy__ = _libhfst_dev.delete_LexcCompiler
    __del__ = lambda self: None
LexcCompiler_swigregister = _libhfst_dev.LexcCompiler_swigregister
LexcCompiler_swigregister(LexcCompiler)

class XfstCompiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XfstCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XfstCompiler, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _libhfst_dev.new_XfstCompiler(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def setReadInteractiveTextFromStdin(self, Value):
        return _libhfst_dev.XfstCompiler_setReadInteractiveTextFromStdin(self, Value)

    def setReadline(self, value):
        return _libhfst_dev.XfstCompiler_setReadline(self, value)

    def setVerbosity(self, verbosity):
        return _libhfst_dev.XfstCompiler_setVerbosity(self, verbosity)

    def setInspectNetSupported(self, value):
        return _libhfst_dev.XfstCompiler_setInspectNetSupported(self, value)

    def set(self, name, text):
        return _libhfst_dev.XfstCompiler_set(self, name, text)

    def get(self, name):
        return _libhfst_dev.XfstCompiler_get(self, name)

    def top(self, silent=False):
        return _libhfst_dev.XfstCompiler_top(self, silent)

    def get_prompt(self):
        return _libhfst_dev.XfstCompiler_get_prompt(self)

    def apply_up(self, indata):
        return _libhfst_dev.XfstCompiler_apply_up(self, indata)

    def apply_down(self, indata):
        return _libhfst_dev.XfstCompiler_apply_down(self, indata)

    def parse_line(self, line):
        return _libhfst_dev.XfstCompiler_parse_line(self, line)

    def quit_requested(self):
        return _libhfst_dev.XfstCompiler_quit_requested(self)
    __swig_destroy__ = _libhfst_dev.delete_XfstCompiler
    __del__ = lambda self: None
XfstCompiler_swigregister = _libhfst_dev.XfstCompiler_swigregister
XfstCompiler_swigregister(XfstCompiler)


def _get_hfst_sfst_output():
    return _libhfst_dev._get_hfst_sfst_output()
_get_hfst_sfst_output = _libhfst_dev._get_hfst_sfst_output

def _hfst_compile_sfst(filename, error_stream, verbose):
    return _libhfst_dev._hfst_compile_sfst(filename, error_stream, verbose)
_hfst_compile_sfst = _libhfst_dev._hfst_compile_sfst

def _one_level_paths_to_string(arg1, show_flags):
    return _libhfst_dev._one_level_paths_to_string(arg1, show_flags)
_one_level_paths_to_string = _libhfst_dev._one_level_paths_to_string

def _two_level_paths_to_string(arg1):
    return _libhfst_dev._two_level_paths_to_string(arg1)
_two_level_paths_to_string = _libhfst_dev._two_level_paths_to_string

def _parse_prolog_network_line(line, graph):
    return _libhfst_dev._parse_prolog_network_line(line, graph)
_parse_prolog_network_line = _libhfst_dev._parse_prolog_network_line

def _parse_prolog_arc_line(line, graph):
    return _libhfst_dev._parse_prolog_arc_line(line, graph)
_parse_prolog_arc_line = _libhfst_dev._parse_prolog_arc_line

def _parse_prolog_symbol_line(line, graph):
    return _libhfst_dev._parse_prolog_symbol_line(line, graph)
_parse_prolog_symbol_line = _libhfst_dev._parse_prolog_symbol_line

def _parse_prolog_final_line(line, graph):
    return _libhfst_dev._parse_prolog_final_line(line, graph)
_parse_prolog_final_line = _libhfst_dev._parse_prolog_final_line

def set_default_fst_type(t):
    """


    Set the default implementation type.

    Parameters
    ----------
    * `impl` :
        An hfst.ImplementationType.

    Set the implementation type (SFST_TYPE, TROPICAL_OPENFST_TYPE, FOMA_TYPE) that
    is used by default by all operations that create transducers. The default value
    is TROPICAL_OPENFST_TYPE

    """
    return _libhfst_dev.set_default_fst_type(t)

def get_default_fst_type():
    """


    Get default transducer implementation type.

    If the default type is not set, it defaults to hfst.ImplementationType.TROPICAL_OPENFST_TYPE

    """
    return _libhfst_dev.get_default_fst_type()

def fst_type_to_string(t):
    """


    Get a string representation of transducer implementation type *type*.

    Parameters
    ----------
    * `type` :
        An hfst.ImplementationType.

    """
    return _libhfst_dev.fst_type_to_string(t)

def two_level_if(context, mappings, alphabet):
    return _libhfst_dev.two_level_if(context, mappings, alphabet)
two_level_if = _libhfst_dev.two_level_if

def two_level_only_if(context, mappings, alphabet):
    return _libhfst_dev.two_level_only_if(context, mappings, alphabet)
two_level_only_if = _libhfst_dev.two_level_only_if

def two_level_if_and_only_if(context, mappings, alphabet):
    return _libhfst_dev.two_level_if_and_only_if(context, mappings, alphabet)
two_level_if_and_only_if = _libhfst_dev.two_level_if_and_only_if

def replace_down(context, mapping, optional, alphabet):
    return _libhfst_dev.replace_down(context, mapping, optional, alphabet)
replace_down = _libhfst_dev.replace_down

def replace_down_karttunen(context, mapping, optional, alphabet):
    return _libhfst_dev.replace_down_karttunen(context, mapping, optional, alphabet)
replace_down_karttunen = _libhfst_dev.replace_down_karttunen

def replace_right(context, mapping, optional, alphabet):
    return _libhfst_dev.replace_right(context, mapping, optional, alphabet)
replace_right = _libhfst_dev.replace_right

def sfst_replace_left(context, mapping, optional, alphabet):
    return _libhfst_dev.sfst_replace_left(context, mapping, optional, alphabet)
sfst_replace_left = _libhfst_dev.sfst_replace_left

def replace_up(context, mapping, optional, alphabet):
    return _libhfst_dev.replace_up(context, mapping, optional, alphabet)
replace_up = _libhfst_dev.replace_up

def left_replace_up(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_up(context, mapping, optional, alphabet)
left_replace_up = _libhfst_dev.left_replace_up

def left_replace_down(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_down(context, mapping, optional, alphabet)
left_replace_down = _libhfst_dev.left_replace_down

def left_replace_down_karttunen(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_down_karttunen(context, mapping, optional, alphabet)
left_replace_down_karttunen = _libhfst_dev.left_replace_down_karttunen

def left_replace_left(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_left(context, mapping, optional, alphabet)
left_replace_left = _libhfst_dev.left_replace_left

def left_replace_right(context, mapping, optional, alphabet):
    return _libhfst_dev.left_replace_right(context, mapping, optional, alphabet)
left_replace_right = _libhfst_dev.left_replace_right

def sfst_restriction(contexts, mapping, alphabet):
    return _libhfst_dev.sfst_restriction(contexts, mapping, alphabet)
sfst_restriction = _libhfst_dev.sfst_restriction

def coercion(contexts, mapping, alphabet):
    return _libhfst_dev.coercion(contexts, mapping, alphabet)
coercion = _libhfst_dev.coercion

def restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.restriction_and_coercion(contexts, mapping, alphabet)
restriction_and_coercion = _libhfst_dev.restriction_and_coercion

def surface_restriction(contexts, mapping, alphabet):
    return _libhfst_dev.surface_restriction(contexts, mapping, alphabet)
surface_restriction = _libhfst_dev.surface_restriction

def surface_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.surface_coercion(contexts, mapping, alphabet)
surface_coercion = _libhfst_dev.surface_coercion

def surface_restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.surface_restriction_and_coercion(contexts, mapping, alphabet)
surface_restriction_and_coercion = _libhfst_dev.surface_restriction_and_coercion

def deep_restriction(contexts, mapping, alphabet):
    return _libhfst_dev.deep_restriction(contexts, mapping, alphabet)
deep_restriction = _libhfst_dev.deep_restriction

def deep_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.deep_coercion(contexts, mapping, alphabet)
deep_coercion = _libhfst_dev.deep_coercion

def deep_restriction_and_coercion(contexts, mapping, alphabet):
    return _libhfst_dev.deep_restriction_and_coercion(contexts, mapping, alphabet)
deep_restriction_and_coercion = _libhfst_dev.deep_restriction_and_coercion
class TwolcCompiler(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TwolcCompiler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TwolcCompiler, name)
    __repr__ = _swig_repr
    __swig_getmethods__["compile_file_and_get_storable_rules"] = lambda x: _libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules
    if _newclass:
        compile_file_and_get_storable_rules = staticmethod(_libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules)
    __swig_getmethods__["compile_script_and_get_storable_rules"] = lambda x: _libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules
    if _newclass:
        compile_script_and_get_storable_rules = staticmethod(_libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules)

    def __init__(self):
        this = _libhfst_dev.new_TwolcCompiler()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _libhfst_dev.delete_TwolcCompiler
    __del__ = lambda self: None
TwolcCompiler_swigregister = _libhfst_dev.TwolcCompiler_swigregister
TwolcCompiler_swigregister(TwolcCompiler)

def TwolcCompiler_compile_file_and_get_storable_rules(inputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr=None):
    return _libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules(inputfile, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr)
TwolcCompiler_compile_file_and_get_storable_rules = _libhfst_dev.TwolcCompiler_compile_file_and_get_storable_rules

def TwolcCompiler_compile_script_and_get_storable_rules(script, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr=None):
    return _libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules(script, silent, verbose, resolve_left_conflicts, resolve_right_conflicts, type, ostr)
TwolcCompiler_compile_script_and_get_storable_rules = _libhfst_dev.TwolcCompiler_compile_script_and_get_storable_rules


def _pmatch_get_tokenized_output(cont, input_text, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar):
    return _libhfst_dev._pmatch_get_tokenized_output(cont, input_text, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar)
_pmatch_get_tokenized_output = _libhfst_dev._pmatch_get_tokenized_output

def _pmatch_locate(*args):
    return _libhfst_dev._pmatch_locate(*args)
_pmatch_locate = _libhfst_dev._pmatch_locate
class PmatchContainer(_object):
    """


    A class for performing pattern matching.

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PmatchContainer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PmatchContainer, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _libhfst_dev.delete_PmatchContainer
    __del__ = lambda self: None

    def match(self, input, time_cutoff=0.0):
        """


        Match input *input*.

        """
        return _libhfst_dev.PmatchContainer_match(self, input, time_cutoff)


    def get_profiling_info(self):
        """


        todo

        """
        return _libhfst_dev.PmatchContainer_get_profiling_info(self)


    def set_verbose(self, b):
        """


        todo

        """
        return _libhfst_dev.PmatchContainer_set_verbose(self, b)


    def set_profile(self, b):
        """


        todo

        """
        return _libhfst_dev.PmatchContainer_set_profile(self, b)


    def __init__(self, *args):
        this = _libhfst_dev.new_PmatchContainer(*args)
        try:
            self.this.append(this)
        except Exception:
            self.this = this

    def locate(self, *args):
        """


        The locations of pmatched strings for string *input* where the results are limited
        as defined by *time_cutoff* and *weight_cutoff*.

        Parameters
        ----------
        * `input` :
            The input string.
        * `time_cutoff` :
            Time cutoff, defaults to zero, i.e. no cutoff.
        * `weight_cutoff` :
            Weight cutoff, defaults to infinity, i.e. no cutoff.

        Returns
        -------
        A tuple of tuples of Location.

        """
        return _libhfst_dev.PmatchContainer_locate(self, *args)


    def get_tokenized_output(self, input, **kwargs):
        """
        Tokenize *input* and get a string representation of the tokenization
        (essentially the same that command line tool hfst-tokenize would give).

        Parameters
        ----------
        * `input` :
            The input string to be tokenized.
        * `kwargs` :
            Possible parameters are:
            output_format, max_weight_classes, dedupe, print_weights, print_all,
            time_cutoff, verbose, beam, tokenize_multichar.
        * `output_format` :
            The format of output; possible values are 'tokenize', 'xerox', 'cg', 'finnpos',
            'giellacg', 'conllu' and 'visl'; 'tokenize' being the default.
        * `max_weight_classes` :
            Maximum number of best weight classes to output
            (where analyses with equal weight constitute a class), defaults to None i.e. no limit.
        * `dedupe` :
            Whether duplicate analyses are removed, defaults to False.
        * `print_weights` :
            Whether weights are printd, defaults to False.
        * `print_all` :
            Whether nonmatching text is printed, defaults to False.
        * `time_cutoff` :
            Maximum number of seconds used per input after limiting the search.
        * `verbose` :
            Whether input is processed verbosely, defaults to True.
        * `beam` :
            Beam within analyses must be to get printed.
        * `tokenize_multichar` :
            Tokenize input into multicharacter symbols present in the transducer, defaults to false.
        """
        output_format='tokenize'
        max_weight_classes=None
        dedupe=False
        print_weights=False
        print_all=False
        time_cutoff=0.0
        verbose=True
        beam=-1.0
        tokenize_multichar=False
        for k,v in kwargs.items():
           if k == 'output_format':
              if v == 'tokenize' or v == 'space_separated' or v == 'xerox' or v == 'cg' or v == 'finnpos' or v == 'giellacg' or v == 'conllu':
                 output_format=v
              else:
                 print('Warning: ignoring unknown value %s for argument %s.' % (v,k))
           elif k == 'max_weight_classes':
              max_weight_classes=int(v)
           elif k == 'dedupe':
              dedupe=v
           elif k == 'print_weights':
              print_weights=v
           elif k == 'print_all':
              print_all=v
           elif k == 'time_cutoff':
              time_cutoff=float(v)
           elif k == 'verbose':
              verbose=v
           elif k == 'beam':
              beam=float(v)
           elif k == 'tokenize_multichar':
              tokenize_multichar=v
           else:
              print('Warning: ignoring unknown argument %s.' % (k))
        return _pmatch_get_tokenized_output(self, input, output_format, max_weight_classes, dedupe, print_weights, print_all, time_cutoff, verbose, beam, tokenize_multichar)

    def tokenize(self, input):
        """
        Tokenize *input* and return a list of tokens i.e. strings.

        Parameters
        ----------
        * `input` :
            The string to be tokenized.
        """
        retval = []
        locations = self.locate(input)
        for loc in locations:
           if loc[0].output != "@_NONMATCHING_@":
              retval.append(loc[0].input)
        return retval


PmatchContainer_swigregister = _libhfst_dev.PmatchContainer_swigregister
PmatchContainer_swigregister(PmatchContainer)



class ImplementationType:
    """
    Back-end implementation.

    Attributes:

        SFST_TYPE:               SFST type, unweighted
        TROPICAL_OPENFST_TYPE:   OpenFst type with tropical weights
        LOG_OPENFST_TYPE:        OpenFst type with logarithmic weights (limited support)
        FOMA_TYPE:               FOMA type, unweighted
        XFSM_TYPE:               XFST type, unweighted (limited support)
        HFST_OL_TYPE:            HFST optimized-lookup type, unweighted
        HFST_OLW_TYPE:           HFST optimized-lookup type, weighted
        HFST2_TYPE:              HFST version 2 legacy type
        UNSPECIFIED_TYPE:        type not specified
        ERROR_TYPE:              (something went wrong)

    """
    SFST_TYPE = _libhfst_dev.SFST_TYPE
    TROPICAL_OPENFST_TYPE = _libhfst_dev.TROPICAL_OPENFST_TYPE
    LOG_OPENFST_TYPE = _libhfst_dev.LOG_OPENFST_TYPE
    FOMA_TYPE = _libhfst_dev.FOMA_TYPE
    XFSM_TYPE = _libhfst_dev.XFSM_TYPE
    HFST_OL_TYPE = _libhfst_dev.HFST_OL_TYPE
    HFST_OLW_TYPE = _libhfst_dev.HFST_OLW_TYPE
    HFST2_TYPE = _libhfst_dev.HFST2_TYPE
    UNSPECIFIED_TYPE = _libhfst_dev.UNSPECIFIED_TYPE
    ERROR_TYPE = _libhfst_dev.ERROR_TYPE

class ReplaceType:
    """
    Replace type in Xerox-type rules.

    Attributes:

        REPL_UP:      Match contexts on input level
        REPL_DOWN:    Match contexts on output level
        REPL_RIGHT:   Match left contexts on input level and right contexts on output level
        REPL_LEFT:    Match left contexts on output level and right contexts on input level

    """
    REPL_UP = _libhfst_dev.REPL_UP
    REPL_DOWN = _libhfst_dev.REPL_DOWN
    REPL_RIGHT = _libhfst_dev.REPL_RIGHT
    REPL_LEFT = _libhfst_dev.REPL_LEFT


from sys import version
if int(version[0]) > 2:
    def unicode(s, c):
        return s

EPSILON='@_EPSILON_SYMBOL_@'
UNKNOWN='@_UNKNOWN_SYMBOL_@'
IDENTITY='@_IDENTITY_SYMBOL_@'

def start_xfst(**kwargs):
    """
    Start interactive xfst compiler.

    Parameters
    ----------
    * `kwargs` :
        Arguments recognized are: type, quit_on_fail.
    * `quit_on_fail` :
        Whether the compiler exits on any error, defaults to False.
    * `type` :
        Implementation type of the compiler, defaults to
        hfst_dev.get_default_fst_type().
    """
    type = get_default_fst_type()
    quit_on_fail = 'OFF'
    for k,v in kwargs.items():
      if k == 'type':
        type = v
      elif k == 'quit_on_fail':
        if v == True:
          quit_on_fail='ON'
      else:
        print('Warning: ignoring unknown argument %s.' % (k))

    comp = XfstCompiler(type)
    comp.setReadInteractiveTextFromStdin(True) # ?
    comp.setReadline(False) # do not mix python and c++ readline
    comp.set('quit-on-fail', quit_on_fail)

    rl_length_1 = 0
    rl_found = False
    try:
      import readline
      rl_found = True
      rl_length_1 = readline.get_current_history_length()
    except ImportError:
      pass

    expression=""
    while True:
        expression += input(comp.get_prompt()).rstrip().lstrip()
        if len(expression) == 0:
           continue
        if expression[-1] == '\\':
           expression = expression[:-2] + '\n'
           continue
        retval = -1
        if True:
            if (expression == "apply down" or expression == "apply up" or expression == "inspect" or expression == "inspect net"):
               stdout.write('interactive command \'' + expression + '\' not supported\n')
               retval = 0
# Viewing must be handled in python
            elif (expression == "view" or expression == "view net"):
               tr = comp.top(True) # silent mode
               if tr == None:
                  stdout.write('Empty stack.\n')
                  if comp.get("quit-on-fail") == "ON":
                     return
               else:
                  from IPython.core.display import display, SVG
                  display(SVG(tr.view()._repr_svg_()))
               retval = 0
            else:
               retval = comp.parse_line(expression);
# at the moment, interactive commands are not supported
        else:
# interactive command
            if (expression == "apply down" or expression == "apply up"):
               rl_length_2=0
               if rl_found:
                  rl_length_2 = readline.get_current_history_length()
               while True:
                  try:
                     line = input().rstrip().lstrip()
                  except EOFError:
                     break
                  if expression == "apply down":
                     comp.apply_down(line)
                  elif expression == "apply up":
                     comp.apply_up(line)
               if rl_found:
                  for foo in range(readline.get_current_history_length() - rl_length_2):
                     readline.remove_history_item(rl_length_2)
               retval = 0
            elif expression == "inspect" or expression == "inspect net":
               print('inspect net not supported')
               retval = 0
            else:
               retval = comp.parse_line(expression + "\n")
        if retval != 0:
           stdout.write("expression '%s' could not be parsed\n" % expression)
           if comp.get("quit-on-fail") == "ON":
              return
        if comp.quit_requested():
           break
        expression = ""

    if rl_found:
      for foo in range(readline.get_current_history_length() - rl_length_1):
         readline.remove_history_item(rl_length_1)

from sys import stdout

def regex(re, **kwargs):
    """
    Get a transducer as defined by regular expression *re*.

    Parameters
    ----------
    * `re` :
        The regular expression defined with Xerox transducer notation.
    * `kwargs` :
        Arguments recognized are: 'output' and 'definitions'.
    * `output` :
        Where warnings and errors are printed. Possible values are sys.stderr
        (the default), a StringIO or None, indicating a quiet mode.
    * `definitions` :
        A dictionary mapping variable names into transducers.


    Regular expression operators:

    ~   complement
    \   term complement
    &   intersection
    -   minus

    $.  contains once
    $?  contains optionally
    $   contains once or more
    ( ) optionality

    +   Kleene plus
    *   Kleene star

    ./. ignore internally (not yet implemented)
    /   ignoring

    |   union

    <>  shuffle
    <   before
    >   after

    .o.   composition
    .O.   lenient composition
    .m>.  merge right
    .<m.  merge left
    .x.   cross product
    .P.   input priority union
    .p.   output priority union
    .-u.  input minus
    .-l.  output minus
    `[ ]  substitute

    ^n,k  catenate from n to k times, inclusive
    ^>n   catenate more than n times
    ^>n   catenate less than n times
    ^n    catenate n times

    .r   reverse
    .i   invert
    .u   input side
    .l   output side

    \\\\\\  left quotient

    Two-level rules:

     \<=   left restriction
     <=>   left and right arrow
     <=    left arrow
     =>    right arrow

    Replace rules:

     ->    replace right
     (->)  optionally replace right
     <-    replace left
     (<-)  optionally replace left
     <->   replace left and right
     (<->) optionally replace left and right
     @->   left-to-right longest match
     @>    left-to-right shortest match
     ->@   right-to-left longest match
     >@    right-to-left shortest match

    Rule contexts, markers and separators:

     ||   match contexts on input sides
     //   match left context on output side and right context on input side
     \\   match left context on input side and right context on output side
     \/   match contexts on output sides
     _    center marker
     ...  markup marker
     ,,   rule separator in parallel rules
     ,    context separator
     [. .]  match epsilons only once

    Read from file:

     @bin" "  read binary transducer
     @txt" "  read transducer in att text format
     @stxt" " read spaced text
     @pl" "   read transducer in prolog text format
     @re" "   read regular expression

    Symbols:

     .#.  word boundary symbol in replacements, restrictions
     0    the epsilon
     ?    any token
     %    escape character
     { }  concatenate symbols
     " "  quote symbol

    :    pair separator
    ::   weight

    ;   end of expression
    !   starts a comment until end of line
#   starts a comment until end of line
    """
    type_ = get_default_fst_type()
    defs=None
    import sys
    output=sys.stderr

    for k,v in kwargs.items():
      if k == 'output':
          output=v;
      elif k == 'definitions':
          defs=v;
      else:
        print('Warning: ignoring unknown argument %s.' % (k))

    comp = XreCompiler(type_)
    if not defs == None:
        for k,v in defs.items():
            vtype = str(type(v))
            if "HfstTransducer" in vtype:
                comp.define_transducer(k,v)
# print('defining transducer')
            else:
                pass

    comp.set_verbosity((output != None))
    if 'StringIO' in str(type(output)):
        retval = comp.compile_iostream(re)
        output.write(retval[1])
        return retval[0]
    else:
        return comp.compile(re)

def _replace_symbols(symbol, epsilonstr=EPSILON):
    if symbol == epsilonstr:
       return EPSILON
    if symbol == "@0@":
       return EPSILON
    symbol = symbol.replace("@_SPACE_@", " ")
    symbol = symbol.replace("@_TAB_@", "\t")
    symbol = symbol.replace("@_COLON_@", ":")
    return symbol

def _parse_att_line(line, fsm, epsilonstr=EPSILON):
# get rid of extra whitespace
    line = line.replace('\t',' ')
    line = " ".join(line.split())
    fields = line.split(' ')
    try:
        if len(fields) == 1:
           if fields[0] == '': # empty transducer...
               return True
           fsm.add_state(int(fields[0]))
           fsm.set_final_weight(int(fields[0]), 0)
        elif len(fields) == 2:
           fsm.add_state(int(fields[0]))
           fsm.set_final_weight(int(fields[0]), float(fields[1]))
        elif len(fields) == 4:
           fsm.add_transition(int(fields[0]), int(fields[1]), _replace_symbols(fields[2]), _replace_symbols(fields[3]), 0)
        elif len(fields) == 5:
           fsm.add_transition(int(fields[0]), int(fields[1]), _replace_symbols(fields[2]), _replace_symbols(fields[3]), float(fields[4]))
        else:
           return False
    except ValueError as e:
        return False
    return True

def read_att_string(att):
    """
    Create a transducer as defined in AT&T format in *att*.
    """
    linecount = 0
    fsm = HfstIterableTransducer()
    lines = att.split('\n')
    for line in lines:
        linecount = linecount + 1
        if not _parse_att_line(line, fsm):
           raise NotValidAttFormatException(line, "", linecount)
    return HfstTransducer(fsm, get_default_fst_type())

def read_att_input():
    """
    Create a transducer as defined in AT&T format in user input.
    An empty line signals the end of input.
    """
    linecount = 0
    fsm = HfstIterableTransducer()
    while True:
        line = input().rstrip()
        if line == "":
           break
        linecount = linecount + 1
        if not _parse_att_line(line, fsm):
           raise NotValidAttFormatException(line, "", linecount)
    return HfstTransducer(fsm, get_default_fst_type())

def read_att_transducer(f, epsilonstr=EPSILON, linecount=[0]):
    """
    Create a transducer as defined in AT&T format in file *f*. *epsilonstr*
    defines how epsilons are represented. *linecount* keeps track of the current
    line in the file.
    """
    linecount_ = 0
    fsm = HfstIterableTransducer()
    while True:
        line = f.readline()
        if line == "":
           if linecount_ == 0:
              raise EndOfStreamException("","",0)
           else:
              linecount_ = linecount_ + 1
              break
        linecount_ = linecount_ + 1
        if line[0] == '-':
           break
        if not _parse_att_line(line, fsm, epsilonstr):
           raise NotValidAttFormatException(line, "", linecount[0] + linecount_)
    linecount[0] = linecount[0] + linecount_
    return HfstTransducer(fsm, get_default_fst_type())

class AttReader:
      """
      A class for reading input in AT&T text format and converting it into
      transducer(s).

      An example that reads AT&T input from file 'testfile.att' where epsilon is
      represented as \"<eps>\" and creates the corresponding transducers and prints
      them. If the input cannot be parsed, a message showing the invalid line in AT&T
      input is printed and reading is stopped.

      with open('testfile.att', 'r') as f:
           try:
                r = hfst_dev.AttReader(f, \"<eps>\")
                for tr in r:
                    print(tr)
           except hfst_dev.exceptions.NotValidAttFormatException as e:
                print(e.what())
      """
      def __init__(self, f, epsilonstr=EPSILON):
          """
          Create an AttReader that reads input from file *f* where the epsilon is
          represented as *epsilonstr*.

          Parameters
          ----------
          * `f` :
              A python file.
          * `epsilonstr` :
              How epsilon is represented in the file. By default, \"@_EPSILON_SYMBOL_@\"
              and \"@0@\" are both recognized.
          """
          self.file = f
          self.epsilonstr = epsilonstr
          self.linecount = [0]

      def read(self):
          """
          Read next transducer.

          Read next transducer description in AT&T format and return a corresponding
          transducer.

          Exceptions
          ----------
          * `hfst_dev.exceptions.NotValidAttFormatException` :
          * `hfst_dev.exceptions.EndOfStreamException` :
          """
          return read_att_transducer(self.file, self.epsilonstr, self.linecount)

      def __iter__(self):
          """
          An iterator to the reader.

          Needed for 'for ... in' statement.

          for transducer in att_reader:
              print(transducer)
          """
          return self

      def next(self):
          """
          Return next element (for python version 3).

          Needed for 'for ... in' statement.

          for transducer in att_reader:
              print(transducer)

          Exceptions
          ----------
          * `StopIteration` :
          """
          try:
             return self.read()
          except EndOfStreamException as e:
             raise StopIteration

      def __next__(self):
          """
          Return next element (for python version 2).

          Needed for 'for ... in' statement.

          for transducer in att_reader:
              print(transducer)

          Exceptions
          ----------
          * `StopIteration` :
          """
          return self.next()

def read_prolog_transducer(f, linecount=[0]):
    """
    Create a transducer as defined in prolog format in file *f*. *linecount*
    keeps track of the current line in the file.
    """
    linecount_ = 0
    fsm = HfstIterableTransducer()

    line = ""
    while(True):
        line = f.readline()
        linecount_ = linecount_ + 1
        if line == "":
            raise EndOfStreamException("","",linecount[0] + linecount_)
        line = line.rstrip()
        if line == "":
            pass # allow extra prolog separator(s)
        if line[0] == '#':
            pass # comment line
        else:
            break

    if not _libhfst_dev._parse_prolog_network_line(line, fsm):
        raise NotValidPrologFormatException(line,"",linecount[0] + linecount_)

    while(True):
        line = f.readline()
        if (line == ""):
            retval = HfstTransducer(fsm, get_default_fst_type())
            retval.set_name(fsm.name)
            linecount[0] = linecount[0] + linecount_
            return retval
        line = line.rstrip()
        linecount_ = linecount_ + 1
        if line == "":  # prolog separator
            retval = HfstTransducer(fsm, get_default_fst_type())
            retval.set_name(fsm.name)
            linecount[0] = linecount[0] + linecount_
            return retval
        if _libhfst_dev._parse_prolog_arc_line(line, fsm):
            pass
        elif _libhfst_dev._parse_prolog_final_line(line, fsm):
            pass
        elif _libhfst_dev._parse_prolog_symbol_line(line, fsm):
            pass
        else:
            raise NotValidPrologFormatException(line,"",linecount[0] + linecount_)

class PrologReader:
      """
      A class for reading input in prolog text format and converting it into
      transducer(s).

      An example that reads prolog input from file 'testfile.prolog' and creates the
      corresponding transducers and prints them. If the input cannot be parsed, a
      message showing the invalid line in prolog input is printed and reading is
      stopped.

          with open('testfile.prolog', 'r') as f:
              try:
                 r = hfst_dev.PrologReader(f)
                 for tr in r:
                     print(tr)
              except hfst_dev.exceptions.NotValidPrologFormatException as e:
                  print(e.what())
      """
      def __init__(self, f):
          """
          Create a PrologReader that reads input from file *f*.

          Parameters
          ----------
          * `f` :
              A python file.
          """
          self.file = f
          self.linecount = [0]

      def read(self):
          """

          Read next transducer.

          Read next transducer description in prolog format and return a corresponding
          transducer.

          Exceptions
          ----------
          * `hfst_dev.exceptions.NotValidPrologFormatException` :
          * `hfst_dev.exceptions.EndOfStreamException` :
          """
          return read_prolog_transducer(self.file, self.linecount)

      def __iter__(self):
          """
          An iterator to the reader.

          Needed for 'for ... in' statement.

          for transducer in prolog_reader:
              print(transducer)
          """
          return self

      def next(self):
          """
          Return next element (for python version 2).

          Needed for 'for ... in' statement.

          for transducer in prolog_reader:
              print(transducer)

          Exceptions
          ----------
          * `StopIteration` :
          """
          try:
             return self.read()
          except EndOfStreamException as e:
             raise StopIteration

      def __next__(self):
          """
          Return next element (for python version 2).

          Needed for 'for ... in' statement.

          for transducer in prolog_reader:
              print(transducer)

          Exceptions
          ----------
          * `StopIteration` :
          """
          return self.next()

def compile_xfst_file(filename, **kwargs):
    """
    Compile (run) xfst.

    Parameters
    ----------
    * `filename` :
        The name of the xfst file.
    * `kwargs` :
        Arguments recognized are: verbosity, quit_on_fail, output, type.
    * `verbosity` :
        The verbosity of the compiler, defaults to 0 (silent). Possible values are:
        0, 1, 2.
    * `quit_on_fail` :
        Whether the script is exited on any error, defaults to True.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringIO, sys.stdout being the default.
    * `type` :
        Implementation type of the compiler, defaults to
        hfst_dev.get_default_fst_type().

    Returns
    -------
    On success 0, else an integer greater than 0.
    """
    return _compile_xfst(filename=filename, **kwargs)

def compile_xfst_script(script, **kwargs):
    """
    Compile (run) xfst.

    Parameters
    ----------
    * `script` :
        The xfst script to be compiled (a string).
    * `kwargs` :
        Arguments recognized are: verbosity, quit_on_fail, output, type.
    * `verbosity` :
        The verbosity of the compiler, defaults to 0 (silent). Possible values are:
        0, 1, 2.
    * `quit_on_fail` :
        Whether the script is exited on any error, defaults to True.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringIO, sys.stdout being the default.
    * `type` :
        Implementation type of the compiler, defaults to
        hfst_dev.get_default_fst_type().

    Returns
    -------
    On success 0, else an integer greater than 0.
    """
    return _compile_xfst(script=script, **kwargs)

def _compile_xfst(**kwargs):
    """
    Compile (run) xfst.

    Parameters
    ----------
    * `kwargs` :
        Arguments recognized are: filename, data, verbosity, quit_on_fail, output, type.
    * `filename` :
        The name of the xfst file.
    * `script` :
        The xfst script to be compiled (a string).
    * `verbosity` :
        The verbosity of the compiler, defaults to 0 (silent). Possible values are:
        0, 1, 2.
    * `quit_on_fail` :
        Whether the script is exited on any error, defaults to True.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringIO, sys.stdout being the default.
    * `type` :
        Implementation type of the compiler, defaults to
        hfst_dev.get_default_fst_type().

    Returns
    -------
    On success 0, else an integer greater than 0.
    """
    if int(version[0]) > 2:
      pass
    else:
      raise RuntimeError('hfst_dev.compile_xfst_file not supported for python version 2')
    verbosity=0
    quit_on_fail='ON'
    type = get_default_fst_type()
    import sys
    output=sys.stdout
    filename=None
    script=None

    for k,v in kwargs.items():
      if k == 'verbosity':
        verbosity=v
      elif k == 'quit_on_fail':
        if v == False:
          quit_on_fail='OFF'
      elif k == 'output':
          output=v
      elif k == 'filename':
          filename=v
      elif k == 'script':
          script=v
      else:
        print('Warning: ignoring unknown argument %s.' % (k))

    if verbosity > 1:
      output.write('Compiling with %s implementation...' % fst_type_to_string(type))
    xfstcomp = XfstCompiler(type)
    xfstcomp.setVerbosity(verbosity > 0)
    xfstcomp.setInspectNetSupported(False)
    xfstcomp.set('quit-on-fail', quit_on_fail)
    if filename == None:
      data = script
    else:
      if verbosity > 1:
        output.write('Opening xfst file %s...' % filename)
      f = open(filename, 'r', encoding='utf-8')
      data = f.read()
      f.close()
      if verbosity > 1:
        output.write('File closed...')

    retval = xfstcomp.parse_line(data);
#retval=-1
#retval = _libhfst_dev.hfst_compile_xfst_to_string_one(xfstcomp, data)
#output.write(unicode(_libhfst_dev.get_hfst_xfst_string_one(), 'utf-8'))

    if verbosity > 1:
      output.write('Parsed file with return value %i (0 indicating succesful parsing).' % retval)
    return retval

def compile_twolc_file(filename, **kwargs):
    """
    Compile twolc file *filename* and return the result.

    Parameters
    ----------
    * `filename` :
        The name of the twolc input file.
    * `kwargs` :
        Arguments recognized are: silent, verbose, resolve_right_conflicts, resolve_left_conflicts, type.
    * `silent` :
        Whether compilation is performed in silent mode, defaults to False.
    * `verbose` :
        Whether compilation is performed in verbose mode, defaults to False.
    * `resolve_right_conflicts` :
        Whether right arrow conflicts are resolved, defaults to True.
    * `resolve_left_conflicts` :
        Whether left arrow conflicts are resolved, defaults to False.
    * `type` :
        Implementation type of the compiler, defaults to hfst_dev.get_default_fst_type().

    Returns
    -------
    The compiled rules.
    """
    return _compile_twolc(filename=filename, **kwargs)

def compile_twolc_script(script, **kwargs):
    """
    Compile twolc script *script* and return the result.

    Parameters
    ----------
    * `script` :
        The twolc script.
    * `kwargs` :
        Arguments recognized are: silent, verbose, resolve_right_conflicts, resolve_left_conflicts, type.
    * `silent` :
        Whether compilation is performed in silent mode, defaults to False.
    * `verbose` :
        Whether compilation is performed in verbose mode, defaults to False.
    * `resolve_right_conflicts` :
        Whether right arrow conflicts are resolved, defaults to True.
    * `resolve_left_conflicts` :
        Whether left arrow conflicts are resolved, defaults to False.
    * `type` :
        Implementation type of the compiler, defaults to hfst_dev.get_default_fst_type().

    Returns
    -------
    A tuple containing the compiled rules.
    """
    return _compile_twolc(script=script, **kwargs)

def _compile_twolc(**kwargs):
    """
    Compile twolc script *script* and return the result.

    Parameters
    ----------
    * `kwargs` :
        Arguments recognized are: script, inputfilename, silent, verbose, resolve_right_conflicts, resolve_left_conflicts, type.
    * `script` :
        The twolc script.
    * `filename` :
        The name of the twolc input file.
    * `silent` :
        Whether compilation is performed in silent mode, defaults to False.
    * `verbose` :
        Whether compilation is performed in verbose mode, defaults to False.
    * `resolve_right_conflicts` :
        Whether right arrow conflicts are resolved, defaults to True.
    * `resolve_left_conflicts` :
        Whether left arrow conflicts are resolved, defaults to False.
    * `type` :
        Implementation type of the compiler, defaults to hfst_dev.get_default_fst_type().

    Returns
    -------
    A tuple containing the compiled rules.
    """
    script=None
    filename=None
    silent=False
    verbose=False
    resolve_right_conflicts=True
    resolve_left_conflicts=False
    implementation_type=get_default_fst_type()

    for k,v in kwargs.items():
        if k == 'script':
            script = v
        elif k == 'filename':
            filename = v
        elif k == 'type':
            implementation_type = v
        elif k == 'silent':
            silent=v
        elif k == 'verbose':
            verbose=v
        elif k == 'resolve_right_conflicts':
            resolve_right_conflicts=v
        elif k == 'resolve_left_conflicts':
            resolve_left_conflicts=v
        else:
            print('Warning: ignoring unknown argument %s.' % (k))

    if filename == None:
        retval = TwolcCompiler.compile_script_and_get_storable_rules(script, silent, verbose,
                                                    resolve_right_conflicts, resolve_left_conflicts,
                                                    implementation_type)
    else:
        retval = TwolcCompiler.compile_file_and_get_storable_rules(filename, silent, verbose,
                                                    resolve_right_conflicts, resolve_left_conflicts,
                                                    implementation_type)
    return retval

def compile_pmatch_file(filename):
    """
    Compile pmatch expressions as defined in *filename* and return a tuple of
    transducers.

    An example:

    If we have a file named streets.txt that contains:

    define CapWord UppercaseAlpha Alpha* ; define StreetWordFr [{avenue} |
    {boulevard} | {rue}] ; define DeFr [ [{de} | {du} | {des} | {de la}] Whitespace
    ] | [{d'} | {l'}] ; define StreetFr StreetWordFr (Whitespace DeFr) CapWord+ ;
    regex StreetFr EndTag(FrenchStreetName) ;

    we can run:

    defs = hfst_dev.compile_pmatch_file('streets.txt')
    const = hfst_dev.PmatchContainer(defs)
    assert cont.match("Je marche seul dans l'avenue desTernes.") ==
      "Je marche seul dans l'<FrenchStreetName>avenue des Ternes</FrenchStreetName>."
    """
    with open(filename, 'r') as myfile:
      data=myfile.read()
      myfile.close()
    defs = compile_pmatch_expression(data)
    return defs

def compile_sfst_file(filename, **kwargs):
    """
    Compile sfst file *filename* into a transducer.

    Parameters
    ----------
    * `filename` :
        The name of the sfst file.
    * `kwargs` :
        Arguments recognized are: verbose, output.
    * `verbose` :
        Whether sfst file is processed in verbose mode, defaults to False.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringI0, sys.stderr being the default. TODO

    Returns
    -------
    On success the resulting transducer, else None.
    """
    verbosity=False
    type = get_default_fst_type()
    output=None

    for k,v in kwargs.items():
      if k == 'verbose':
        verbosity=v
      elif k == 'output':
          output=v
      else:
        print('Warning: ignoring unknown argument %s.' % (k))

    retval=None
    import sys
    if output == None:
       retval = _hfst_compile_sfst(filename, "", verbosity)
    elif output == sys.stdout:
       retval = libhfst_dev._hfst_compile_sfst(filename, "cout", verbosity)
    elif output == sys.stderr:
       retval = _hfst_compile_sfst(filename, "cerr", verbosity)
    else:
       retval = _hfst_compile_sfst(filename, "", verbosity)
       output.write(unicode(_get_hfst_sfst_output(), 'utf-8'))

    return retval

def _compile_lexc(**kwargs):
    """
    Compile lexc into a transducer.

    Parameters
    ----------
    * `kwargs` :
        Arguments recognized are: filenames, script, verbosity, with_flags, output.
    * `filenames` :
        The names of the lexc files.
    * `script` :
        The lexc script to be compiled (a string).
    * `verbosity` :
        The verbosity of the compiler, defaults to 0 (silent). Possible values are:
        0, 1, 2.
    * `with_flags` :
        Whether lexc flags are used when compiling, defaults to False.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringIO, sys.stderr being the default.

    Returns
    -------
    On success the resulting transducer, else None.
    """
    verbosity=0
    withflags=False
    alignstrings=False
    type = get_default_fst_type()
    import sys
    output=sys.stderr
    filenames=None
    script=None

    for k,v in kwargs.items():
      if k == 'verbosity':
        verbosity=v
      elif k == 'with_flags':
        if v == True:
          withflags = v
      elif k == 'align_strings':
          alignstrings = v
      elif k == 'output':
          output=v
      elif k == 'filenames':
          filenames=v
      elif k == 'script':
          script=v

      else:
        print('Warning: ignoring unknown argument %s.' % (k))

    lexccomp = LexcCompiler(type, withflags, alignstrings)
    lexccomp.setVerbosity(verbosity)

    retval=-1
    if filenames == None:
        lexccomp.parse_line(script)
        retval = lexccomp.compileLexical()
#retval = hfst_compile_lexc_script(lexccomp, script, "")
#output.write(unicode(get_hfst_lexc_output(), 'utf-8'))
    else:
        for filename in filenames:
            lexccomp.parse(filename)
        retval = lexccomp.compileLexical()
#retval = hfst_compile_lexc_files(lexccomp, filenames, "")
#output.write(unicode(get_hfst_lexc_output(), 'utf-8'))

    return retval

def compile_lexc_file(filename, **kwargs):
    """
    Compile lexc file *filename* or into a transducer.

    Parameters
    ----------
    * `filename` :
        The name of the lexc file.
    * `kwargs` :
        Arguments recognized are: verbosity, with_flags, output.
    * `verbosity` :
        The verbosity of the compiler, defaults to 0 (silent). Possible values are:
        0, 1, 2.
    * `with_flags` :
        Whether lexc flags are used when compiling, defaults to False.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringIO, sys.stderr being the default.

    Returns
    -------
    On success the resulting transducer, else None.
    """
    return _compile_lexc(filenames=(filename,), **kwargs)

def compile_lexc_files(filenames, **kwargs):
    """
    Compile lexc files *filenames* or into a transducer.

    Parameters
    ----------
    * `filenames` :
        The list of lexc filenames.
    * `kwargs` :
        Arguments recognized are: verbosity, with_flags, output.
    * `verbosity` :
        The verbosity of the compiler, defaults to 0 (silent). Possible values are:
        0, 1, 2.
    * `with_flags` :
        Whether lexc flags are used when compiling, defaults to False.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringIO, sys.stderr being the default.

    Returns
    -------
    On success the resulting transducer, else None.
    """
    return _compile_lexc(filenames=filenames, **kwargs)

def compile_lexc_script(script, **kwargs):
    """
    Compile lexc script *script* into a transducer.

    Parameters
    ----------
    * `script` :
        The lexc script to be compiled (a string).
    * `kwargs` :
        Arguments recognized are: verbosity, with_flags, output.
    * `verbosity` :
        The verbosity of the compiler, defaults to 0 (silent). Possible values are:
        0, 1, 2.
    * `with_flags` :
        Whether lexc flags are used when compiling, defaults to False.
    * `output` :
        Where output is printed. Possible values are sys.stdout, sys.stderr, a
        StringIO, sys.stderr being the default.

    Returns
    -------
    On success the resulting transducer, else None.
    """
    return _compile_lexc(script=script, **kwargs)

def _is_weighted_word(arg):
    if isinstance(arg, tuple) and len(arg) == 2 and isinstance(arg[0], str) and isinstance(arg[1], (int, float)):
       return True
    return False

def _check_word(arg):
    if len(arg) == 0:
       raise RuntimeError('Empty word.')
    return arg

def fsa(arg):
    """
    Get a transducer (automaton in this case) that recognizes one or more paths.

    Parameters
    ----------
    * `arg` :
        See example below

    Possible inputs:

      One unweighted identity path:
        'foo'  ->  [f o o]

      Weighted path: a tuple of string and number, e.g.
        ('foo',1.4)
        ('bar',-3)
        ('baz',0)

      Several paths: a list or a tuple of paths and/or weighted paths, e.g.
        ['foo', 'bar']
        ('foo', ('bar',5.0))
        ('foo', ('bar',5.0), 'baz', 'Foo', ('Bar',2.4))
        [('foo',-1), ('bar',0), ('baz',3.5)]

    """
    deftok = HfstTokenizer()
    retval = HfstIterableTransducer()
    if isinstance(arg, str):
       if len(arg) == 0:
           retval.set_final_weight(0, 0) # epsilon transducer with zero weight
       else:
           retval.disjunct(deftok.tokenize(_check_word(arg)), 0)
    elif _is_weighted_word(arg):
       if len(arg) == 0:
           retval.set_final_weight(0, arg[1]) # epsilon transducer with weight
       else:
           retval.disjunct(deftok.tokenize(_check_word(arg[0])), arg[1])
    elif isinstance(arg, tuple) or isinstance(arg, list):
       for word in arg:
           if _is_weighted_word(word):
              if len(word) == 0:
                  retval.set_final_weight(0, word[1]) # epsilon transducer with weight
              else:
                  retval.disjunct(deftok.tokenize(_check_word(word[0])), word[1])
           elif isinstance(word, str):
              if len(word) == 0:
                  retval.set_final_weight(0, 0) # epsilon transducer with zero weight
              else:
                  retval.disjunct(deftok.tokenize(_check_word(word)), 0)
           else:
              raise RuntimeError('Tuple/list element not a string or tuple of string and weight.')
    else:
       raise RuntimeError('Not a string or tuple/list of strings.')
    return HfstTransducer(retval, get_default_fst_type())

def fst(arg):
    """
    Get a transducer that recognizes one or more paths.

    Parameters
    ----------
    * `arg` :
        See example below

    Possible inputs:

      One unweighted identity path:
        'foo'  ->  [f o o]

      Weighted path: a tuple of string and number, e.g.
        ('foo',1.4)
        ('bar',-3)
        ('baz',0)

      Several paths: a list or a tuple of paths and/or weighted paths, e.g.
        ['foo', 'bar']
        ('foo', ('bar',5.0))
        ('foo', ('bar',5.0), 'baz', 'Foo', ('Bar',2.4))
        [('foo',-1), ('bar',0), ('baz',3.5)]

      A dictionary mapping strings to any of the above cases:
        {'foo':'foo', 'bar':('foo',1.4), 'baz':(('foo',-1),'BAZ')}
    """
    if isinstance(arg, dict):
       retval = regex('[0-0]') # empty transducer
       for input, output in arg.items():
           if not isinstance(input, str):
              raise RuntimeError('Key not a string.')
           left = fsa(input)
           right = 0
           if isinstance(output, str):
              right = fsa(output)
           elif isinstance(output, list) or isinstance(output, tuple):
              right = fsa(output)
           else:
              raise RuntimeError('Value not a string or tuple/list of strings.')
           left.cross_product(right)
           retval.disjunct(left)
       return retval
    return fsa(arg)

def fst_to_fsa(fst, separator=''):
    """
    (Experimental)

    Encode a transducer into an automaton, i.e. create a transducer where each
    transition <in:out> of *fst* is replaced with a transition <inSout:inSout>
    where 'S' is *separator*, except if the transition symbol on both sides is
    hfst_dev.EPSILON, hfst_dev.IDENTITY or hfst_dev.UNKNOWN.

    All states and weights of transitions and end states are copied otherwise
    as such. The alphabet is copied, and new symbols which are created when
    encoding the transitions, are inserted to it.

    Parameters
    ----------
    * `fst` :
        The transducer.
    * `separator` :
        The separator symbol inserted between input and output symbols.

    Examples:

        import hfst
        foo2bar = hfst_dev.fst({'foo':'bar'})

    creates a transducer [f:b o:a o:r]. Calling

        foobar = hfst_dev.fst_to_fsa(foo2bar)

    will create the transducer [fb:fb oa:oa or:or] and

        foobar = hfst_dev.fst_to_fsa(foo2bar, '^')

    the transducer [f^b:f^b o^a:o^a o^r:o^r].

    """
    encoded_symbols = StringSet()
    retval = HfstIterableTransducer(fst)
    for state in retval.states():
        arcs = retval.transitions(state)
        for arc in arcs:
            input = arc.get_input_symbol()
            output = arc.get_output_symbol()
            if (input == output) and ((input == EPSILON) or (input == UNKNOWN) or (input == IDENTITY)):
                continue
            symbol = input + separator + output
            arc.set_input_symbol(symbol)
            arc.set_output_symbol(symbol)
            encoded_symbols.insert(symbol)
    retval.add_symbols_to_alphabet(encoded_symbols)
    if 'HfstTransducer' in str(type(fst)):
        return HfstTransducer(retval)
    else:
        return retval

def fsa_to_fst(fsa, separator=''):
    """
    (Experimental)

    Decode an encoded automaton back into a transducer, i.e. create a
    transducer where each transition <inSout:inSout> of *fsa*, where 'S' is
    the first *separator* found in the compound symbol 'inSout', is replaced
    with a transition <in:out>.

    If no *separator* is found in the symbol, transition is copied as such. All
    states and weights of transitions and end states are copied as such. The
    alphabet is copied, omitting encoded symbols which were decoded according
    to *separator*. Any new input and output symbols extracted from encoded
    symbols are added to the alphabet.

    If *separator* is the empty string, 'in' must either be single-character
    symbol or a special symbol of form '@...@'.

    Parameters
    ----------
    * `fsa` :
        The encoded transducer. Must be an automaton, i.e. for each
        transition, the input and output symbols must be the same. Else, a
        RuntimeError is thrown.
    * `separator` :
        The symbol separating input and output symbol parts in *fsa*. If it is
        the empty string, each encoded transition symbol is must be of form
        'x...' (single-character input symbol 'x') or '@...@...' (special
        symbol as input symbol). Else, a RuntimeError is thrown.

    Examples:

        import hfst
        foo2bar = hfst_dev.fst({'foo':'bar'})  # creates transducer [f:b o:a o:r]
        foobar = hfst_dev.fst_to_fsa(foo2bar, '^')

    creates the transducer [f^b:f^b o^a:o^a o^r:o^r]. Then calling

        foo2bar = hfst_dev.fsa_to_fst(foobar, '^')

    will create again the original transducer [f:b o:a o:r].
    """
    retval = HfstIterableTransducer(fsa)
    encoded_symbols = StringSet()
    for state in retval.states():
        arcs = retval.transitions(state)
        for arc in arcs:
            input = arc.get_input_symbol()
            output = arc.get_output_symbol()
            symbols = []
            if not (input == output):
                raise RuntimeError('Transition input and output symbols differ.')
            if input == "":
                raise RuntimeError('Transition symbol cannot be the empty string.')
# separator given:
            if len(separator) > 0:
                symbols = input.split(separator, 1)
# no separator given:
            else:
                index = input.find('@')
                if not index == 0:
                    symbols.append(input[0])
                    if not input[1] == '':
                        symbols.append(input[1:])
                else:
                    index = input.find('@', 1)
                    if index == -1:
                        raise RuntimeError('Transition symbol cannot have only one "@" sign.')
                    symbols.append(input[0:index+1])
                    if not input[index+1] == '':
                        symbols.append(input[index+1:])
            arc.set_input_symbol(symbols[0])
            arc.set_output_symbol(symbols[-1])
# encoded symbol to be removed from alphabet of result
            if len(symbols) > 1:
                encoded_symbols.insert(input)
    retval.remove_symbols_from_alphabet(encoded_symbols)
    if 'HfstTransducer' in str(type(fsa)):
        return HfstTransducer(retval)
    else:
        return retval

def tokenized_fst(arg, weight=0):
    """
    Get a transducer that recognizes the concatenation of symbols or symbol pairs in
    *arg*.

    Parameters
    ----------
    * `arg` :
        The symbols or symbol pairs that form the path to be recognized.

    Example

       import hfst
       tok = hfst_dev.HfstTokenizer()
       tok.add_multichar_symbol('foo')
       tok.add_multichar_symbol('bar')
       tr = hfst_dev.tokenized_fst(tok.tokenize('foobar', 'foobaz'))

    will create the transducer [foo:foo bar:b 0:a 0:z].
    """
    retval = HfstIterableTransducer()
    state = 0
    if isinstance(arg, list) or isinstance(arg, tuple):
       for token in arg:
           if isinstance(token, str):
              new_state = retval.add_state()
              retval.add_transition(state, new_state, token, token, 0)
              state = new_state
           elif isinstance(token, list) or isinstance(token, tuple):
              if len(token) == 2:
                 new_state = retval.add_state()
                 retval.add_transition(state, new_state, token[0], token[1], 0)
                 state = new_state
              elif len(token) == 1:
                 new_state = retval.add_state()
                 retval.add_transition(state, new_state, token, token, 0)
                 state = new_state
              else:
                 raise RuntimeError('Symbol or symbol pair must be given.')
       retval.set_final_weight(state, weight)
       return HfstTransducer(retval, get_default_fst_type())
    else:
       raise RuntimeError('Argument must be a list or a tuple')

def empty_fst():
    """
    Get an empty transducer.

    Empty transducer has one state that is not final, i.e. it does not recognize any
    string.
    """
    return regex('[0-0]')

def epsilon_fst(weight=0):
    """
    Get an epsilon transducer.

    Parameters
    ----------
    * `weight` :
        The weight of the final state. Epsilon transducer has one state that is
        final (with final weight *weight*), i.e. it recognizes the empty string.
    """
    return regex('[0]::' + str(weight))

def concatenate(transducers):
    """
    Return a concatenation of *transducers*.
    """
    retval = epsilon_fst()
    for tr in transducers:
      retval.concatenate(tr)
    retval.minimize()
    return retval

def disjunct(transducers):
    """
    Return a disjunction of *transducers*.
    """
    retval = empty_fst()
    for tr in transducers:
      retval.disjunct(tr)
    retval.minimize()
    return retval

def intersect(transducers):
    """
    Return an intersection of *transducers*.
    """
    retval = None
    for tr in transducers:
      if retval == None:
        retval = HfstTransducer(tr)
      else:
        retval.intersect(tr)
    retval.minimize()
    return retval

def subtract(transducers):
    """
    Return a subtraction of *transducers*.
    """
    retval = None
    for tr in transducers:
      if retval == None:
        retval = HfstTransducer(tr)
      else:
        retval.subtract(tr)
    retval.minimize()
    return retval

def compose(transducers):
    """
    Return a composition of *transducers*.
    """
    retval = None
    for tr in transducers:
        if retval == None:
            retval = HfstTransducer(tr)
        else:
            retval.compose(tr)
    retval.minimize()
    return retval

def cross_product(transducers):
    """
    Return a cross product of *transducers*.
    """
    retval = None
    for tr in transducers:
        if retval == None:
            retval = HfstTransducer(tr)
        else:
            retval.cross_product(tr)
    retval.minimize()
    return retval


# This file is compatible with both classic and new-style classes.


