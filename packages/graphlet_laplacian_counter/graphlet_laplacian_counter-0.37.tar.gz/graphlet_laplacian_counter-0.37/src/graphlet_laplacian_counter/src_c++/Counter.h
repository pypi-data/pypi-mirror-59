#ifndef NCOUNT_FOR_GRAPHLET_LAPLACIAN_H
#define NCOUNT_FOR_GRAPHLET_LAPLACIAN_H

/* this is the file known as 'ncount_huge.cpp' in /Past_Members/Oleksii/Uncategorized/Research/ncount/ncount_huge

/* ncount.cpp by Jason Lai based on code by Natasa Przulj  */
/* Modified by Oleksii to keep large variable on heap rather than stack, so that */
/* it can actually process big networks. Also this can be compiled for windows */
/* Modified to use bit vectors (8-times less memory) in adjacency matrix by Wayne Hayes, 16 May 2009 */
/* Modified to use maps (sparse) for adjacency matrix by Wayne Hayes, 16 May 2009 */
/* suggested g++-3.4 compile flags: -O3 -funroll-loops     */
/* Usage: ncount <input graph> <output prefix>
 * Counts graphlets and graphlet degrees (called node classes here)
 *
 * Basic algorithm: Brute force enumeration of 3-5 node connected subgraphs
 *   With some overlap that needs to be factored out later.
 *
 * Process is:
 *   Pick node A, pick a node B adj to A, pick a node C adj to B, pick a
 *   node D adj to C, pick a node E adj to D. And each node can only
 *   appear once in the subgraph.
 *
 *   Use a separate process for graphlets containing the claw, by picking
 *   a center node and then picking the rest.
 *
 *   Examine the edges between them to determine which graphlet the
 *   subgraph corresponds to. Classify each node in the graphlet and add
 *   it to the count for that graphlet type.
 *
 *   At the end, divide out the overcount and print out how many
 *   graphlets touch at the same node class/type.
 */

// set this to 1 if normal ncount runs out of memory, but be warned
// it makes ncount run 10-20 times slower.
#define HUGE_GRAPHS 0

#include <time.h> //Oleksii
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <map>        /* STL ordered dictionary class */
#include "Lcount3DArray.h"
#include "Lcount3DSparse.h"
#include "Lcount3DVector.h"
#include "Graph.h"
#include <string.h>

#define PROGRESS_INFO 0 /* Print status to stdout */
/* These lookup tables were generated by analyzing sample graphs representing
 * each graphlet, and then adjusting the table sizes for perfect hashing.
 */

/* Lookup table for graphlets. Calculated by:
 * [(sum of (degree % 4 for node/neighbors))/2][edge count/2]-4
 * Special handling needed for X23 and X25
 */
const char gtable [][8] =
        {{-1,-1,10,-1,-1,8},{-1,11,-1,-1,15,14,12},{17,19,-1,16,18,20},
         {-1,-1,23,24,-1,21},{-1,-1,26,25},{-1,-1,-1,-1,-1,-1,27},{28}};

/* Lookup table for nodes by [graphlet][sum of degrees of node/neighbors] */
const char ntable [][21] =
        {{-1,-1,-1,0,1},{-1,-1,-1,-1,-1,-1,2},{-1,-1,-1,3,-1,4},{-1,-1,-1,-1,5,-1,6},
         {-1,-1,-1,-1,-1,-1,7},{-1,-1,-1,-1,8,-1,-1,9,10},
         {-1,-1,-1,-1,-1,-1,-1,-1,11,-1,12},{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,13},
         {-1,-1,-1,14,-1,15,16},{-1,-1,-1,17,18,-1,19,20},{-1,-1,-1,-1,-1,21,-1,-1,22},
         {-1,-1,-1,-1,23,-1,-1,-1,24,25},{-1,-1,-1,26,-1,-1,27,28,-1,29},
         {-1,-1,-1,-1,-1,30,-1,-1,31,-1,32},{-1,-1,-1,-1,-1,-1,33},
         {-1,-1,-1,-1,34,-1,35,36,37},{-1,-1,-1,-1,-1,38,-1,-1,-1,39,-1,40,41},
         {-1,-1,-1,-1,-1,-1,-1,-1,42,-1,-1,-1,43},{-1,-1,-1,-1,44,-1,-1,-1,45,-1,46,47},
         {-1,-1,-1,-1,-1,-1,-1,-1,48,49},{-1,-1,-1,-1,-1,-1,-1,50,51,-1,52},
         {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,53,-1,-1,-1,54},
         {-1,-1,-1,-1,-1,55,-1,-1,-1,-1,-1,-1,-1,56,57},
         {-1,-1,-1,-1,-1,-1,-1,-1,-1,58,-1,-1,59,-1,60},
         {-1,-1,-1,-1,-1,-1,-1,-1,61,-1,-1,62,63},
         {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,64,-1,-1,-1,65,-1,66},
         {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,67,-1,-1,68},
         {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,69,-1,-1,70},
         {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,71}};


/* klcount: ratio of number of nodes of this type to number of graphlets */
const int klcount[] = {2, 1, 3, 2, 2, 3, 1, 4, 1, 2, 1, 2, 2, 4, 2, 2, 1, 1, 2, 1,
                 1, 4, 1, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 5, 1, 1, 2, 1, 1, 2,
                 1, 1, 4, 1, 1, 1, 1, 2, 3, 2, 2, 1, 2, 3, 2, 1, 3, 1, 2, 2,
                 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 3, 5};

enum {P3_A, P3_B, C3_A, P4_A, P4_B, CLAW_A, CLAW_B, C4_A, FLOW_A, FLOW_B,
    FLOW_C, DIAM_A, DIAM_B, K4_A, P5_A, P5_B, P5_C,
    X10_A, X10_B, X10_C, X10_D, X11_A, X11_B, X12_A, X12_B, X12_C, X13_A,
    X13_B, X13_C, X13_D, X14_A, X14_B, X14_C, C5_A, X16_A, X16_B, X16_C,
    X16_D, X17_A, X17_B, X17_C, X17_D, X18_A, X18_B, X19_A, X19_B, X19_C,
    X19_D, X20_A, X20_B, X21_A, X21_B, X21_C, X22_A, X22_B, X23_A, X23_B,
    X23_C, X24_A, X24_B, X24_C, X25_A, X25_B, X25_C, X26_A, X26_B, X26_C,
    X27_A, X27_B, X28_A, X28_B, K5_A};

class Counter{

public:

    Counter()  {};
    std::vector<std::vector<std::vector<double> > > count_from_vectors(std::vector<int> src_nodes, std::vector<int> dst_nodes);
    std::vector<std::vector<std::vector<double> > > count_from_vectors_single_node(std::vector<int> src_nodes, std::vector<int> dst_nodes, int node);

    Lcount3D& count(Graph& g, bool five_nodes, std::string output_prefix);

private:

    Lcount3D& count_subroutine(Graph& g, Lcount3D &laplacians, bool five_nodes, std::vector<int> nodes_to_run= std::vector<int>());

};

#endif
