
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>tlslite.recordlayer module &#8212; tlslite-ng 0.8.0-alpha36 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-tlslite.recordlayer">
<span id="tlslite-recordlayer-module"></span><h1>tlslite.recordlayer module<a class="headerlink" href="#module-tlslite.recordlayer" title="Permalink to this headline">¶</a></h1>
<p>Implementation of the TLS Record Layer protocol</p>
<dl class="class">
<dt id="tlslite.recordlayer.ConnectionState">
<em class="property">class </em><code class="descclassname">tlslite.recordlayer.</code><code class="descname">ConnectionState</code><a class="headerlink" href="#tlslite.recordlayer.ConnectionState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Preserve the connection state for reading and writing data to records</p>
<dl class="method">
<dt id="tlslite.recordlayer.ConnectionState.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.ConnectionState.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an instance with empty encryption and MACing contexts</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.ConnectionState.getSeqNumBytes">
<code class="descname">getSeqNumBytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.ConnectionState.getSeqNumBytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return encoded sequence number and increment it.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tlslite.recordlayer.RecordLayer">
<em class="property">class </em><code class="descclassname">tlslite.recordlayer.</code><code class="descname">RecordLayer</code><span class="sig-paren">(</span><em>sock</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implementation of TLS record layer protocol</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="#tlslite.recordlayer.RecordLayer.version" title="tlslite.recordlayer.RecordLayer.version"><strong>version</strong></a> – the TLS version to use (tuple encoded as on the wire)</li>
<li><strong>sock</strong> – underlying socket</li>
<li><strong>client</strong> – whether the connection should use encryption</li>
<li><strong>handshake_finished</strong> – used in SSL2, True if handshake protocol is over</li>
<li><a class="reference internal" href="#tlslite.recordlayer.RecordLayer.tls13record" title="tlslite.recordlayer.RecordLayer.tls13record"><strong>tls13record</strong></a> – if True, the record layer will use the TLS 1.3 version
and content type hiding</li>
<li><a class="reference internal" href="#tlslite.recordlayer.RecordLayer.early_data_ok" title="tlslite.recordlayer.RecordLayer.early_data_ok"><strong>early_data_ok</strong></a> (<em>bool</em>) – if True, it’s ok to ignore undecryptable records
up to the size of max_early_data (sum of payloads)</li>
<li><strong>max_early_data</strong> (<em>int</em>) – maximum number of bytes that will be processed
before aborting the connection on data that can not be validated,
works only if early_data_ok is set to True</li>
<li><strong>padding_cb</strong> (<em>callable</em>) – callback used for calculating the size of
padding to add in TLSv1.3 records</li>
<li><strong>send_record_limit</strong> (<em>int</em>) – hint provided to padding callback to not
generate records larger than the receiving size expects</li>
<li><a class="reference internal" href="#tlslite.recordlayer.RecordLayer.recv_record_limit" title="tlslite.recordlayer.RecordLayer.recv_record_limit"><strong>recv_record_limit</strong></a> (<em>int</em>) – negotiated size of records we are willing to
accept, TLSRecordOverflow will be raised when records with larger
plaintext size are received (in TLS 1.3 padding is included in this
size but encrypted content type is not)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>sock</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(…) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.addPadding">
<code class="descname">addPadding</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.addPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Add padding to data so that it is multiple of block size</p>
</dd></dl>

<dl class="attribute">
<dt id="tlslite.recordlayer.RecordLayer.blockSize">
<code class="descname">blockSize</code><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.blockSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of block used by current symmetric cipher (R/O)</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.calcPendingStates">
<code class="descname">calcPendingStates</code><span class="sig-paren">(</span><em>cipherSuite</em>, <em>masterSecret</em>, <em>clientRandom</em>, <em>serverRandom</em>, <em>implementations</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.calcPendingStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Create pending states for encryption and decryption.</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.calcSSL2PendingStates">
<code class="descname">calcSSL2PendingStates</code><span class="sig-paren">(</span><em>cipherSuite</em>, <em>masterSecret</em>, <em>clientRandom</em>, <em>serverRandom</em>, <em>implementations</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.calcSSL2PendingStates" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the keys for encryption and decryption in SSLv2</p>
<p>While we could reuse calcPendingStates(), we need to provide the
key-arg data for the server that needs to be passed up to handshake
protocol.</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.calcTLS1_3KeyUpdate_reciever">
<code class="descname">calcTLS1_3KeyUpdate_reciever</code><span class="sig-paren">(</span><em>cipherSuite</em>, <em>cl_app_secret</em>, <em>sr_app_secret</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.calcTLS1_3KeyUpdate_reciever" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.calcTLS1_3KeyUpdate_sender">
<code class="descname">calcTLS1_3KeyUpdate_sender</code><span class="sig-paren">(</span><em>cipherSuite</em>, <em>cl_app_secret</em>, <em>sr_app_secret</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.calcTLS1_3KeyUpdate_sender" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.calcTLS1_3PendingState">
<code class="descname">calcTLS1_3PendingState</code><span class="sig-paren">(</span><em>cipherSuite</em>, <em>cl_traffic_secret</em>, <em>sr_traffic_secret</em>, <em>implementations</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.calcTLS1_3PendingState" title="Permalink to this definition">¶</a></dt>
<dd><p>Create pending state for encryption in TLS 1.3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cipherSuite</strong> (<em>int</em>) – cipher suite that will be used for encrypting
and decrypting data</li>
<li><strong>cl_traffic_secret</strong> (<em>bytearray</em>) – Client Traffic Secret, either
handshake secret or application data secret</li>
<li><strong>sr_traffic_secret</strong> (<em>bytearray</em>) – Server Traffic Secret, either
handshake secret or application data secret</li>
<li><strong>implementations</strong> (<em>list</em>) – list of names of implementations that
are permitted for the connection</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.calculateMAC">
<code class="descname">calculateMAC</code><span class="sig-paren">(</span><em>mac</em>, <em>seqnumBytes</em>, <em>contentType</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.calculateMAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the SSL/TLS version of a MAC</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.changeReadState">
<code class="descname">changeReadState</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.changeReadState" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the cipher state to the pending one for read operations.</p>
<p>This should be done only once after a call to
<a class="reference internal" href="#tlslite.recordlayer.RecordLayer.calcPendingStates" title="tlslite.recordlayer.RecordLayer.calcPendingStates"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calcPendingStates()</span></code></a> was
performed and directly after receiving a <code class="xref py py-class docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code>
message.</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.changeWriteState">
<code class="descname">changeWriteState</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.changeWriteState" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the cipher state to the pending one for write operations.</p>
<p>This should be done only once after a call to
<a class="reference internal" href="#tlslite.recordlayer.RecordLayer.calcPendingStates" title="tlslite.recordlayer.RecordLayer.calcPendingStates"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calcPendingStates()</span></code></a> was
performed and directly after sending a <code class="xref py py-class docutils literal notranslate"><span class="pre">ChangeCipherSpec</span></code>
message.</p>
</dd></dl>

<dl class="attribute">
<dt id="tlslite.recordlayer.RecordLayer.early_data_ok">
<code class="descname">early_data_ok</code><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.early_data_ok" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or get the state of early data acceptability.</p>
<p>If processing of the early_data records is to suceed, even if the
encryption is not correct, set this property to True. It will be
automatically reset to False as soon as a decryptable record is
processed.</p>
<p>Use max_early_data to set the limit of the total size of records
that will be processed like this.</p>
</dd></dl>

<dl class="attribute">
<dt id="tlslite.recordlayer.RecordLayer.encryptThenMAC">
<code class="descname">encryptThenMAC</code><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.encryptThenMAC" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or get the setting of Encrypt Then MAC mechanism.</p>
<p>set the encrypt-then-MAC mechanism for record
integrity for next parameter change (after CCS),
gets current state</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.getCipherImplementation">
<code class="descname">getCipherImplementation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.getCipherImplementation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the implementation used for the connection</p>
<p>‘python’ for tlslite internal implementation, ‘openssl’ for M2crypto
and ‘pycrypto’ for pycrypto
:rtype: str
:returns: Name of cipher implementation used, None if not initialised</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.getCipherName">
<code class="descname">getCipherName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.getCipherName" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of the bulk cipher used by this connection</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The name of the cipher, like ‘aes128’, ‘rc4’, etc.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.isCBCMode">
<code class="descname">isCBCMode</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.isCBCMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if cipher uses CBC mode</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.recvRecord">
<code class="descname">recvRecord</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.recvRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Read, decrypt and check integrity of a single record</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">tuple</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">message header and decrypted message payload</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="tlslite.errors.html#tlslite.errors.TLSDecryptionFailed" title="tlslite.errors.TLSDecryptionFailed"><strong>TLSDecryptionFailed</strong></a> – when decryption of data failed</li>
<li><a class="reference internal" href="tlslite.errors.html#tlslite.errors.TLSBadRecordMAC" title="tlslite.errors.TLSBadRecordMAC"><strong>TLSBadRecordMAC</strong></a> – when record has bad MAC or padding</li>
<li><strong>socket.error</strong> – when reading from socket was unsuccessful</li>
<li><a class="reference internal" href="tlslite.errors.html#tlslite.errors.TLSRecordOverflow" title="tlslite.errors.TLSRecordOverflow"><strong>TLSRecordOverflow</strong></a> – when the received record was longer than
allowed by negotiated version of TLS</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="tlslite.recordlayer.RecordLayer.recv_record_limit">
<code class="descname">recv_record_limit</code><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.recv_record_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum record size that is permitted for receiving.</p>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.sendRecord">
<code class="descname">sendRecord</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.sendRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Encrypt, MAC and send arbitrary message as-is through socket.</p>
<p>Note that if the message was not fragmented to below 2**14 bytes
it will be rejected by the other connection side.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msg</strong> (<a class="reference internal" href="tlslite.messages.html#tlslite.messages.ApplicationData" title="tlslite.messages.ApplicationData"><em>ApplicationData</em></a><em>, </em><em>HandshakeMessage</em><em>, </em><em>etc.</em>) – TLS message to send</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordLayer.shutdown">
<code class="descname">shutdown</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear read and write states</p>
</dd></dl>

<dl class="attribute">
<dt id="tlslite.recordlayer.RecordLayer.tls13record">
<code class="descname">tls13record</code><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.tls13record" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the value of the tls13record state.</p>
</dd></dl>

<dl class="attribute">
<dt id="tlslite.recordlayer.RecordLayer.version">
<code class="descname">version</code><a class="headerlink" href="#tlslite.recordlayer.RecordLayer.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the TLS version used by record layer</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="tlslite.recordlayer.RecordSocket">
<em class="property">class </em><code class="descclassname">tlslite.recordlayer.</code><code class="descname">RecordSocket</code><span class="sig-paren">(</span><em>sock</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordSocket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Socket wrapper for reading and writing TLS Records.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>sock</strong> – wrapped socket</li>
<li><a class="reference internal" href="#tlslite.recordlayer.RecordLayer.version" title="tlslite.recordlayer.RecordLayer.version"><strong>version</strong></a> – version for the records to be encoded on the wire</li>
<li><a class="reference internal" href="#tlslite.recordlayer.RecordLayer.tls13record" title="tlslite.recordlayer.RecordLayer.tls13record"><strong>tls13record</strong></a> – flag to indicate that TLS 1.3 specific record limits
should be used for received records</li>
<li><a class="reference internal" href="#tlslite.recordlayer.RecordLayer.recv_record_limit" title="tlslite.recordlayer.RecordLayer.recv_record_limit"><strong>recv_record_limit</strong></a> (<em>int</em>) – negotiated maximum size of record plaintext
size</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="tlslite.recordlayer.RecordSocket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>sock</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordSocket.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign socket to wrapper</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordSocket.recv">
<code class="descname">recv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordSocket.recv" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a single record from socket, handle SSLv2 and SSLv3 record layer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">generator</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">generator that returns 0 or 1 in case the read would be
blocking or a tuple containing record header (object) and record
data (bytearray) read from socket</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>socket.error</strong> – In case of network error</li>
<li><a class="reference internal" href="tlslite.errors.html#tlslite.errors.TLSAbruptCloseError" title="tlslite.errors.TLSAbruptCloseError"><strong>TLSAbruptCloseError</strong></a> – When the socket was closed on the other
side in middle of record receiving</li>
<li><a class="reference internal" href="tlslite.errors.html#tlslite.errors.TLSRecordOverflow" title="tlslite.errors.TLSRecordOverflow"><strong>TLSRecordOverflow</strong></a> – When the received record was longer than
allowed by TLS</li>
<li><a class="reference internal" href="tlslite.errors.html#tlslite.errors.TLSIllegalParameterException" title="tlslite.errors.TLSIllegalParameterException"><strong>TLSIllegalParameterException</strong></a> – When the record header was
malformed</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="tlslite.recordlayer.RecordSocket.send">
<code class="descname">send</code><span class="sig-paren">(</span><em>msg</em>, <em>padding=0</em><span class="sig-paren">)</span><a class="headerlink" href="#tlslite.recordlayer.RecordSocket.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the message through socket.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msg</strong> (<em>bytearray</em>) – TLS message to send</li>
<li><strong>padding</strong> (<em>int</em>) – amount of padding to specify for SSLv2</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>socket.error</strong> – when write to socket failed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">tlslite-ng</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Hubert Kario.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tlslite.recordlayer.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>