{% load cache %}
{% cache block_timeout inline_app_loader_block gui_version %}
<script type="text/javascript">
    /**
     * Function, that cleans files cache, unregisters current Service Worker instance and reloads page.
     */
    function cleanCacheAndReloadPage() {
        function cleanServiceWorkerCache() {
            if ('caches' in window) {
                window.caches.keys().then(keyList => {
                    keyList.forEach(key => {
                        window.caches.delete(key);
                    })
                });
            }

            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    if (registrations.length == 0) {
                        window.location.reload(true);
                    }

                    let promises = [];

                    registrations.forEach(registration => {
                        promises.push(registration.unregister());
                    });

                    Promise.all(promises).then(response => {
                        window.location.reload(true);
                    });
                })
            } else {
                window.location.reload(true);
            }
        }

        window.guiFilesCache.deleteAllCache().then(res => cleanServiceWorkerCache());
    }

    /**
     * Handler for window.onerror event, that should be called during Files loading.
     */
    function onLoadingErrorHandler(event) {
        if(window && window.guiFilesLoader && window.guiFilesLoader.appendError &&
            typeof window.guiFilesLoader.appendError == "function") {
            window.guiFilesLoader.appendError(event.error);
        }
    }

    /**
     * Function selects DOM elements by selector and push them into JQ Class constructor.
     * If typeof selector is 'string', function will find DOM element,
     * appropriate to this selector.
     * If typeof selector is 'object' function will push selector.
     * @param {string, object} selector DOM element or DOM elements' selector.
     * @return {object} JQ Class instance.
     */
    function jqConstructor(selector) {
        function _getElement(selector) {
            if(typeof selector == "object") {
                return selector;
            }

            if(typeof selector != "string") {
                return;
            }

            selector = selector.trim();
            let method = 'getElementsByTagName';

            if(selector[0] == "#") {
                method = 'getElementById';
                selector = selector.slice(1);
            } else if(selector[0] == ".") {
                method = 'getElementsByClassName';
                selector = selector.slice(1);
            }

            return document[method](selector);
        }

        return new JQ(_getElement(selector));
    }

    /**
     * Class, that provides some methods, that make DOM manipulations easier.
     * Simple analog of JQuery, has only basic methods.
     */
    class JQ {
        /**
         * Constructor of JQ Class.
         * @param {object, HTMLCollection} elements DOM elements, that should be edited.
         */
        constructor(elements) {
            if(!elements) {
                this.length = 0;
            } else {
                if (elements.length) {
                    for (let i = 0; i < elements.length; i++) {
                        this[i] = elements[i];
                    }
                    this.length = elements.length;
                } else {
                    this[0] = elements;
                    this.length = 1;
                }

                let props = [];
                for(let i = 0; i < this.length; i++) {
                    if(!this[i]) {
                        continue;
                    }
                    props.push(this[i]);
                }

                Object.defineProperty(this, 'elements', {
                    value: props,
                });
            }
        }
        /**
         * Static method.
         * This method is supposed to be called from fadeIn and fadeOut methods.
         * @param {number, string} speed Animation speed.
         */
        static getSpeed(speed) {
            let speed_props = {
                fast: 50,
                normal: 150,
                slow: 300,
            };

            if(typeof speed == "string") {
                if(speed_props[speed]) {
                    speed = speed_props[speed];
                }
            }

            if(!speed) {
                speed = 50;
            }
            return speed;
        }
        /**
         * Method, that inserts into end of DOM element some HTML.
         * @param {string} html HTML, that should be appended.
         */
        append(html) {
            this.elements.forEach(el => {
                el.innerHTML = el.innerHTML + html;
            });
        }
        /**
         * Method, that inserts into beginning of DOM element some HTML.
         * @param {string} html HTML, that should be appended.
         */
        prepend(html) {
            this.elements.forEach(el => {
                el.innerHTML = html + el.innerHTML;
            });
        }
        /**
         * Method, that shows DOM element.
         */
        show() {
            this.elements.forEach(el => {
                let prop = "";
                if(el.jq_props && el.jq_props && el.jq_props.style) {
                    prop = el.jq_props.style.display || "";
                }
                el.style.display = prop;
            });
        }
        /**
         * Method, that hides DOM element.
         */
        hide() {
            this.elements.forEach(el => {
                if(el.style.display && el.style.display != "none") {
                    if(!el.jq_props) {
                        el.jq_props = {};
                    }

                    if(!el.jq_props.style) {
                        el.jq_props.style = {};
                    }
                    el.jq_props.style.display = el.style.display;
                }
                el.style.display = "none";
            });
        }
        /**
         * Method, that adds CSS class to DOM element.
         * @param {string} item CSS class, that should be added.
         */
        addClass(item) {
            this.elements.forEach(el => {
                if(el.className.indexOf(item) == -1) {
                    el.className += " " + item;
                }
            });
        }
        /**
         * Method, that removes CSS class from DOM element.
         * @param {string} item CSS class, that should be removed.
         */
        removeClass(item) {
            this.elements.forEach(el => {
                el.className = el.className.replace(item, "");
            });
        }
        /**
         * Method, that smoothly shows DOM element.
         * @param {number, string} speed Animation speed.
         */
        fadeIn(speed) {
            speed = this.constructor.getSpeed(speed);

            this.elements.forEach(el => {
                let prop = 1;
                if(el.jq_props && el.jq_props.style && el.jq_props.style.opacity) {
                    prop = el.jq_props.style.opacity;
                }
                let interval_id = setInterval(() => {
                    jqConstructor(el).show();

                    if (!el.style.opacity || el.style.opacity == "0") {
                        el.style.opacity = 0;
                    }

                    if (el.style.opacity < prop) {
                        el.style.opacity = Number(el.style.opacity) + 0.1;
                    } else {
                        if(!(el.jq_props && el.jq_props.style &&
                            el.jq_props.style.opacity)) {
                            el.style.opacity = "";
                        }
                        clearInterval(interval_id);
                    }
                }, speed);
            });
        }
        /**
         * Method, that smoothly hides DOM element.
         * @param {number, string} speed Animation speed.
         */
        fadeOut(speed) {
            speed = this.constructor.getSpeed(speed);

            this.elements.forEach(el => {
                let prop = 1;
                if(el.style.opacity && el.style.opacity != "0") {
                    if(!el.jq_props) {
                        el.jq_props = {};
                    }

                    if(!el.jq_props.style) {
                        el.jq_props.style = {};
                    }
                    prop = el.jq_props.style.opacity = el.style.opacity;
                }

                let interval_id = setInterval(() => {
                    if (!el.style.opacity) {
                        el.style.opacity = prop;
                    }
                    if (el.style.opacity > 0) {
                        el.style.opacity -= 0.1;
                    } else {
                        jqConstructor(el).hide();
                        clearInterval(interval_id);
                    }
                }, speed);
            });
        }
    }

     /**
     * Class, that creates FilesCache instances - Objects, that communicate with indexedDB.
     * More about indexedDB:
     * - https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Basic_Concepts_Behind_IndexedDB
     * - https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB
     */
    class FilesCache {
        /**
         * Constructor of FilesCache class.
         * @param {object} opt Object with options for FilesCache instance.
         */
        constructor(opt={}) {
            this.indexed_db = window.indexedDB || window.mozIndexedDB ||
                window.webkitIndexedDB || window.msIndexedDB;
            this.host_id = "{{host_url}}".replace(/[^0-9A-z]/img, "_");
            this.db_name = 'cache_' + this.host_id + "__";
            this.db_version = 1;
            this.store_name = 'cache_store';

            for(let key in opt) {
                this[key] = opt[key];
            }
        }
        /**
         * Method, that returns promise of connection to FilesCache indexedDB.
         */
        connectDB() {
            return new Promise((resolve, reject) => {
                let request = this.indexed_db.open(this.db_name, this.db_version);

                request.onerror = (err) => {
                    console.error("Error in FilesCache.connectDB().", err);
                    reject(err);
                };

                request.onsuccess = (event) => {
                    let db = event.target.result;

                    db.onerror = function(event) {
                        console.log('indexedDB - db.onerror ', event);
                    };

                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    let db = event.target.result;
                    db.createObjectStore(
                        this.store_name, { keyPath: "path", autoIncrement: true }
                    );
                    this.connectDB().then(resolve, reject)
                }
            })
        }
        /**
         * Method, that returns promise to get file from FilesCache.
         */
        getFile(file_url) {
            return new Promise((resolve, reject) => {
                this.connectDB().then(db => {
                    let transaction = db.transaction([this.store_name], "readonly");
                    let request = transaction.objectStore(this.store_name).get(file_url);

                    transaction.oncomplete = function(event) {
                        db.close();
                    };

                    request.onerror = (err) => {
                        console.error("Error in FilesCache.getFile()", err);
                        reject(err);
                    };

                    request.onsuccess = () => {
                        if(!request.result) {
                            reject();
                            return;
                        }

                        resolve(request.result ? request.result : -1);
                    }
                }, reject);
            });
        }
        /**
         * Method, that returns promise to save file in FilesCache.
         */
        setFile(file_url, file_data) {
            return new Promise((resolve, reject) => {
                this.connectDB().then(db => {
                    let transaction = db.transaction([this.store_name],"readwrite");
                    transaction.oncomplete = (event) => {
                        db.close();
                    };

                    transaction.onerror = (event) => {
                        console.error("Error in FilesCache.setFile().", event);
                    };

                    let objectStore = transaction.objectStore(this.store_name);

                    let request = objectStore.put({path: file_url, data: file_data});

                    request.onerror = (err) => {
                        console.error("Error in FilesCache.setFile()", err);
                        reject(err);
                    };

                    request.onsuccess = () => {
                        if(!request.result) {
                            reject();
                            return;
                        }
                        resolve(request.result ? request.result : -1);
                    }
                }, reject);
            });
        }
        /**
         * Method, that returns promise to delete file from FilesCache.
         */
        delFile(file_url) {
            return new Promise((resolve, reject) => {
                this.connectDB().then(db => {
                    let transaction = db.transaction([this.store_name],"readwrite");
                    transaction.oncomplete = (event) => {
                        db.close();
                    };

                    transaction.onerror = (event) => {
                        console.error("Error in FilesCache.delFile()", event);
                    };

                    let objectStore = transaction.objectStore(this.store_name);
                    let request = objectStore.delete(file_url);

                    request.onerror = (err) => {
                        console.error("Error in FilesCache.detFile()", err);
                        reject(err);
                    };

                    request.onsuccess = () => {
                        resolve(true);
                    }
                }, reject);
            });
        }
        /**
         * Method, that returns promise to delete all file from FilesCache (delete FilesCache indexedDB).
         */
        deleteAllCache() {
            return new Promise((resolve, reject) => {
                let DBDeleteRequest = this.indexed_db.deleteDatabase(this.db_name);

                DBDeleteRequest.onerror = (event) => {
                    console.error("Error during 'deleteAllCache' method execution. ", event);
                    reject(event);
                };

                DBDeleteRequest.onblocked = (event) => {
                    resolve(event);
                };

                DBDeleteRequest.onsuccess = (event) => {
                    resolve(event);
                };
            });
        }
    }

    /**
     * Class, that manages loading static files (tpl, css, js, events)
     * and appending them to html document.
     */
    class FilesLoader {
        /**
         * Constructor of FilesLoader Class.
         */
        constructor(resource_list) {
            /**
             * Array of JS objects, that contain info about files, that should be loaded.
             */
            this.resource_list = resource_list;
            /**
             * Property - simple analog of JQuery.
             * FilesLoader use it, because at the moment of files loading
             * there is no JQuery yet.
             */
            this.jq = jqConstructor;
            /**
             * Boolean property, that means is loader loading files right now or not?
             */
            this.loading = false;
            /**
             * Array, that collects errors occurred during files/app loading.
             */
            this.errors = [];
        }
        /**
         * Method sets current loading operation on the app loading page.
         * @param {string} operation String with name of loading operation.
         */
        setLoadingOperation(operation) {
            let el = document.getElementById("LoadingProgressBarOperation");

            if(!el) {
                return;
            }

            el.innerText = operation;
        }
        /**
         * Method shows animation during loading static files from server.
         */
        setFilesLoadingProgress() {
            let elem = document.getElementById("LoadingProgressBarCount");

            if(!elem) {
                return;
            }

            if(elem.innerText.length == 3) {
                elem.innerText = "";
            }

            elem.innerText += ".";

            setTimeout(() => {
                if(this.loading) {
                    this.setFilesLoadingProgress();
                }
            }, 800);
        }
        /**
         * Method, that changes app loading progress bar value.
         * @param {number} width Value of loading progress bar width.
         */
        setAppLoadingProgress(width) {
            let elem = document.getElementById("LoadingProgressBarLine");

            if(!elem) {
                return;
            }

            elem.style.width = Math.ceil(width) + '%';

            elem = document.getElementById("LoadingProgressBarCount");

            if(!elem) {
                return;
            }

            elem.style.width = Math.ceil(width) + '%';
            elem.innerHTML = Math.ceil(width) * 1  + '%';
        }
        /**
         * Method, that hides loading progress bar and shows App content.
         */
        hideLoadingProgress() {
            this.jq("#RealBody").show();

            this.jq("#LoadingProgressBar").fadeOut();
        }
        /**
         * Method, that adds logs of files loading.
         * @param {object, string} data Logging message.
         * @param {object} extendData Additional logging message.
         */
        appendLog(data, extendData) {
            try {
                let text = "";

                if(!extendData) {
                    extendData = {type:'Log', name:""};
                }

                text += "Type:"+extendData.type+"\t";

                if(extendData.name) text += "Name:"+extendData.name+"\t";

                if(typeof data == "string") {
                    text += data;
                } else {
                    text += "JSON:"+JSON.stringify(data);
                }

                text = '<pre class="LoadingProgressBar-success">' + text + '</pre>';
                this.jq('.LoadingProgressBar-logger-wrapper').append(text);
            } catch(e) {
                this.appendError(e);
            }
        }
        /**
         * Method, that adds to the html document info about file loading error.
         * @param {object, string} exception Error object or string.
         * @param {object} extendData Additional logging message.
         */
        appendError(exception, extendData) {
            this.errors.push(exception);

            try {
                console.error(exception);

                let text = "";

                if(!extendData) {
                    extendData = {type:'Error', name:""};
                }

                text += "Type:"+extendData.type+"\t";

                if(extendData.name) text += "Name:"+extendData.name+"\n";

                if(exception && exception.message) {
                    text += exception.message + "\nstack:\n"+exception.stack;
                } else {
                    text += "JSON exeption:\n"+JSON.stringify(exception);
                }


                text = '<pre class="LoadingProgressBar-error">' + text + '</pre>';
                this.jq('.LoadingProgressBar-logger-wrapper').append(text);
                this.jq(".LoadingProgressBar-logger-wrapper").show();
                this.jq(".LoadingProgressBar-error-msg").show();

                this.jq(".loadInfoWrapper").addClass("need-reload");
            } catch(e) {
                debugger;
                alert("Error in appendError function\n"+JSON.stringify(e));
            }
        }
        /**
         * Method, that creates DOM element for file content.
         * @param {string} type Type (tag) of DOM element.
         * @param {array} attributes Array of objects -
         * DOM element attributes(key, value).
         * @param {object} props Object with properties of DOM element.
         */
        createFileDomElement(type, attributes, props) {
            let el = document.createElement(type);

            attributes.forEach(attr => {
                el.setAttribute(attr.key, attr.value);
            });

            for(let key in props) {
                el[key] = props[key];
            }

            return el;
        }
        /**
         * Method, that appends files synchronously (in 'priority' order) to the page.
         * Firstly, current method adds to the page file with '0' index, then it appends file with '1' index and so on.
         * @param {array} files Resource list.
         * @param {array} response List of responses of files loading.
         * @param {number} index List index of element from files and response arrays.
         */
        appendFilesSync(files, response, index=0) {
            if(this.errors.length > 0) {
                return;
            }

            let item = files[index];
            let handler = 'appendFile_' + item.type;
            if(this[handler]) {
                response[index].text().then(content => {
                    this[handler](item, content);
                    this.appendLog('File was appended to the page - "' + item.name +'"');

                    if(index + 1 == files.length) {
                        this.setAppLoadingProgress(100);
                        tabSignal.emit('resource.loaded');

                        tabSignal.connect('app.version.updated', () => {
                            let text = 'Oops! It looks like version of current page has become outdated. Please, reload the page.';
                            alert(text);
                        });

                        window.addEventListener('storage', function(e) {
                            if(window.gui_version != localStorage.getItem('gui_version')) {
                                tabSignal.emit('app.version.updated');
                            }
                        });
                    } else {
                        let prog = Math.floor(index + 1/files.length * 100);
                        this.setAppLoadingProgress(prog);
                        this.appendFilesSync(files, response, index + 1);
                    }
                });
            }
        }
        /**
         * Method, that appends JS type file to the page.
         * @param {object} file Object with file properties (type, (name)url).
         * @param {string} content File's content.
         */
        appendFile_js(file, content) {
            let attributes = [
                {key: "type", value: "text/javascript"},
                {key: "data-url", value: file.name},
            ];
            let props = {
                innerHTML: content,
            };

            let link = this.createFileDomElement("script", attributes, props);
            document.getElementsByTagName("head")[0].appendChild(link);
        }
        /**
         * Method, that appends CSS type file to the page.
         * @param {object} file Object with file properties (type, (name)url).
         * @param {string} content File's content.
         */
        appendFile_css(file, content) {
            let attributes = [
                {key: "rel", value: "stylesheet"}, {key: "type", value: "text/css"},
                {key: "media", value: "text/css"}, {key: "data-url", value: file.name},
            ];
            let props = {
                rel: 'stylesheet',
                type: 'text/css',
                media: 'all',
                innerHTML: content.replace(
                    /\.\.\/fonts/gmi, hostname + window.guiStaticPath + "fonts"
                ),
            };

            let link = this.createFileDomElement("style", attributes, props);

            document.getElementsByTagName("head")[0].appendChild(link);
        }
        /**
         * Method, that appends TPL type file to the page.
         * @param {object} file Object with file properties (type, (name)url).
         * @param {string} content File's content.
         */
        appendFile_tpl(file, content) {
            let div = this.createFileDomElement("div", [], {innerHTML: content});
            document.getElementsByTagName("body")[0].appendChild(div);
        }
        /**
         * Method checks, that all files were loaded with 200 status.
         * @param {array} response Array with responses of files loading.
         * @return {boolean}
         */
        checkAllFilesLoaded(response) {
            for (let index in response) {
                let item = response[index];

                if (item.status != 200) {
                    throw new Error(item.status + ' error occurred during file loading - "' + item.url + '"');
                }
            }

            return true;
        }
        /**
         * Method, that loads all files form resource_list.
         * Method returns promise of files loading.
         */
        loadAllFiles() {
            let promises = [];

            for (let index in this.resource_list) {
                let item = this.resource_list[index];
                promises.push(fetch(item.name));
            }

            return Promise.all(promises);
        }
        /**
         * Method, that init files loading.
         */
        onReady() {
            console.log("onReady");

            this.loading = true;
            this.setLoadingOperation('loading files');
            this.setFilesLoadingProgress();

            this.loadAllFiles().then(response => {
                this.loading = false;
                this.setLoadingOperation('loading app');
                if(this.checkAllFilesLoaded(response)) {
                    this.appendLog('All static files were successfully loaded');
                    this.appendFilesSync(this.resource_list, response);
                }
            }).catch(error => {
                this.loading = false;
                this.appendError(error);
                throw error;
            });
        }
    }

    ///////////////////////////////////code execution/////////////////////////////////////
    window.guiFilesCache = new FilesCache();
    window.guiFilesLoader = new FilesLoader(window.resourceList);

    if (localStorage['gui_version'] !== gui_version) {
        localStorage['gui_version'] = gui_version;
        cleanCacheAndReloadPage();
    } else {
        localStorage['gui_version'] = gui_version;

        window.addEventListener("error", onLoadingErrorHandler);

        window.guiFilesLoader.onReady();
    }
</script>
{% endcache %}