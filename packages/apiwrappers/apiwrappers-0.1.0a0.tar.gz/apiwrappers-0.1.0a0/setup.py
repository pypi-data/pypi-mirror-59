# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['apiwrappers', 'apiwrappers.drivers']

package_data = \
{'': ['*']}

extras_require = \
{':python_version >= "3.7" and python_version < "3.8"': ['typing-extensions>=3.7.4,<4.0.0'],
 'aiohttp': ['aiohttp>=3.6.2,<4.0.0'],
 'requests': ['requests>=2.22.0,<3.0.0']}

setup_kwargs = {
    'name': 'apiwrappers',
    'version': '0.1.0a0',
    'description': 'apiwrappers is a library for building API wrappers that work both with regular and async code',
    'long_description': '========\nOverview\n========\n\n.. start-badges\n\n.. image:: https://github.com/unmade/apiwrappers/workflows/lint%20and%20test/badge.svg?branch=master\n    :alt: Build Status\n    :target: https://github.com/unmade/apiwrappers/blob/master/.github/workflows/lint-and-test.yml\n\n.. image:: https://codecov.io/gh/unmade/apiwrappers/branch/master/graph/badge.svg\n    :alt: Coverage Status\n    :target: https://codecov.io/gh/unmade/apiwrappers\n\n.. image:: http://www.mypy-lang.org/static/mypy_badge.svg\n    :alt: Checked with mypy\n    :target: http://mypy-lang.org/\n\n.. image:: https://img.shields.io/pypi/v/apiwrappers.svg\n    :alt: PyPI Package latest release\n    :target: https://pypi.org/project/apiwrappers\n\n.. image:: https://img.shields.io/pypi/pyversions/apiwrappers.svg\n    :alt: Supported versions\n    :target: https://pypi.org/project/apiwrappers\n\n.. image:: https://img.shields.io/badge/License-MIT-purple.svg\n    :alt: MIT License\n    :target: https://github.com/unmade/apiwrappers/blob/master/LICENSE\n\n.. end-badges\n\n----------\n\n*apiwrappers* is a library for building API wrappers\nthat work both with regular and async code.\n\nFeatures\n========\n\n- **Fast to code** - bootstrap API wrappers with minimal efforts\n  and declarative style\n- **No code duplication** - support both sync and async implementations\n  with one wrapper\n- **Unified interface** - work with different python HTTP client libraries\n  in the same way. Currently it supports:\n\n    - `requests <https://requests.readthedocs.io/en/master/>`_\n    - `aiohttp <https://docs.aiohttp.org/en/stable/client.html>`_\n\n- **Customizable** - middleware mechanism to customize request/response\n- **Typed** - library is fully typed and it is relatively easy\n  to get fully type annotated wrapper\n\nInstallation\n============\n\n.. code-block:: bash\n\n    pip install apiwrappers[requests,aiohttp]\n\n*Note: extras are optional and mainly needed for the final\nuser of your future API wrapper*\n\nQuickstart\n==========\n\nEach wrapper needs a HTTP client to make request to the API.\n\n*apiwrappers* provides common interface (drivers) for\nthe most popular HTTP clients.\nLet\'s learn how to make a simple request:\n\n.. code-block:: python\n\n    >>> from apiwrappers import Method, Request, make_driver\n    >>> request = Request(Method.GET, "https://example.org", "/")\n    >>> driver = make_driver("requests")\n    >>> response = driver.fetch(request)\n    >>> response.status_code\n    200\n    >>> response.headers["content-type"]\n    \'text/html; charset=UTF-8\'\n    >>> response.text()\n    \'<!doctype html>\\n<html>\\n<head>\\n<title>Example Domain</title>...\'\n\nOr using asynchronous driver:\n\n*Use IPython or Python 3.8+ with python -m asyncio\nto try this code interactively*\n\n.. code-block:: python\n\n    >>> driver = make_driver("aiohttp")\n    >>> response = await driver.fetch(request)\n    >>> response.status_code\n    200\n\n\nWriting a simple API wrapper\n----------------------------\n\nNow, that we learned how to make HTTP requests,\nlet\'s build our first API wrapper:\n\n.. code-block:: python\n\n    from typing import Awaitable, Generic, List, Mapping, TypeVar, overload\n\n    from apiwrappers import AsyncDriver, Driver, Method, Request, Response, make_driver\n\n    T = TypeVar("T", Driver, AsyncDriver)\n\n\n    class Github(Generic[T]):\n        def __init__(self, host: str, driver: T):\n            self.host = host\n            self.driver: T = driver\n\n        @overload\n        def get_repos(self: "Github[Driver]", username: str) -> Response:\n            ...\n\n        @overload\n        def get_repos(self: "Github[AsyncDriver]", username: str) -> Awaitable[Response]:\n            ...\n\n        def get_repos(self, username: str):\n            request = Request(Method.GET, self.host, f"/users/{username}/repos")\n            return self.driver.fetch(request)\n\nHere we defined one method of the `api.github.com <https://api.github.com>`_\nto get all user repos by username.\n\nHowever wrapper has some flaws:\n\n- ``get_repos`` method returns ``Response`` object, but it would be nice\n  to know what data we expect from response, and not deal with a json\n- we had to use overload twice to set correct response type\n  based on driver type\n- it\'s hard to test, because ``get_repos`` method has side-effect and we need\n  either mock ``self.driver.fetch`` call or use third party libraries\n  such as responses, aioresponses, etc...\n\nLet\'s improve our wrapper:\n\n.. code-block:: python\n\n    from __future__ import annotations\n\n    from dataclasses import dataclass\n    from typing import Any, Generic, List, Mapping, TypeVar\n\n    from apiwrappers import AsyncDriver, Driver, Fetch, Method, Request, make_driver\n\n    T = TypeVar("T", Driver, AsyncDriver)\n\n\n    @dataclass\n    class Repo:\n        id: int\n        name: str\n\n        @classmethod\n        def from_dict(cls, item: Mapping[str, Any]) -> Repo:\n            return cls(id=item["id"], name=item["name"])\n\n        @classmethod\n        def from_list(cls, items: List[Mapping[str, Any]]) -> List[Repo]:\n            return [cls.from_dict(item) for item in items]\n\n\n    class Github(Generic[T]):\n        get_repos = Fetch(Repo.from_list)\n\n        def __init__(self, host: str, driver: T):\n            self.host = host\n            self.driver: T = driver\n\n        @get_repos.request\n        def get_repos_request(self, username: str) -> Request:\n            return Request(Method.GET, self.host, f"/users/{username}/repos")\n\nHere we did the following:\n\n#. First, we defined ``Repo`` dataclass that describes what\n   we want to get from response\n#. Next, we used ``Fetch`` descriptor to declare API method\n#. Each ``Fetch`` object also needs a so-called request factory.\n   We provide one by using ``get_repos.request`` decorator\n   on the ``get_repos_request``\n#. ``get_repos_request`` is a pure function and easy to test\n\nNow, our API wrapper is ready for use:\n\n.. code-block:: python\n\n    >>> driver = make_driver("requests")\n    >>> github = Github("https://api.github.com", driver=driver)\n    >>> github.get_repos("unmade")\n    [Repo(id=47463599, name=\'am-date-picker\'),\n     Repo(id=231653904, name=\'apiwrappers\'),\n     Repo(id=144204778, name=\'conway\'),\n     ...\n    ]\n\nTo use it with asyncio all we need to do is provide a proper driver\nand don\'t forget to ``await`` method call:\n\n.. code-block:: python\n\n    >>> driver = make_driver("aiohttp")\n    >>> github = Github("https://api.github.com", driver=driver)\n    >>> await github.get_repos("unmade")\n    [Repo(id=47463599, name=\'am-date-picker\'),\n     Repo(id=231653904, name=\'apiwrappers\'),\n     Repo(id=144204778, name=\'conway\'),\n     ...\n    ]\n\n\n*In the example above only return type will be annotated and checked by mypy.\nMethod arguments will not be checked by mypy, since it has some limitations\non defining generic callable args. If you want to have fully type annotated\nwrapper, then you still have to use overload decorator.*\n',
    'author': 'Aleksei Maslakov',
    'author_email': 'lesha.maslakov@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'extras_require': extras_require,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
