from ticdat.utils import verify, containerish, stringish, find_duplicates_from_dict_ticdat
from ticdat.utils import find_case_space_duplicates
import ticdat.utils as tu
from ticdat.ticdatfactory import TicDatFactory
import os, subprocess, inspect, time, uuid, shutil
from collections import defaultdict
from ticdat.jsontd import make_json_dict

INFINITY = 999999

def _code_dir():
    return os.path.dirname(os.path.abspath(inspect.getsourcefile(_code_dir)))

def lingo_run(lng_file, input_tdf, input_dat, soln_tdf, infinity=INFINITY, runlingo_path=None):
    """
    solve an optimization problem using an Lingo .lng file

    :param lng_file: An Lingo .lng file.

    :param input_tdf: A TicDatFactory defining the input schema

    :param input_dat: A TicDat object consistent with input_tdf

    :param soln_tdf: A TicDatFactory defining the solution variables

    :param infinity: A number used to represent infinity in Lingo

    :param runlingo_path: A path to the runlingo executable

    :return: a TicDat object consistent with soln_tdf, or None if no solution found
    """
    verify(os.path.isfile(lng_file), "lng_file %s is not a valid file."%lng_file)
    verify(not find_case_space_duplicates(input_tdf),
           "There are case space duplicate field names in the input schema.")
    verify(not find_case_space_duplicates(soln_tdf),
           "There are case space duplicate field names in the solution schema.")
    verify(len({input_tdf.lingo_prepend + t for t in input_tdf.all_tables}.union(
               {soln_tdf.lingo_prepend + t for t in soln_tdf.all_tables})) ==
           len(input_tdf.all_tables) + len(soln_tdf.all_tables),
           "There are colliding input and solution table names.\nSet lingo_prepend so " +
           "as to insure the input and solution table names are effectively distinct.")
    msg = []
    verify(input_tdf.good_tic_dat_object(input_dat, msg.append),
           "tic_dat not a good object for the input_tdf factory : %s"%"\n".join(msg))
    mapping = _try_create_space_case_mapping(input_tdf, input_dat)
    verify("failures" not in mapping, "The following case-space mapping data collisions were found.\n%s"%
                                       mapping.get("failures"))
    input_dat = _apply_space_case_mapping(input_tdf, input_dat, {v:k for k,v in mapping["mapping"].items()})
    orig_input_tdf, orig_soln_tdf = input_tdf, soln_tdf
    input_dat = input_tdf.TicDat(**make_json_dict(orig_input_tdf, input_dat))
    assert input_tdf.good_tic_dat_object(input_dat)
    lng_file_name = os.path.basename(lng_file)[:-4]
    with open(lng_file, "r") as f:
        lng = f.read()
        assert ("ticdat_" + lng_file_name + ".lng") in lng
        assert ("ticdat_" + lng_file_name + "_output.ldt") in lng
        assert ("ticdat_" + lng_file_name + ".ldt") in lng
    working_dir = os.path.abspath(os.path.dirname(lng_file))
    if tu.development_deployed_environment:
        working_dir = os.path.join(working_dir, "lingoticdat_%s"%uuid.uuid4())
        shutil.rmtree(working_dir, ignore_errors = True)
        os.mkdir(working_dir)
        working_dir = os.path.abspath(working_dir)
        _ = os.path.join(working_dir, os.path.basename(lng_file))
        shutil.copy(lng_file, _)
        lng_file = _
    commandsfile = os.path.join(working_dir, "ticdat_"+lng_file_name+".ltf")
    ldtfile = os.path.join(working_dir, "ticdat_"+lng_file_name+".ldt")
    output_txt = os.path.join(working_dir, "output.txt")
    soln_tables = {t for t, pk in soln_tdf.primary_key_fields.items() if pk}
    results = []
    for tbn in soln_tables:
        fn = os.path.join(working_dir, tbn+".ldt")
        if os.path.isfile(fn):
            os.remove(fn)
        results.append(fn)
    with open(ldtfile, "w") as f:
        f.write(create_lingo_text(input_tdf, input_dat, infinity))
    verify(os.path.isfile(ldtfile), "Could not create ticdat_" + lng_file_name+".ldt")
    with open(os.path.join(working_dir, "ticdat_"+lng_file_name+".lng"), "w") as f:
        f.write("! Autogenerated input file, created by lingo.py on " + time.asctime() + " ;\n")
        f.write(create_lingo_mod_text(orig_input_tdf))
    with open(os.path.join(working_dir,"ticdat_"+lng_file_name+"_output.ldt"), "w") as f:
        f.write("! Autogenerated output file, created by lingo.py on " + time.asctime() + " ;\n")
        f.write(create_lingo_output_text(orig_soln_tdf))
    commands = [
        "! Autogenerated commands file, created by lingo.py on " + time.asctime() + " ;",
        "TAKE " + lng_file,
        "GO",
        "QUIT"
    ]
    with open(commandsfile, "w") as f:
        f.write("\n".join(commands))
    if not runlingo_path:
        if 'TICDAT_LINGO_PATH' in os.environ:
            runlingo_path = os.environ['TICDAT_LINGO_PATH']
        else:
            verify_str = "need to either pass runlingo_path argument or run lingo_run_setup.py"
            if tu.development_deployed_environment:
                verify_str = "Could not find runlingo. Make sure the Application Type is set correctly"
            verify(os.path.isfile(os.path.join(_code_dir(),"runlingo_path.txt")), verify_str)
            with open(os.path.join(_code_dir(),"runlingo_path.txt"),"r") as f:
                runlingo_path = f.read().strip()
    verify(os.path.isfile(runlingo_path), "%s not a valid path to runlingo"%runlingo_path)
    output = ''
    try:
        output = subprocess.check_output([runlingo_path, commandsfile], stderr=subprocess.STDOUT, cwd=working_dir)
    except subprocess.CalledProcessError as err:
        if tu.development_deployed_environment:
            raise Exception("runlingo failed to complete: " + str(err.output))
    with open(output_txt, "w") as f:
        f.write(str(output))
    output_data = {}
    for i in zip(soln_tables,results):
        if not os.path.isfile(i[1]):
            print("%s is not a valid file. A solution was likely not generated. Check 'output.txt' for details."%i[1])
            return None
        with open(i[1], "r") as f:
            output_data[i[0]] = f.read()
    rtn = read_lingo_text(soln_tdf, output_data)
    return _apply_space_case_mapping(soln_tdf, rtn, mapping["mapping"])

_can_run_lingo_run_tests = os.path.isfile(os.path.join(_code_dir(),"runlingo_path.txt")) or "TICDAT_LINGO_PATH" in os.environ

def create_lingo_output_text(tdf):
    """
    Generate a Lingo output .ldt string from a TicDat object.
    :param tdf: A TicDatFactory defining the output schema
    :return: A string consistent with the Lingo .ldt format
    """
    prepend = getattr(tdf, "lingo_prepend", "")
    dict_tables = {t for t, pk in tdf.primary_key_fields.items() if pk}
    rtn = 'data:\n'
    for tbn in dict_tables:
        p_tbn = prepend + tbn
        rtn += '\t@TEXT(\"' + tbn + ".ldt\") = " + p_tbn
        for fk in tdf.data_fields[tbn]:
            rtn += ", " + p_tbn + "_" + fk.lower().replace(" ","")
        rtn += ";\n"
    rtn += 'enddata'
    return rtn

def create_lingo_text(tdf, tic_dat, infinity=INFINITY):
    """
    Generate a Lingo .ldt string from a TicDat object

    :param tdf: A TicDatFactory defining the schema

    :param tic_dat: A TicDat object consistent with tdf

    :param infinity: A number used to represent infinity in lingo

    :return: A string consistent with the Lingo .ldt format
    """
    msg = []
    verify(tdf.good_tic_dat_object(tic_dat, msg.append),
           "tic_dat not a good object for this factory : %s"%"\n".join(msg))
    verify(not tdf.generator_tables, "doesn't work with generator tables.")
    verify(not tdf.generic_tables, "doesn't work with generic tables. (not yet - will add ASAP as needed) ")
    dict_with_lists = defaultdict(list)
    dict_tables = {t for t,pk in tdf.primary_key_fields.items() if pk}
    prepend = getattr(tdf, "lingo_prepend", "")
    for t in dict_tables:
        for k,r in getattr(tic_dat, t).items():
            row = list(k) if containerish(k) else [k]
            for f in tdf.data_fields.get(t, []):
                row.append(r[f])
            dict_with_lists[t].append(row)
    for t in set(tdf.all_tables).difference(dict_tables):
        for r in getattr(tic_dat, t):
            row = [r[f] for f in tdf.data_fields[t]]
            dict_with_lists[t].append(row)
    rtn = "data:\n"
    for t in _sorted_tables(tdf):
        rtn += "%s"%(prepend + t)
        for field in tdf.data_fields[t]:
            rtn += ',' + prepend + t + "_" + field.replace(" ", "_").lower()
        rtn += "=\n"
        for row in dict_with_lists[t]:
            rtn += "\t"
            for field in row:
                if stringish(field):
                    rtn += field + " "
                else:
                    rtn += str(infinity) if float('inf') == field else str(field) + " "
            rtn += "\n"
        rtn += ";\n"
    rtn+="enddata"
    return rtn

def create_lingo_mod_text(tdf):
    """
    Generate a Lingo .lng string from a TicDat object for diagnostic purposes

    :param tdf: A TicDatFactory defining the input schema

    :return: A string consistent with the Lingo .lng input format
    """
    verify(not find_case_space_duplicates(tdf), "There are case space duplicate field names in the schema.")
    verify(not tdf.generator_tables, "Input schema error - doesn't work with generator tables.")
    verify(not tdf.generic_tables, "Input schema error - doesn't work with generic tables. (not yet - will \
            add ASAP as needed) ")
    rtn = 'sets:\n'
    dict_tables = {t for t, pk in tdf.primary_key_fields.items() if pk}
    verify(set(dict_tables) == set(tdf.all_tables), "not yet handling non-PK tables of any sort")

    prepend = getattr(tdf, "lingo_prepend", "")

    def get_table_as_mod_text(tdf, tbn):
        p_tbn = prepend + tbn
        rtn = p_tbn
        if len(tdf.primary_key_fields[tbn]) > 1:
            fkr = []
            for i in range(len(tdf.primary_key_fields[tbn])):
                pk = tdf.primary_key_fields[tbn][i]
                fk = list(filter(lambda k: k.native_table == tbn and k.mapping.native_field == pk, tdf.foreign_keys))
                verify(len(fk) == 1, "Table '%s' needs to fully link it's primary key fields to parent tables via"
                                     " foreign keys."%tbn)
                fkr.append(prepend + fk[0].foreign_table)
            rtn += '(' + ','.join(fkr) + ')'
        rtn += ':'
        fields = []
        for df in tdf.data_fields[tbn]:
            df_m = p_tbn + '_' + df.replace(' ', '_').lower()
            fields.append(df_m)
        rtn += ','.join(fields)
        rtn += ';\n'
        return rtn

    for t in _sorted_tables(tdf):
        rtn += get_table_as_mod_text(tdf, t)
    rtn+='endsets'
    return rtn

def read_lingo_text(tdf,results_text):
    """
    Read Lingo .ldt strings

    :param tdf: A TicDatFactory defining the schema

    :param results_text: A list of strings defining Lingo tables

    :return: A TicDat object consistent with tdf
    """

    for i in results_text.values():
        verify(stringish(i), "text needs to be a string")

    def _get_as_type(val):
        try:
            return float(val)
        except ValueError:
            return val

    dict_with_lists = defaultdict(list)

    for tbn in results_text:
        rows = []
        text = results_text[tbn].strip().split("\n")
        for line in text:
            rows.append(list(map(lambda k: _get_as_type(k),line.strip().split())))
        dict_with_lists[tbn] = rows


    assert not find_duplicates_from_dict_ticdat(tdf, dict_with_lists), \
            "duplicates were found - if asserts are disabled, duplicate rows will overwrite"

    return tdf.TicDat(**{k.replace(tdf.lingo_prepend,"",1):v for k,v in dict_with_lists.items()})

def _try_create_space_case_mapping(tdf, ticdat):
    '''
    :param tdf: a TicDatFactory
    :param ticdat: a ticdat for the tdf
    :return: {"mapping:mapping} if a good mapping can be made, else {"failures":failures}
    '''
    assert tdf.good_tic_dat_object(ticdat), "ticdat not a good object for the tdf"
    rtn = defaultdict(set)
    for t in tdf.all_tables:
        if tdf.primary_key_fields.get(t):
            for ks in getattr(ticdat, t):
                for k in (ks if containerish(ks) else [ks]):
                    if stringish(k):
                        newk = ''.join(list(map(lambda c: c.upper() if c.isalnum() else '_', k)))
                        rtn[newk].add(k)
    failures = {k:tuple(sorted(v)) for k,v in rtn.items() if len(v) > 1}
    if failures:
        return {"failures":failures}
    return {"mapping": {k:next(iter(v)) for k,v in rtn.items()}}

def _apply_space_case_mapping(tdf, ticdat, mapping):
    """
    :param tdf: a TicDatFactory
    :param ticdat: a ticdat for the tdf
    :param mapping: the mapping returned by an earlier call to _try_create_space_case_mapping.
                    **Should be the value in the {"mapping":mapping} dict, if such a dict was
                      returned, and not the {"mapping":mapping} dict itself.
    :return:
    """
    assert tdf.good_tic_dat_object(ticdat), "ticdat not a good object for the tdf"
    assert tu.dictish(mapping)
    def apply_mapping(k):
        if containerish(k):
            return tuple(list(map(apply_mapping, k)))
        return mapping.get(k, k)
    rtn = tdf.copy_tic_dat(ticdat)
    for t in tdf.all_tables:
        if tdf.primary_key_fields.get(t):
            for k,v in getattr(ticdat, t).items():
                del getattr(rtn, t)[k]
                getattr(rtn, t)[apply_mapping(k)] = v
    return rtn


def _sorted_tables(tdf):
    """
    :param tdf: a TicDatFactory
    :return: A list of tables that is sorted so primary keys are defined before other tables where they are used
    """
    ordered_tables = []
    dict_tables = {t for t, pk in tdf.primary_key_fields.items() if pk}
    def next_table(tbn):
        fks = list(filter(lambda k: k.native_table == tbn, tdf.foreign_keys))
        if len(fks) == 0:
            return [tbn]
        tables = []
        for fk in fks:
            if fk.foreign_table not in tables + ordered_tables:
                tables += next_table(fk.foreign_table)
        return tables + [tbn]

    for tbn in dict_tables:
        for table in next_table(tbn):
            if table not in ordered_tables:
                ordered_tables.append(table)
    return ordered_tables