from typing import Type
from base58 import b58encode

from pyost.rpc.pb import rpc_pb2 as pb
from pyost.algorithm import Algorithm, get_algorithm_by_id
from pyost.simpleencoder import SimpleEncoder


class Signature:
    """Contains the signature of a message and the public key to verify it.

    Args:
        algo_cls: The class type of the `Algorithm` to use to sign the message.
        message: The binary message to sign.
        seckey: The secret key to use to sign the message.

    Attributes:
        algo_cls: The class type of the `Algorithm` used to sign the message.
        sig: The binary signature of the message.
        pubkey: The public key corresponding to the private key that signed the message.
    """
    def __init__(self, algo_cls: Type[Algorithm] = Algorithm, message: bytes = None, seckey: bytes = None):
        self.algo_cls: Type[Algorithm] = algo_cls
        self.sig: bytes = algo_cls.sign(message, seckey)
        self.pubkey: bytes = algo_cls.get_pubkey(seckey)

    def __str__(self) -> str:
        return f"'algo': {self.algo_cls.__int__()}\n" \
            f"'sig': '{b58encode(self.sig)}'\n" \
            f"'pubkey': '{b58encode(self.pubkey)}'"

    def verify(self, message: bytes) -> bool:
        """Tells whether the owner of the public key has signed a message.

        Args:
            message: The binary message to verify.

        Returns:
            ``True`` if the sig was generated from the same message and the public key's corresponding private key.

        Raises:
            ValueError: If this `Signature` has not been properly initialized.
        """
        if self.pubkey is None or self.sig is None:
            raise ValueError('The Signature is missing pubkey and/or sig.')
        return self.algo_cls.verify(message, self.pubkey, self.sig)

    def from_raw(self, sr: pb.Signature) -> None:
        """Deserializes a protobuf object to update this object's members.

        Args:
            sr: The protobuf object.

        Returns:
            Itself.
        """
        self.algo_cls = get_algorithm_by_id(sr.algorithm)
        self.sig = sr.signature
        self.pubkey = sr.public_key

    def to_raw(self) -> pb.Signature:
        """Serializes this object's members to a protobuf object.

        Returns:
            A protobuf object.
        """
        return pb.Signature(
            algorithm=self.algo_cls.__int__(),
            signature=self.sig,
            public_key=self.pubkey,
        )

    def to_bytes(self) -> bytes:
        """Serializes this object to bytes, used to calculate the hash of a `Transaction`.

        Returns:
            A binary representation of this object.
        """
        se = SimpleEncoder()
        se.write_bytes(self.algo_cls.__int__().to_bytes(1, se.byteorder, signed=False), False)
        se.write_bytes(self.sig)
        se.write_bytes(self.pubkey)
        return se.to_bytes()


class KeyPair:
    """Contains a pair of public and private keys for a given `Algorithm`.

    Args:
        algo_cls: The class type of the `Algorithm` to use, such as `Ed25519`.
        seckey: The secret key, if None a new secret key will be generated with the `Algorithm` factory method.

    Attributes:
        algo_cls: The class type of the `Algorithm` used to create the keys.
        seckey: The secret key generated by the `Algorithm`.
        pubkey: The public key inferred from the secret key.
    """
    def __init__(self, algo_cls: Type[Algorithm], seckey: bytes = None):
        self.algo_cls: Type[Algorithm] = algo_cls
        self.seckey: bytes = seckey if seckey is not None else algo_cls.gen_seckey()
        self.pubkey: bytes = algo_cls.get_pubkey(self.seckey)

    def __repr__(self):
        return f"{{'algo_cls': {self.algo_cls.__int__()},\n" \
            f"'pubkey': '{b58encode(self.pubkey)}',\n" \
            f"'seckey': '{b58encode(self.seckey)}'}}"

    def __str__(self):
        return self.__repr__()

    def sign(self, message: bytes) -> Signature:
        """Signs a binary message.

        Args:
            message: The binary message to sign.

        Returns:
            A `Signature` made from the `message` and the private key.
        """
        return Signature(self.algo_cls, message, self.seckey)
